// Generated from ClickHouseParser.g4 by ANTLR 4.7.

package parser // ClickHouseParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 180, 1171, 
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44, 
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4, 
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55, 
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9, 
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65, 
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4, 
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76, 
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9, 
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86, 
	4, 87, 9, 87, 3, 2, 3, 2, 5, 2, 177, 10, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 
	3, 195, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 7, 4, 201, 10, 4, 12, 4, 14, 4, 
	204, 11, 4, 3, 4, 5, 4, 207, 10, 4, 3, 4, 5, 4, 210, 10, 4, 3, 5, 5, 5, 
	213, 10, 5, 3, 5, 3, 5, 5, 5, 217, 10, 5, 3, 5, 5, 5, 220, 10, 5, 3, 5, 
	5, 5, 223, 10, 5, 3, 5, 5, 5, 226, 10, 5, 3, 5, 5, 5, 229, 10, 5, 3, 5, 
	5, 5, 232, 10, 5, 3, 5, 5, 5, 235, 10, 5, 3, 5, 5, 5, 238, 10, 5, 3, 5, 
	5, 5, 241, 10, 5, 3, 5, 5, 5, 244, 10, 5, 3, 5, 5, 5, 247, 10, 5, 3, 5, 
	5, 5, 250, 10, 5, 3, 5, 5, 5, 253, 10, 5, 3, 6, 3, 6, 3, 6, 3, 7, 3, 7, 
	5, 7, 260, 10, 7, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 268, 10, 8, 
	3, 8, 5, 8, 271, 10, 8, 3, 9, 5, 9, 274, 10, 9, 3, 9, 3, 9, 3, 9, 3, 9, 
	3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 284, 10, 10, 3, 11, 3, 11, 3, 11, 5, 
	11, 289, 10, 11, 3, 12, 5, 12, 292, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 
	5, 12, 298, 10, 12, 3, 12, 3, 12, 5, 12, 302, 10, 12, 3, 12, 3, 12, 5, 
	12, 306, 10, 12, 5, 12, 308, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 
	3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 319, 10, 12, 3, 12, 5, 12, 322, 10, 
	12, 3, 12, 3, 12, 3, 12, 5, 12, 327, 10, 12, 3, 13, 3, 13, 5, 13, 331, 
	10, 13, 3, 14, 3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 
	3, 16, 3, 16, 5, 16, 344, 10, 16, 3, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3, 
	18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 357, 10, 19, 3, 20, 3, 20, 
	3, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 3, 23, 3, 
	23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 376, 10, 23, 3, 23, 3, 23, 3, 23, 
	3, 23, 5, 23, 382, 10, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 7, 23, 389, 
	10, 23, 12, 23, 14, 23, 392, 11, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 
	3, 23, 7, 23, 400, 10, 23, 12, 23, 14, 23, 403, 11, 23, 3, 23, 3, 23, 7, 
	23, 407, 10, 23, 12, 23, 14, 23, 410, 11, 23, 3, 23, 3, 23, 3, 23, 5, 23, 
	415, 10, 23, 3, 24, 3, 24, 5, 24, 419, 10, 24, 3, 24, 3, 24, 3, 24, 3, 
	24, 5, 24, 425, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 432, 
	10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 438, 10, 24, 3, 24, 3, 24, 3, 
	24, 3, 24, 3, 24, 3, 24, 5, 24, 446, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 
	3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 457, 10, 24, 3, 24, 5, 24, 460, 
	10, 24, 3, 24, 5, 24, 463, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 
	24, 470, 10, 24, 5, 24, 472, 10, 24, 5, 24, 474, 10, 24, 3, 24, 5, 24, 
	477, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 483, 10, 24, 3, 24, 3, 
	24, 3, 24, 3, 24, 3, 24, 5, 24, 490, 10, 24, 3, 24, 5, 24, 493, 10, 24, 
	3, 24, 5, 24, 496, 10, 24, 3, 24, 3, 24, 3, 24, 5, 24, 501, 10, 24, 3, 
	25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 7, 25, 
	513, 10, 25, 12, 25, 14, 25, 516, 11, 25, 3, 25, 3, 25, 3, 25, 5, 25, 521, 
	10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 527, 10, 26, 3, 26, 3, 26, 3, 
	26, 3, 26, 5, 26, 533, 10, 26, 3, 26, 3, 26, 3, 26, 5, 26, 538, 10, 26, 
	3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 544, 10, 26, 5, 26, 546, 10, 26, 3, 
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 554, 10, 27, 3, 27, 3, 27, 
	3, 27, 7, 27, 559, 10, 27, 12, 27, 14, 27, 562, 11, 27, 3, 28, 3, 28, 3, 
	28, 3, 28, 3, 28, 5, 28, 569, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 595, 
	10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 603, 10, 29, 12, 
	29, 14, 29, 606, 11, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 
	3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 620, 10, 29, 12, 29, 14, 29, 
	623, 11, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 632, 
	10, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 649, 10, 30, 12, 30, 14, 
	30, 652, 11, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 
	661, 10, 30, 12, 30, 14, 30, 664, 11, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 
	3, 30, 3, 30, 3, 30, 5, 30, 684, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 
	32, 3, 32, 3, 32, 3, 33, 3, 33, 5, 33, 695, 10, 33, 3, 33, 3, 33, 3, 34, 
	3, 34, 3, 34, 7, 34, 702, 10, 34, 12, 34, 14, 34, 705, 11, 34, 3, 35, 3, 
	35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 
	3, 37, 3, 37, 3, 37, 5, 37, 722, 10, 37, 3, 37, 5, 37, 725, 10, 37, 3, 
	38, 3, 38, 3, 38, 3, 38, 5, 38, 731, 10, 38, 3, 38, 3, 38, 3, 38, 5, 38, 
	736, 10, 38, 3, 38, 3, 38, 5, 38, 740, 10, 38, 3, 39, 3, 39, 3, 39, 3, 
	39, 3, 39, 5, 39, 747, 10, 39, 3, 39, 5, 39, 750, 10, 39, 3, 39, 3, 39, 
	5, 39, 754, 10, 39, 5, 39, 756, 10, 39, 3, 39, 5, 39, 759, 10, 39, 3, 39, 
	3, 39, 5, 39, 763, 10, 39, 3, 40, 3, 40, 3, 40, 5, 40, 768, 10, 40, 3, 
	40, 3, 40, 5, 40, 772, 10, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 
	3, 42, 5, 42, 781, 10, 42, 3, 42, 3, 42, 3, 43, 3, 43, 5, 43, 787, 10, 
	43, 3, 44, 3, 44, 5, 44, 791, 10, 44, 3, 45, 3, 45, 3, 46, 3, 46, 3, 47, 
	3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 50, 3, 
	50, 5, 50, 809, 10, 50, 3, 51, 3, 51, 5, 51, 813, 10, 51, 3, 52, 3, 52, 
	3, 52, 7, 52, 818, 10, 52, 12, 52, 14, 52, 821, 11, 52, 3, 53, 3, 53, 5, 
	53, 825, 10, 53, 3, 53, 3, 53, 5, 53, 829, 10, 53, 3, 53, 3, 53, 5, 53, 
	833, 10, 53, 3, 54, 3, 54, 3, 54, 3, 54, 7, 54, 839, 10, 54, 12, 54, 14, 
	54, 842, 11, 54, 3, 55, 3, 55, 3, 55, 5, 55, 847, 10, 55, 3, 56, 3, 56, 
	3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 857, 10, 56, 3, 57, 3, 
	57, 3, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 7, 58, 867, 10, 58, 12, 58, 
	14, 58, 870, 11, 58, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 61, 3, 
	61, 3, 61, 7, 61, 881, 10, 61, 12, 61, 14, 61, 884, 11, 61, 3, 62, 3, 62, 
	3, 62, 3, 62, 5, 62, 890, 10, 62, 3, 62, 3, 62, 5, 62, 894, 10, 62, 3, 
	62, 3, 62, 5, 62, 898, 10, 62, 3, 63, 3, 63, 3, 64, 3, 64, 3, 65, 3, 65, 
	3, 65, 7, 65, 907, 10, 65, 12, 65, 14, 65, 910, 11, 65, 3, 66, 3, 66, 3, 
	66, 7, 66, 915, 10, 66, 12, 66, 14, 66, 918, 11, 66, 3, 67, 3, 67, 5, 67, 
	922, 10, 67, 3, 68, 5, 68, 925, 10, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 
	69, 3, 70, 3, 70, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 3, 72, 3, 73, 3, 73, 
	5, 73, 942, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 
	74, 5, 74, 952, 10, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 
	3, 74, 3, 74, 3, 74, 7, 74, 964, 10, 74, 12, 74, 14, 74, 967, 11, 74, 3, 
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 
	74, 3, 74, 7, 74, 992, 10, 74, 12, 74, 14, 74, 995, 11, 74, 3, 74, 3, 74, 
	3, 74, 3, 74, 3, 74, 7, 74, 1002, 10, 74, 12, 74, 14, 74, 1005, 11, 74, 
	5, 74, 1007, 10, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 
	74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 1021, 10, 74, 3, 74, 3, 74, 3, 74, 
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 1053, 10, 74, 3, 74, 3, 
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 1065, 
	10, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 
	74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 1091, 10, 74, 3, 74, 3, 74, 7, 74, 
	1095, 10, 74, 12, 74, 14, 74, 1098, 11, 74, 3, 75, 3, 75, 3, 76, 5, 76, 
	1103, 10, 76, 3, 77, 3, 77, 3, 77, 7, 77, 1108, 10, 77, 12, 77, 14, 77, 
	1111, 11, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 79, 3, 79, 5, 79, 1119, 10, 
	79, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80, 7, 80, 1127, 10, 80, 12, 
	80, 14, 80, 1130, 11, 80, 5, 80, 1132, 10, 80, 3, 80, 3, 80, 3, 81, 3, 
	81, 3, 81, 3, 81, 7, 81, 1140, 10, 81, 12, 81, 14, 81, 1143, 11, 81, 5, 
	81, 1145, 10, 81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3, 83, 
	5, 83, 1155, 10, 83, 3, 84, 3, 84, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 
	85, 1164, 10, 85, 3, 86, 3, 86, 3, 87, 3, 87, 3, 87, 3, 87, 2, 3, 146, 
	88, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 
	38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 
	74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 
	108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 
	138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 
	168, 170, 172, 2, 15, 4, 2, 6, 6, 10, 10, 4, 2, 16, 16, 26, 26, 4, 2, 36, 
	36, 39, 39, 5, 2, 15, 15, 97, 97, 101, 101, 4, 2, 30, 30, 32, 32, 4, 2, 
	13, 14, 31, 32, 4, 2, 46, 46, 65, 65, 5, 2, 7, 7, 35, 35, 70, 70, 5, 2, 
	127, 127, 133, 133, 135, 135, 4, 2, 128, 128, 134, 134, 9, 2, 28, 28, 54, 
	54, 71, 71, 73, 73, 92, 92, 113, 113, 117, 117, 18, 2, 4, 19, 21, 21, 23, 
	24, 26, 27, 30, 36, 38, 43, 45, 47, 49, 53, 55, 58, 60, 70, 72, 72, 74, 
	91, 93, 104, 106, 107, 109, 112, 114, 116, 4, 2, 75, 75, 176, 177, 2, 1304, 
	2, 176, 3, 2, 2, 2, 4, 194, 3, 2, 2, 2, 6, 196, 3, 2, 2, 2, 8, 212, 3, 
	2, 2, 2, 10, 254, 3, 2, 2, 2, 12, 257, 3, 2, 2, 2, 14, 263, 3, 2, 2, 2, 
	16, 273, 3, 2, 2, 2, 18, 279, 3, 2, 2, 2, 20, 285, 3, 2, 2, 2, 22, 326, 
	3, 2, 2, 2, 24, 330, 3, 2, 2, 2, 26, 332, 3, 2, 2, 2, 28, 335, 3, 2, 2, 
	2, 30, 338, 3, 2, 2, 2, 32, 345, 3, 2, 2, 2, 34, 348, 3, 2, 2, 2, 36, 352, 
	3, 2, 2, 2, 38, 358, 3, 2, 2, 2, 40, 363, 3, 2, 2, 2, 42, 366, 3, 2, 2, 
	2, 44, 369, 3, 2, 2, 2, 46, 416, 3, 2, 2, 2, 48, 502, 3, 2, 2, 2, 50, 522, 
	3, 2, 2, 2, 52, 547, 3, 2, 2, 2, 54, 594, 3, 2, 2, 2, 56, 631, 3, 2, 2, 
	2, 58, 683, 3, 2, 2, 2, 60, 685, 3, 2, 2, 2, 62, 689, 3, 2, 2, 2, 64, 692, 
	3, 2, 2, 2, 66, 698, 3, 2, 2, 2, 68, 706, 3, 2, 2, 2, 70, 710, 3, 2, 2, 
	2, 72, 716, 3, 2, 2, 2, 74, 730, 3, 2, 2, 2, 76, 741, 3, 2, 2, 2, 78, 764, 
	3, 2, 2, 2, 80, 773, 3, 2, 2, 2, 82, 780, 3, 2, 2, 2, 84, 786, 3, 2, 2, 
	2, 86, 790, 3, 2, 2, 2, 88, 792, 3, 2, 2, 2, 90, 794, 3, 2, 2, 2, 92, 796, 
	3, 2, 2, 2, 94, 798, 3, 2, 2, 2, 96, 802, 3, 2, 2, 2, 98, 808, 3, 2, 2, 
	2, 100, 812, 3, 2, 2, 2, 102, 814, 3, 2, 2, 2, 104, 822, 3, 2, 2, 2, 106, 
	834, 3, 2, 2, 2, 108, 846, 3, 2, 2, 2, 110, 848, 3, 2, 2, 2, 112, 858, 
	3, 2, 2, 2, 114, 863, 3, 2, 2, 2, 116, 871, 3, 2, 2, 2, 118, 874, 3, 2, 
	2, 2, 120, 877, 3, 2, 2, 2, 122, 885, 3, 2, 2, 2, 124, 899, 3, 2, 2, 2, 
	126, 901, 3, 2, 2, 2, 128, 903, 3, 2, 2, 2, 130, 911, 3, 2, 2, 2, 132, 
	919, 3, 2, 2, 2, 134, 924, 3, 2, 2, 2, 136, 928, 3, 2, 2, 2, 138, 931, 
	3, 2, 2, 2, 140, 933, 3, 2, 2, 2, 142, 935, 3, 2, 2, 2, 144, 939, 3, 2, 
	2, 2, 146, 1020, 3, 2, 2, 2, 148, 1099, 3, 2, 2, 2, 150, 1102, 3, 2, 2, 
	2, 152, 1104, 3, 2, 2, 2, 154, 1112, 3, 2, 2, 2, 156, 1116, 3, 2, 2, 2, 
	158, 1122, 3, 2, 2, 2, 160, 1135, 3, 2, 2, 2, 162, 1148, 3, 2, 2, 2, 164, 
	1154, 3, 2, 2, 2, 166, 1156, 3, 2, 2, 2, 168, 1163, 3, 2, 2, 2, 170, 1165, 
	3, 2, 2, 2, 172, 1167, 3, 2, 2, 2, 174, 177, 5, 4, 3, 2, 175, 177, 5, 172, 
	87, 2, 176, 174, 3, 2, 2, 2, 176, 175, 3, 2, 2, 2, 177, 178, 3, 2, 2, 2, 
	178, 179, 7, 2, 2, 3, 179, 3, 3, 2, 2, 2, 180, 195, 5, 76, 39, 2, 181, 
	195, 5, 6, 4, 2, 182, 195, 5, 44, 23, 2, 183, 195, 5, 46, 24, 2, 184, 195, 
	5, 48, 25, 2, 185, 195, 5, 50, 26, 2, 186, 195, 5, 52, 27, 2, 187, 195, 
	5, 62, 32, 2, 188, 195, 5, 64, 33, 2, 189, 195, 5, 72, 37, 2, 190, 195, 
	5, 74, 38, 2, 191, 195, 5, 78, 40, 2, 192, 195, 5, 80, 41, 2, 193, 195, 
	5, 70, 36, 2, 194, 180, 3, 2, 2, 2, 194, 181, 3, 2, 2, 2, 194, 182, 3, 
	2, 2, 2, 194, 183, 3, 2, 2, 2, 194, 184, 3, 2, 2, 2, 194, 185, 3, 2, 2, 
	2, 194, 186, 3, 2, 2, 2, 194, 187, 3, 2, 2, 2, 194, 188, 3, 2, 2, 2, 194, 
	189, 3, 2, 2, 2, 194, 190, 3, 2, 2, 2, 194, 191, 3, 2, 2, 2, 194, 192, 
	3, 2, 2, 2, 194, 193, 3, 2, 2, 2, 195, 5, 3, 2, 2, 2, 196, 202, 5, 8, 5, 
	2, 197, 198, 7, 110, 2, 2, 198, 199, 7, 6, 2, 2, 199, 201, 5, 8, 5, 2, 
	200, 197, 3, 2, 2, 2, 201, 204, 3, 2, 2, 2, 202, 200, 3, 2, 2, 2, 202, 
	203, 3, 2, 2, 2, 203, 206, 3, 2, 2, 2, 204, 202, 3, 2, 2, 2, 205, 207, 
	5, 94, 48, 2, 206, 205, 3, 2, 2, 2, 206, 207, 3, 2, 2, 2, 207, 209, 3, 
	2, 2, 2, 208, 210, 5, 42, 22, 2, 209, 208, 3, 2, 2, 2, 209, 210, 3, 2, 
	2, 2, 210, 7, 3, 2, 2, 2, 211, 213, 5, 10, 6, 2, 212, 211, 3, 2, 2, 2, 
	212, 213, 3, 2, 2, 2, 213, 214, 3, 2, 2, 2, 214, 216, 5, 12, 7, 2, 215, 
	217, 5, 14, 8, 2, 216, 215, 3, 2, 2, 2, 216, 217, 3, 2, 2, 2, 217, 219, 
	3, 2, 2, 2, 218, 220, 7, 45, 2, 2, 219, 218, 3, 2, 2, 2, 219, 220, 3, 2, 
	2, 2, 220, 222, 3, 2, 2, 2, 221, 223, 5, 18, 10, 2, 222, 221, 3, 2, 2, 
	2, 222, 223, 3, 2, 2, 2, 223, 225, 3, 2, 2, 2, 224, 226, 5, 16, 9, 2, 225, 
	224, 3, 2, 2, 2, 225, 226, 3, 2, 2, 2, 226, 228, 3, 2, 2, 2, 227, 229, 
	5, 22, 12, 2, 228, 227, 3, 2, 2, 2, 228, 229, 3, 2, 2, 2, 229, 231, 3, 
	2, 2, 2, 230, 232, 5, 26, 14, 2, 231, 230, 3, 2, 2, 2, 231, 232, 3, 2, 
	2, 2, 232, 234, 3, 2, 2, 2, 233, 235, 5, 28, 15, 2, 234, 233, 3, 2, 2, 
	2, 234, 235, 3, 2, 2, 2, 235, 237, 3, 2, 2, 2, 236, 238, 5, 30, 16, 2, 
	237, 236, 3, 2, 2, 2, 237, 238, 3, 2, 2, 2, 238, 240, 3, 2, 2, 2, 239, 
	241, 5, 32, 17, 2, 240, 239, 3, 2, 2, 2, 240, 241, 3, 2, 2, 2, 241, 243, 
	3, 2, 2, 2, 242, 244, 5, 34, 18, 2, 243, 242, 3, 2, 2, 2, 243, 244, 3, 
	2, 2, 2, 244, 246, 3, 2, 2, 2, 245, 247, 5, 38, 20, 2, 246, 245, 3, 2, 
	2, 2, 246, 247, 3, 2, 2, 2, 247, 249, 3, 2, 2, 2, 248, 250, 5, 36, 19, 
	2, 249, 248, 3, 2, 2, 2, 249, 250, 3, 2, 2, 2, 250, 252, 3, 2, 2, 2, 251, 
	253, 5, 40, 21, 2, 252, 251, 3, 2, 2, 2, 252, 253, 3, 2, 2, 2, 253, 9, 
	3, 2, 2, 2, 254, 255, 7, 116, 2, 2, 255, 256, 5, 130, 66, 2, 256, 11, 3, 
	2, 2, 2, 257, 259, 7, 93, 2, 2, 258, 260, 7, 38, 2, 2, 259, 258, 3, 2, 
	2, 2, 259, 260, 3, 2, 2, 2, 260, 261, 3, 2, 2, 2, 261, 262, 5, 130, 66, 
	2, 262, 13, 3, 2, 2, 2, 263, 267, 7, 47, 2, 2, 264, 268, 5, 82, 42, 2, 
	265, 268, 5, 140, 71, 2, 266, 268, 5, 142, 72, 2, 267, 264, 3, 2, 2, 2, 
	267, 265, 3, 2, 2, 2, 267, 266, 3, 2, 2, 2, 268, 270, 3, 2, 2, 2, 269, 
	271, 5, 134, 68, 2, 270, 269, 3, 2, 2, 2, 270, 271, 3, 2, 2, 2, 271, 15, 
	3, 2, 2, 2, 272, 274, 7, 66, 2, 2, 273, 272, 3, 2, 2, 2, 273, 274, 3, 2, 
	2, 2, 274, 275, 3, 2, 2, 2, 275, 276, 7, 11, 2, 2, 276, 277, 7, 63, 2, 
	2, 277, 278, 5, 152, 77, 2, 278, 17, 3, 2, 2, 2, 279, 280, 7, 91, 2, 2, 
	280, 283, 5, 20, 11, 2, 281, 282, 7, 77, 2, 2, 282, 284, 5, 20, 11, 2, 
	283, 281, 3, 2, 2, 2, 283, 284, 3, 2, 2, 2, 284, 19, 3, 2, 2, 2, 285, 288, 
	7, 176, 2, 2, 286, 287, 7, 135, 2, 2, 287, 289, 7, 176, 2, 2, 288, 286, 
	3, 2, 2, 2, 288, 289, 3, 2, 2, 2, 289, 21, 3, 2, 2, 2, 290, 292, 7, 51, 
	2, 2, 291, 290, 3, 2, 2, 2, 291, 292, 3, 2, 2, 2, 292, 293, 3, 2, 2, 2, 
	293, 307, 9, 2, 2, 2, 294, 308, 7, 57, 2, 2, 295, 297, 7, 66, 2, 2, 296, 
	298, 7, 106, 2, 2, 297, 296, 3, 2, 2, 2, 297, 298, 3, 2, 2, 2, 298, 308, 
	3, 2, 2, 2, 299, 301, 7, 90, 2, 2, 300, 302, 7, 106, 2, 2, 301, 300, 3, 
	2, 2, 2, 301, 302, 3, 2, 2, 2, 302, 308, 3, 2, 2, 2, 303, 305, 7, 50, 2, 
	2, 304, 306, 7, 106, 2, 2, 305, 304, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 
	306, 308, 3, 2, 2, 2, 307, 294, 3, 2, 2, 2, 307, 295, 3, 2, 2, 2, 307, 
	299, 3, 2, 2, 2, 307, 303, 3, 2, 2, 2, 308, 309, 3, 2, 2, 2, 309, 310, 
	7, 63, 2, 2, 310, 318, 5, 24, 13, 2, 311, 312, 7, 112, 2, 2, 312, 313, 
	7, 121, 2, 2, 313, 314, 5, 152, 77, 2, 314, 315, 7, 122, 2, 2, 315, 319, 
	3, 2, 2, 2, 316, 317, 7, 112, 2, 2, 317, 319, 5, 152, 77, 2, 318, 311, 
	3, 2, 2, 2, 318, 316, 3, 2, 2, 2, 319, 327, 3, 2, 2, 2, 320, 322, 7, 51, 
	2, 2, 321, 320, 3, 2, 2, 2, 321, 322, 3, 2, 2, 2, 322, 323, 3, 2, 2, 2, 
	323, 324, 7, 27, 2, 2, 324, 325, 7, 63, 2, 2, 325, 327, 5, 24, 13, 2, 326, 
	291, 3, 2, 2, 2, 326, 321, 3, 2, 2, 2, 327, 23, 3, 2, 2, 2, 328, 331, 5, 
	164, 83, 2, 329, 331, 5, 142, 72, 2, 330, 328, 3, 2, 2, 2, 330, 329, 3, 
	2, 2, 2, 331, 25, 3, 2, 2, 2, 332, 333, 7, 85, 2, 2, 333, 334, 5, 144, 
	73, 2, 334, 27, 3, 2, 2, 2, 335, 336, 7, 115, 2, 2, 336, 337, 5, 144, 73, 
	2, 337, 29, 3, 2, 2, 2, 338, 339, 7, 52, 2, 2, 339, 340, 7, 18, 2, 2, 340, 
	343, 5, 152, 77, 2, 341, 342, 7, 116, 2, 2, 342, 344, 7, 103, 2, 2, 343, 
	341, 3, 2, 2, 2, 343, 344, 3, 2, 2, 2, 344, 31, 3, 2, 2, 2, 345, 346, 7, 
	53, 2, 2, 346, 347, 5, 144, 73, 2, 347, 33, 3, 2, 2, 2, 348, 349, 7, 80, 
	2, 2, 349, 350, 7, 18, 2, 2, 350, 351, 5, 102, 52, 2, 351, 35, 3, 2, 2, 
	2, 352, 353, 7, 68, 2, 2, 353, 356, 7, 176, 2, 2, 354, 355, 7, 119, 2, 
	2, 355, 357, 7, 176, 2, 2, 356, 354, 3, 2, 2, 2, 356, 357, 3, 2, 2, 2, 
	357, 37, 3, 2, 2, 2, 358, 359, 7, 68, 2, 2, 359, 360, 7, 176, 2, 2, 360, 
	361, 7, 18, 2, 2, 361, 362, 5, 152, 77, 2, 362, 39, 3, 2, 2, 2, 363, 364, 
	7, 95, 2, 2, 364, 365, 5, 66, 34, 2, 365, 41, 3, 2, 2, 2, 366, 367, 7, 
	49, 2, 2, 367, 368, 5, 164, 83, 2, 368, 43, 3, 2, 2, 2, 369, 370, 7, 58, 
	2, 2, 370, 371, 7, 60, 2, 2, 371, 375, 5, 82, 42, 2, 372, 373, 7, 55, 2, 
	2, 373, 374, 7, 137, 2, 2, 374, 376, 7, 177, 2, 2, 375, 372, 3, 2, 2, 2, 
	375, 376, 3, 2, 2, 2, 376, 381, 3, 2, 2, 2, 377, 378, 7, 121, 2, 2, 378, 
	379, 5, 128, 65, 2, 379, 380, 7, 122, 2, 2, 380, 382, 3, 2, 2, 2, 381, 
	377, 3, 2, 2, 2, 381, 382, 3, 2, 2, 2, 382, 414, 3, 2, 2, 2, 383, 384, 
	7, 107, 2, 2, 384, 385, 7, 121, 2, 2, 385, 390, 5, 170, 86, 2, 386, 387, 
	7, 119, 2, 2, 387, 389, 5, 170, 86, 2, 388, 386, 3, 2, 2, 2, 389, 392, 
	3, 2, 2, 2, 390, 388, 3, 2, 2, 2, 390, 391, 3, 2, 2, 2, 391, 393, 3, 2, 
	2, 2, 392, 390, 3, 2, 2, 2, 393, 408, 7, 122, 2, 2, 394, 395, 7, 119, 2, 
	2, 395, 396, 7, 121, 2, 2, 396, 401, 5, 170, 86, 2, 397, 398, 7, 119, 2, 
	2, 398, 400, 5, 170, 86, 2, 399, 397, 3, 2, 2, 2, 400, 403, 3, 2, 2, 2, 
	401, 399, 3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402, 404, 3, 2, 2, 2, 403, 
	401, 3, 2, 2, 2, 404, 405, 7, 122, 2, 2, 405, 407, 3, 2, 2, 2, 406, 394, 
	3, 2, 2, 2, 407, 410, 3, 2, 2, 2, 408, 406, 3, 2, 2, 2, 408, 409, 3, 2, 
	2, 2, 409, 415, 3, 2, 2, 2, 410, 408, 3, 2, 2, 2, 411, 412, 7, 49, 2, 2, 
	412, 415, 5, 92, 47, 2, 413, 415, 5, 6, 4, 2, 414, 383, 3, 2, 2, 2, 414, 
	411, 3, 2, 2, 2, 414, 413, 3, 2, 2, 2, 415, 45, 3, 2, 2, 2, 416, 418, 9, 
	3, 2, 2, 417, 419, 7, 100, 2, 2, 418, 417, 3, 2, 2, 2, 418, 419, 3, 2, 
	2, 2, 419, 500, 3, 2, 2, 2, 420, 424, 7, 33, 2, 2, 421, 422, 7, 56, 2, 
	2, 422, 423, 7, 74, 2, 2, 423, 425, 7, 43, 2, 2, 424, 421, 3, 2, 2, 2, 
	424, 425, 3, 2, 2, 2, 425, 426, 3, 2, 2, 2, 426, 501, 5, 88, 45, 2, 427, 
	431, 7, 98, 2, 2, 428, 429, 7, 56, 2, 2, 429, 430, 7, 74, 2, 2, 430, 432, 
	7, 43, 2, 2, 431, 428, 3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432, 433, 3, 2, 
	2, 2, 433, 437, 5, 82, 42, 2, 434, 435, 7, 78, 2, 2, 435, 436, 7, 22, 2, 
	2, 436, 438, 5, 86, 44, 2, 437, 434, 3, 2, 2, 2, 437, 438, 3, 2, 2, 2, 
	438, 473, 3, 2, 2, 2, 439, 440, 7, 121, 2, 2, 440, 441, 5, 120, 61, 2, 
	441, 442, 7, 122, 2, 2, 442, 445, 5, 96, 49, 2, 443, 444, 7, 12, 2, 2, 
	444, 446, 5, 6, 4, 2, 445, 443, 3, 2, 2, 2, 445, 446, 3, 2, 2, 2, 446, 
	447, 3, 2, 2, 2, 447, 448, 5, 108, 55, 2, 448, 449, 7, 80, 2, 2, 449, 450, 
	7, 18, 2, 2, 450, 451, 7, 121, 2, 2, 451, 452, 5, 102, 52, 2, 452, 456, 
	7, 122, 2, 2, 453, 454, 7, 91, 2, 2, 454, 455, 7, 18, 2, 2, 455, 457, 5, 
	146, 74, 2, 456, 453, 3, 2, 2, 2, 456, 457, 3, 2, 2, 2, 457, 459, 3, 2, 
	2, 2, 458, 460, 5, 106, 54, 2, 459, 458, 3, 2, 2, 2, 459, 460, 3, 2, 2, 
	2, 460, 462, 3, 2, 2, 2, 461, 463, 5, 40, 21, 2, 462, 461, 3, 2, 2, 2, 
	462, 463, 3, 2, 2, 2, 463, 474, 3, 2, 2, 2, 464, 465, 5, 96, 49, 2, 465, 
	471, 7, 12, 2, 2, 466, 472, 5, 6, 4, 2, 467, 469, 5, 82, 42, 2, 468, 470, 
	5, 96, 49, 2, 469, 468, 3, 2, 2, 2, 469, 470, 3, 2, 2, 2, 470, 472, 3, 
	2, 2, 2, 471, 466, 3, 2, 2, 2, 471, 467, 3, 2, 2, 2, 472, 474, 3, 2, 2, 
	2, 473, 439, 3, 2, 2, 2, 473, 464, 3, 2, 2, 2, 474, 501, 3, 2, 2, 2, 475, 
	477, 7, 70, 2, 2, 476, 475, 3, 2, 2, 2, 476, 477, 3, 2, 2, 2, 477, 478, 
	3, 2, 2, 2, 478, 482, 7, 109, 2, 2, 479, 480, 7, 56, 2, 2, 480, 481, 7, 
	74, 2, 2, 481, 483, 7, 43, 2, 2, 482, 479, 3, 2, 2, 2, 482, 483, 3, 2, 
	2, 2, 483, 484, 3, 2, 2, 2, 484, 489, 5, 82, 42, 2, 485, 486, 7, 121, 2, 
	2, 486, 487, 5, 120, 61, 2, 487, 488, 7, 122, 2, 2, 488, 490, 3, 2, 2, 
	2, 489, 485, 3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490, 492, 3, 2, 2, 2, 491, 
	493, 5, 96, 49, 2, 492, 491, 3, 2, 2, 2, 492, 493, 3, 2, 2, 2, 493, 495, 
	3, 2, 2, 2, 494, 496, 7, 84, 2, 2, 495, 494, 3, 2, 2, 2, 495, 496, 3, 2, 
	2, 2, 496, 497, 3, 2, 2, 2, 497, 498, 7, 12, 2, 2, 498, 499, 5, 6, 4, 2, 
	499, 501, 3, 2, 2, 2, 500, 420, 3, 2, 2, 2, 500, 427, 3, 2, 2, 2, 500, 
	476, 3, 2, 2, 2, 501, 47, 3, 2, 2, 2, 502, 503, 7, 88, 2, 2, 503, 504, 
	7, 98, 2, 2, 504, 505, 5, 82, 42, 2, 505, 506, 7, 104, 2, 2, 506, 514, 
	5, 82, 42, 2, 507, 508, 7, 119, 2, 2, 508, 509, 5, 82, 42, 2, 509, 510, 
	7, 104, 2, 2, 510, 511, 5, 82, 42, 2, 511, 513, 3, 2, 2, 2, 512, 507, 3, 
	2, 2, 2, 513, 516, 3, 2, 2, 2, 514, 512, 3, 2, 2, 2, 514, 515, 3, 2, 2, 
	2, 515, 520, 3, 2, 2, 2, 516, 514, 3, 2, 2, 2, 517, 518, 7, 78, 2, 2, 518, 
	519, 7, 22, 2, 2, 519, 521, 5, 86, 44, 2, 520, 517, 3, 2, 2, 2, 520, 521, 
	3, 2, 2, 2, 521, 49, 3, 2, 2, 2, 522, 545, 9, 4, 2, 2, 523, 526, 7, 33, 
	2, 2, 524, 525, 7, 56, 2, 2, 525, 527, 7, 43, 2, 2, 526, 524, 3, 2, 2, 
	2, 526, 527, 3, 2, 2, 2, 527, 528, 3, 2, 2, 2, 528, 532, 5, 88, 45, 2, 
	529, 530, 7, 78, 2, 2, 530, 531, 7, 22, 2, 2, 531, 533, 5, 86, 44, 2, 532, 
	529, 3, 2, 2, 2, 532, 533, 3, 2, 2, 2, 533, 546, 3, 2, 2, 2, 534, 537, 
	7, 98, 2, 2, 535, 536, 7, 56, 2, 2, 536, 538, 7, 43, 2, 2, 537, 535, 3, 
	2, 2, 2, 537, 538, 3, 2, 2, 2, 538, 539, 3, 2, 2, 2, 539, 543, 5, 82, 42, 
	2, 540, 541, 7, 78, 2, 2, 541, 542, 7, 22, 2, 2, 542, 544, 5, 86, 44, 2, 
	543, 540, 3, 2, 2, 2, 543, 544, 3, 2, 2, 2, 544, 546, 3, 2, 2, 2, 545, 
	523, 3, 2, 2, 2, 545, 534, 3, 2, 2, 2, 546, 51, 3, 2, 2, 2, 547, 548, 7, 
	8, 2, 2, 548, 549, 7, 98, 2, 2, 549, 553, 5, 82, 42, 2, 550, 551, 7, 78, 
	2, 2, 551, 552, 7, 22, 2, 2, 552, 554, 5, 86, 44, 2, 553, 550, 3, 2, 2, 
	2, 553, 554, 3, 2, 2, 2, 554, 555, 3, 2, 2, 2, 555, 560, 5, 54, 28, 2, 
	556, 557, 7, 119, 2, 2, 557, 559, 5, 54, 28, 2, 558, 556, 3, 2, 2, 2, 559, 
	562, 3, 2, 2, 2, 560, 558, 3, 2, 2, 2, 560, 561, 3, 2, 2, 2, 561, 53, 3, 
	2, 2, 2, 562, 560, 3, 2, 2, 2, 563, 564, 7, 4, 2, 2, 564, 565, 7, 23, 2, 
	2, 565, 568, 5, 118, 60, 2, 566, 567, 7, 5, 2, 2, 567, 569, 5, 124, 63, 
	2, 568, 566, 3, 2, 2, 2, 568, 569, 3, 2, 2, 2, 569, 595, 3, 2, 2, 2, 570, 
	571, 7, 39, 2, 2, 571, 572, 7, 23, 2, 2, 572, 595, 5, 124, 63, 2, 573, 
	574, 7, 72, 2, 2, 574, 575, 7, 23, 2, 2, 575, 595, 5, 118, 60, 2, 576, 
	577, 7, 16, 2, 2, 577, 578, 7, 83, 2, 2, 578, 595, 5, 84, 43, 2, 579, 580, 
	7, 36, 2, 2, 580, 581, 7, 83, 2, 2, 581, 595, 5, 84, 43, 2, 582, 583, 7, 
	39, 2, 2, 583, 584, 7, 83, 2, 2, 584, 595, 5, 84, 43, 2, 585, 586, 7, 44, 
	2, 2, 586, 587, 7, 83, 2, 2, 587, 588, 5, 84, 43, 2, 588, 589, 7, 47, 2, 
	2, 589, 590, 7, 177, 2, 2, 590, 595, 3, 2, 2, 2, 591, 592, 7, 48, 2, 2, 
	592, 593, 7, 83, 2, 2, 593, 595, 5, 84, 43, 2, 594, 563, 3, 2, 2, 2, 594, 
	570, 3, 2, 2, 2, 594, 573, 3, 2, 2, 2, 594, 576, 3, 2, 2, 2, 594, 579, 
	3, 2, 2, 2, 594, 582, 3, 2, 2, 2, 594, 585, 3, 2, 2, 2, 594, 591, 3, 2, 
	2, 2, 595, 55, 3, 2, 2, 2, 596, 632, 5, 58, 30, 2, 597, 598, 7, 174, 2, 
	2, 598, 599, 7, 121, 2, 2, 599, 604, 5, 162, 82, 2, 600, 601, 7, 119, 2, 
	2, 601, 603, 5, 56, 29, 2, 602, 600, 3, 2, 2, 2, 603, 606, 3, 2, 2, 2, 
	604, 602, 3, 2, 2, 2, 604, 605, 3, 2, 2, 2, 605, 607, 3, 2, 2, 2, 606, 
	604, 3, 2, 2, 2, 607, 608, 7, 122, 2, 2, 608, 632, 3, 2, 2, 2, 609, 610, 
	7, 146, 2, 2, 610, 611, 7, 121, 2, 2, 611, 612, 5, 56, 29, 2, 612, 613, 
	7, 122, 2, 2, 613, 632, 3, 2, 2, 2, 614, 615, 7, 147, 2, 2, 615, 616, 7, 
	121, 2, 2, 616, 621, 5, 56, 29, 2, 617, 618, 7, 119, 2, 2, 618, 620, 5, 
	56, 29, 2, 619, 617, 3, 2, 2, 2, 620, 623, 3, 2, 2, 2, 621, 619, 3, 2, 
	2, 2, 621, 622, 3, 2, 2, 2, 622, 624, 3, 2, 2, 2, 623, 621, 3, 2, 2, 2, 
	624, 625, 7, 122, 2, 2, 625, 632, 3, 2, 2, 2, 626, 627, 7, 148, 2, 2, 627, 
	628, 7, 121, 2, 2, 628, 629, 5, 56, 29, 2, 629, 630, 7, 122, 2, 2, 630, 
	632, 3, 2, 2, 2, 631, 596, 3, 2, 2, 2, 631, 597, 3, 2, 2, 2, 631, 609, 
	3, 2, 2, 2, 631, 614, 3, 2, 2, 2, 631, 626, 3, 2, 2, 2, 632, 57, 3, 2, 
	2, 2, 633, 684, 7, 151, 2, 2, 634, 684, 7, 152, 2, 2, 635, 684, 7, 153, 
	2, 2, 636, 684, 7, 154, 2, 2, 637, 684, 7, 155, 2, 2, 638, 684, 7, 156, 
	2, 2, 639, 684, 7, 157, 2, 2, 640, 684, 7, 158, 2, 2, 641, 684, 7, 149, 
	2, 2, 642, 684, 7, 150, 2, 2, 643, 644, 7, 159, 2, 2, 644, 645, 7, 121, 
	2, 2, 645, 650, 5, 60, 31, 2, 646, 647, 7, 119, 2, 2, 647, 649, 5, 60, 
	31, 2, 648, 646, 3, 2, 2, 2, 649, 652, 3, 2, 2, 2, 650, 648, 3, 2, 2, 2, 
	650, 651, 3, 2, 2, 2, 651, 653, 3, 2, 2, 2, 652, 650, 3, 2, 2, 2, 653, 
	654, 7, 122, 2, 2, 654, 684, 3, 2, 2, 2, 655, 656, 7, 160, 2, 2, 656, 657, 
	7, 121, 2, 2, 657, 662, 5, 60, 31, 2, 658, 659, 7, 119, 2, 2, 659, 661, 
	5, 60, 31, 2, 660, 658, 3, 2, 2, 2, 661, 664, 3, 2, 2, 2, 662, 660, 3, 
	2, 2, 2, 662, 663, 3, 2, 2, 2, 663, 665, 3, 2, 2, 2, 664, 662, 3, 2, 2, 
	2, 665, 666, 7, 122, 2, 2, 666, 684, 3, 2, 2, 2, 667, 684, 7, 161, 2, 2, 
	668, 684, 7, 162, 2, 2, 669, 684, 7, 163, 2, 2, 670, 684, 7, 164, 2, 2, 
	671, 684, 7, 167, 2, 2, 672, 684, 7, 168, 2, 2, 673, 684, 7, 169, 2, 2, 
	674, 684, 7, 170, 2, 2, 675, 684, 7, 171, 2, 2, 676, 684, 7, 172, 2, 2, 
	677, 684, 7, 173, 2, 2, 678, 684, 7, 166, 2, 2, 679, 680, 7, 165, 2, 2, 
	680, 681, 7, 121, 2, 2, 681, 682, 7, 176, 2, 2, 682, 684, 7, 121, 2, 2, 
	683, 633, 3, 2, 2, 2, 683, 634, 3, 2, 2, 2, 683, 635, 3, 2, 2, 2, 683, 
	636, 3, 2, 2, 2, 683, 637, 3, 2, 2, 2, 683, 638, 3, 2, 2, 2, 683, 639, 
	3, 2, 2, 2, 683, 640, 3, 2, 2, 2, 683, 641, 3, 2, 2, 2, 683, 642, 3, 2, 
	2, 2, 683, 643, 3, 2, 2, 2, 683, 655, 3, 2, 2, 2, 683, 667, 3, 2, 2, 2, 
	683, 668, 3, 2, 2, 2, 683, 669, 3, 2, 2, 2, 683, 670, 3, 2, 2, 2, 683, 
	671, 3, 2, 2, 2, 683, 672, 3, 2, 2, 2, 683, 673, 3, 2, 2, 2, 683, 674, 
	3, 2, 2, 2, 683, 675, 3, 2, 2, 2, 683, 676, 3, 2, 2, 2, 683, 677, 3, 2, 
	2, 2, 683, 678, 3, 2, 2, 2, 683, 679, 3, 2, 2, 2, 684, 59, 3, 2, 2, 2, 
	685, 686, 7, 177, 2, 2, 686, 687, 7, 137, 2, 2, 687, 688, 7, 176, 2, 2, 
	688, 61, 3, 2, 2, 2, 689, 690, 7, 111, 2, 2, 690, 691, 5, 88, 45, 2, 691, 
	63, 3, 2, 2, 2, 692, 694, 7, 94, 2, 2, 693, 695, 7, 51, 2, 2, 694, 693, 
	3, 2, 2, 2, 694, 695, 3, 2, 2, 2, 695, 696, 3, 2, 2, 2, 696, 697, 5, 66, 
	34, 2, 697, 65, 3, 2, 2, 2, 698, 703, 5, 68, 35, 2, 699, 700, 7, 119, 2, 
	2, 700, 702, 5, 68, 35, 2, 701, 699, 3, 2, 2, 2, 702, 705, 3, 2, 2, 2, 
	703, 701, 3, 2, 2, 2, 703, 704, 3, 2, 2, 2, 704, 67, 3, 2, 2, 2, 705, 703, 
	3, 2, 2, 2, 706, 707, 5, 164, 83, 2, 707, 708, 7, 137, 2, 2, 708, 709, 
	5, 170, 86, 2, 709, 69, 3, 2, 2, 2, 710, 711, 7, 64, 2, 2, 711, 712, 7, 
	87, 2, 2, 712, 713, 7, 115, 2, 2, 713, 714, 5, 144, 73, 2, 714, 715, 9, 
	5, 2, 2, 715, 71, 3, 2, 2, 2, 716, 717, 7, 79, 2, 2, 717, 718, 7, 98, 2, 
	2, 718, 721, 5, 82, 42, 2, 719, 720, 7, 83, 2, 2, 720, 722, 7, 177, 2, 
	2, 721, 719, 3, 2, 2, 2, 721, 722, 3, 2, 2, 2, 722, 724, 3, 2, 2, 2, 723, 
	725, 7, 45, 2, 2, 724, 723, 3, 2, 2, 2, 724, 725, 3, 2, 2, 2, 725, 73, 
	3, 2, 2, 2, 726, 731, 7, 43, 2, 2, 727, 731, 9, 6, 2, 2, 728, 729, 7, 96, 
	2, 2, 729, 731, 7, 26, 2, 2, 730, 726, 3, 2, 2, 2, 730, 727, 3, 2, 2, 2, 
	730, 728, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 733, 7, 98, 2, 2, 733, 
	735, 5, 82, 42, 2, 734, 736, 5, 94, 48, 2, 735, 734, 3, 2, 2, 2, 735, 736, 
	3, 2, 2, 2, 736, 739, 3, 2, 2, 2, 737, 738, 7, 49, 2, 2, 738, 740, 5, 92, 
	47, 2, 739, 737, 3, 2, 2, 2, 739, 740, 3, 2, 2, 2, 740, 75, 3, 2, 2, 2, 
	741, 755, 7, 96, 2, 2, 742, 756, 7, 34, 2, 2, 743, 746, 7, 99, 2, 2, 744, 
	745, 7, 47, 2, 2, 745, 747, 5, 88, 45, 2, 746, 744, 3, 2, 2, 2, 746, 747, 
	3, 2, 2, 2, 747, 753, 3, 2, 2, 2, 748, 750, 7, 74, 2, 2, 749, 748, 3, 2, 
	2, 2, 749, 750, 3, 2, 2, 2, 750, 751, 3, 2, 2, 2, 751, 752, 7, 67, 2, 2, 
	752, 754, 7, 177, 2, 2, 753, 749, 3, 2, 2, 2, 753, 754, 3, 2, 2, 2, 754, 
	756, 3, 2, 2, 2, 755, 742, 3, 2, 2, 2, 755, 743, 3, 2, 2, 2, 756, 758, 
	3, 2, 2, 2, 757, 759, 5, 94, 48, 2, 758, 757, 3, 2, 2, 2, 758, 759, 3, 
	2, 2, 2, 759, 762, 3, 2, 2, 2, 760, 761, 7, 49, 2, 2, 761, 763, 5, 92, 
	47, 2, 762, 760, 3, 2, 2, 2, 762, 763, 3, 2, 2, 2, 763, 77, 3, 2, 2, 2, 
	764, 765, 7, 96, 2, 2, 765, 767, 7, 86, 2, 2, 766, 768, 5, 94, 48, 2, 767, 
	766, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 771, 3, 2, 2, 2, 769, 770, 
	7, 49, 2, 2, 770, 772, 5, 92, 47, 2, 771, 769, 3, 2, 2, 2, 771, 772, 3, 
	2, 2, 2, 772, 79, 3, 2, 2, 2, 773, 774, 7, 21, 2, 2, 774, 775, 7, 98, 2, 
	2, 775, 776, 5, 82, 42, 2, 776, 81, 3, 2, 2, 2, 777, 778, 5, 88, 45, 2, 
	778, 779, 7, 132, 2, 2, 779, 781, 3, 2, 2, 2, 780, 777, 3, 2, 2, 2, 780, 
	781, 3, 2, 2, 2, 781, 782, 3, 2, 2, 2, 782, 783, 5, 90, 46, 2, 783, 83, 
	3, 2, 2, 2, 784, 787, 5, 164, 83, 2, 785, 787, 7, 177, 2, 2, 786, 784, 
	3, 2, 2, 2, 786, 785, 3, 2, 2, 2, 787, 85, 3, 2, 2, 2, 788, 791, 5, 164, 
	83, 2, 789, 791, 7, 177, 2, 2, 790, 788, 3, 2, 2, 2, 790, 789, 3, 2, 2, 
	2, 791, 87, 3, 2, 2, 2, 792, 793, 5, 164, 83, 2, 793, 89, 3, 2, 2, 2, 794, 
	795, 5, 164, 83, 2, 795, 91, 3, 2, 2, 2, 796, 797, 5, 164, 83, 2, 797, 
	93, 3, 2, 2, 2, 798, 799, 7, 60, 2, 2, 799, 800, 7, 82, 2, 2, 800, 801, 
	7, 177, 2, 2, 801, 95, 3, 2, 2, 2, 802, 803, 7, 42, 2, 2, 803, 804, 7, 
	137, 2, 2, 804, 805, 5, 98, 50, 2, 805, 97, 3, 2, 2, 2, 806, 809, 5, 100, 
	51, 2, 807, 809, 5, 164, 83, 2, 808, 806, 3, 2, 2, 2, 808, 807, 3, 2, 2, 
	2, 809, 99, 3, 2, 2, 2, 810, 813, 5, 156, 79, 2, 811, 813, 5, 112, 57, 
	2, 812, 810, 3, 2, 2, 2, 812, 811, 3, 2, 2, 2, 813, 101, 3, 2, 2, 2, 814, 
	819, 5, 104, 53, 2, 815, 816, 7, 119, 2, 2, 816, 818, 5, 104, 53, 2, 817, 
	815, 3, 2, 2, 2, 818, 821, 3, 2, 2, 2, 819, 817, 3, 2, 2, 2, 819, 820, 
	3, 2, 2, 2, 820, 103, 3, 2, 2, 2, 821, 819, 3, 2, 2, 2, 822, 824, 5, 144, 
	73, 2, 823, 825, 9, 7, 2, 2, 824, 823, 3, 2, 2, 2, 824, 825, 3, 2, 2, 2, 
	825, 828, 3, 2, 2, 2, 826, 827, 7, 76, 2, 2, 827, 829, 9, 8, 2, 2, 828, 
	826, 3, 2, 2, 2, 828, 829, 3, 2, 2, 2, 829, 832, 3, 2, 2, 2, 830, 831, 
	7, 24, 2, 2, 831, 833, 7, 177, 2, 2, 832, 830, 3, 2, 2, 2, 832, 833, 3, 
	2, 2, 2, 833, 105, 3, 2, 2, 2, 834, 835, 7, 105, 2, 2, 835, 840, 5, 110, 
	56, 2, 836, 837, 7, 119, 2, 2, 837, 839, 5, 110, 56, 2, 838, 836, 3, 2, 
	2, 2, 839, 842, 3, 2, 2, 2, 840, 838, 3, 2, 2, 2, 840, 841, 3, 2, 2, 2, 
	841, 107, 3, 2, 2, 2, 842, 840, 3, 2, 2, 2, 843, 844, 7, 83, 2, 2, 844, 
	845, 7, 18, 2, 2, 845, 847, 5, 146, 74, 2, 846, 843, 3, 2, 2, 2, 846, 847, 
	3, 2, 2, 2, 847, 109, 3, 2, 2, 2, 848, 856, 5, 146, 74, 2, 849, 857, 7, 
	29, 2, 2, 850, 851, 7, 104, 2, 2, 851, 852, 7, 37, 2, 2, 852, 857, 7, 177, 
	2, 2, 853, 854, 7, 104, 2, 2, 854, 855, 7, 108, 2, 2, 855, 857, 7, 177, 
	2, 2, 856, 849, 3, 2, 2, 2, 856, 850, 3, 2, 2, 2, 856, 853, 3, 2, 2, 2, 
	856, 857, 3, 2, 2, 2, 857, 111, 3, 2, 2, 2, 858, 859, 5, 164, 83, 2, 859, 
	860, 7, 121, 2, 2, 860, 861, 5, 114, 58, 2, 861, 862, 7, 122, 2, 2, 862, 
	113, 3, 2, 2, 2, 863, 868, 5, 116, 59, 2, 864, 865, 7, 119, 2, 2, 865, 
	867, 5, 116, 59, 2, 866, 864, 3, 2, 2, 2, 867, 870, 3, 2, 2, 2, 868, 866, 
	3, 2, 2, 2, 868, 869, 3, 2, 2, 2, 869, 115, 3, 2, 2, 2, 870, 868, 3, 2, 
	2, 2, 871, 872, 5, 164, 83, 2, 872, 873, 5, 126, 64, 2, 873, 117, 3, 2, 
	2, 2, 874, 875, 5, 168, 85, 2, 875, 876, 5, 126, 64, 2, 876, 119, 3, 2, 
	2, 2, 877, 882, 5, 122, 62, 2, 878, 879, 7, 119, 2, 2, 879, 881, 5, 122, 
	62, 2, 880, 878, 3, 2, 2, 2, 881, 884, 3, 2, 2, 2, 882, 880, 3, 2, 2, 2, 
	882, 883, 3, 2, 2, 2, 883, 121, 3, 2, 2, 2, 884, 882, 3, 2, 2, 2, 885, 
	886, 5, 124, 63, 2, 886, 889, 5, 126, 64, 2, 887, 888, 9, 9, 2, 2, 888, 
	890, 5, 146, 74, 2, 889, 887, 3, 2, 2, 2, 889, 890, 3, 2, 2, 2, 890, 893, 
	3, 2, 2, 2, 891, 892, 7, 25, 2, 2, 892, 894, 5, 146, 74, 2, 893, 891, 3, 
	2, 2, 2, 893, 894, 3, 2, 2, 2, 894, 897, 3, 2, 2, 2, 895, 896, 7, 105, 
	2, 2, 896, 898, 5, 146, 74, 2, 897, 895, 3, 2, 2, 2, 897, 898, 3, 2, 2, 
	2, 898, 123, 3, 2, 2, 2, 899, 900, 5, 164, 83, 2, 900, 125, 3, 2, 2, 2, 
	901, 902, 5, 56, 29, 2, 902, 127, 3, 2, 2, 2, 903, 908, 5, 124, 63, 2, 
	904, 905, 7, 119, 2, 2, 905, 907, 5, 124, 63, 2, 906, 904, 3, 2, 2, 2, 
	907, 910, 3, 2, 2, 2, 908, 906, 3, 2, 2, 2, 908, 909, 3, 2, 2, 2, 909, 
	129, 3, 2, 2, 2, 910, 908, 3, 2, 2, 2, 911, 916, 5, 132, 67, 2, 912, 913, 
	7, 119, 2, 2, 913, 915, 5, 132, 67, 2, 914, 912, 3, 2, 2, 2, 915, 918, 
	3, 2, 2, 2, 916, 914, 3, 2, 2, 2, 916, 917, 3, 2, 2, 2, 917, 131, 3, 2, 
	2, 2, 918, 916, 3, 2, 2, 2, 919, 921, 5, 146, 74, 2, 920, 922, 5, 134, 
	68, 2, 921, 920, 3, 2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 133, 3, 2, 2, 2, 
	923, 925, 7, 12, 2, 2, 924, 923, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925, 
	926, 3, 2, 2, 2, 926, 927, 5, 138, 70, 2, 927, 135, 3, 2, 2, 2, 928, 929, 
	7, 12, 2, 2, 929, 930, 5, 138, 70, 2, 930, 137, 3, 2, 2, 2, 931, 932, 5, 
	164, 83, 2, 932, 139, 3, 2, 2, 2, 933, 934, 5, 156, 79, 2, 934, 141, 3, 
	2, 2, 2, 935, 936, 7, 121, 2, 2, 936, 937, 5, 8, 5, 2, 937, 938, 7, 122, 
	2, 2, 938, 143, 3, 2, 2, 2, 939, 941, 5, 146, 74, 2, 940, 942, 5, 136, 
	69, 2, 941, 940, 3, 2, 2, 2, 941, 942, 3, 2, 2, 2, 942, 145, 3, 2, 2, 2, 
	943, 944, 8, 74, 1, 2, 944, 945, 7, 121, 2, 2, 945, 946, 5, 146, 74, 2, 
	946, 947, 7, 122, 2, 2, 947, 1021, 3, 2, 2, 2, 948, 1021, 5, 156, 79, 2, 
	949, 951, 7, 19, 2, 2, 950, 952, 5, 146, 74, 2, 951, 950, 3, 2, 2, 2, 951, 
	952, 3, 2, 2, 2, 952, 953, 3, 2, 2, 2, 953, 954, 7, 114, 2, 2, 954, 955, 
	5, 146, 74, 2, 955, 956, 7, 102, 2, 2, 956, 957, 5, 146, 74, 2, 957, 965, 
	3, 2, 2, 2, 958, 959, 7, 114, 2, 2, 959, 960, 5, 146, 74, 2, 960, 961, 
	7, 102, 2, 2, 961, 962, 5, 146, 74, 2, 962, 964, 3, 2, 2, 2, 963, 958, 
	3, 2, 2, 2, 964, 967, 3, 2, 2, 2, 965, 963, 3, 2, 2, 2, 965, 966, 3, 2, 
	2, 2, 966, 968, 3, 2, 2, 2, 967, 965, 3, 2, 2, 2, 968, 969, 7, 40, 2, 2, 
	969, 970, 5, 146, 74, 2, 970, 971, 7, 41, 2, 2, 971, 1021, 3, 2, 2, 2, 
	972, 973, 7, 134, 2, 2, 973, 1021, 5, 146, 74, 24, 974, 975, 7, 20, 2, 
	2, 975, 976, 7, 121, 2, 2, 976, 977, 5, 146, 74, 2, 977, 978, 7, 12, 2, 
	2, 978, 979, 5, 56, 29, 2, 979, 980, 7, 122, 2, 2, 980, 1021, 3, 2, 2, 
	2, 981, 982, 7, 59, 2, 2, 982, 983, 5, 146, 74, 2, 983, 984, 5, 148, 75, 
	2, 984, 1021, 3, 2, 2, 2, 985, 986, 7, 74, 2, 2, 986, 1021, 5, 146, 74, 
	14, 987, 988, 7, 121, 2, 2, 988, 993, 5, 164, 83, 2, 989, 990, 7, 119, 
	2, 2, 990, 992, 5, 164, 83, 2, 991, 989, 3, 2, 2, 2, 992, 995, 3, 2, 2, 
	2, 993, 991, 3, 2, 2, 2, 993, 994, 3, 2, 2, 2, 994, 996, 3, 2, 2, 2, 995, 
	993, 3, 2, 2, 2, 996, 997, 7, 122, 2, 2, 997, 1007, 3, 2, 2, 2, 998, 1003, 
	5, 164, 83, 2, 999, 1000, 7, 119, 2, 2, 1000, 1002, 5, 164, 83, 2, 1001, 
	999, 3, 2, 2, 2, 1002, 1005, 3, 2, 2, 2, 1003, 1001, 3, 2, 2, 2, 1003, 
	1004, 3, 2, 2, 2, 1004, 1007, 3, 2, 2, 2, 1005, 1003, 3, 2, 2, 2, 1006, 
	987, 3, 2, 2, 2, 1006, 998, 3, 2, 2, 2, 1007, 1008, 3, 2, 2, 2, 1008, 1009, 
	7, 123, 2, 2, 1009, 1010, 5, 146, 74, 10, 1010, 1021, 3, 2, 2, 2, 1011, 
	1021, 5, 142, 72, 2, 1012, 1013, 7, 121, 2, 2, 1013, 1014, 5, 152, 77, 
	2, 1014, 1015, 7, 122, 2, 2, 1015, 1021, 3, 2, 2, 2, 1016, 1021, 5, 154, 
	78, 2, 1017, 1021, 5, 170, 86, 2, 1018, 1021, 5, 168, 85, 2, 1019, 1021, 
	7, 127, 2, 2, 1020, 943, 3, 2, 2, 2, 1020, 948, 3, 2, 2, 2, 1020, 949, 
	3, 2, 2, 2, 1020, 972, 3, 2, 2, 2, 1020, 974, 3, 2, 2, 2, 1020, 981, 3, 
	2, 2, 2, 1020, 985, 3, 2, 2, 2, 1020, 1006, 3, 2, 2, 2, 1020, 1011, 3, 
	2, 2, 2, 1020, 1012, 3, 2, 2, 2, 1020, 1016, 3, 2, 2, 2, 1020, 1017, 3, 
	2, 2, 2, 1020, 1018, 3, 2, 2, 2, 1020, 1019, 3, 2, 2, 2, 1021, 1096, 3, 
	2, 2, 2, 1022, 1023, 12, 26, 2, 2, 1023, 1024, 7, 132, 2, 2, 1024, 1095, 
	5, 146, 74, 27, 1025, 1026, 12, 22, 2, 2, 1026, 1027, 9, 10, 2, 2, 1027, 
	1095, 5, 146, 74, 23, 1028, 1029, 12, 21, 2, 2, 1029, 1030, 9, 11, 2, 2, 
	1030, 1095, 5, 146, 74, 22, 1031, 1032, 12, 20, 2, 2, 1032, 1033, 7, 129, 
	2, 2, 1033, 1095, 5, 146, 74, 21, 1034, 1035, 12, 19, 2, 2, 1035, 1036, 
	7, 17, 2, 2, 1036, 1037, 5, 146, 74, 2, 1037, 1038, 7, 9, 2, 2, 1038, 1039, 
	5, 146, 74, 20, 1039, 1095, 3, 2, 2, 2, 1040, 1052, 12, 18, 2, 2, 1041, 
	1053, 7, 136, 2, 2, 1042, 1053, 7, 137, 2, 2, 1043, 1053, 7, 138, 2, 2, 
	1044, 1053, 7, 139, 2, 2, 1045, 1053, 7, 140, 2, 2, 1046, 1053, 7, 141, 
	2, 2, 1047, 1053, 7, 124, 2, 2, 1048, 1053, 7, 125, 2, 2, 1049, 1053, 7, 
	67, 2, 2, 1050, 1051, 7, 74, 2, 2, 1051, 1053, 7, 67, 2, 2, 1052, 1041, 
	3, 2, 2, 2, 1052, 1042, 3, 2, 2, 2, 1052, 1043, 3, 2, 2, 2, 1052, 1044, 
	3, 2, 2, 2, 1052, 1045, 3, 2, 2, 2, 1052, 1046, 3, 2, 2, 2, 1052, 1047, 
	3, 2, 2, 2, 1052, 1048, 3, 2, 2, 2, 1052, 1049, 3, 2, 2, 2, 1052, 1050, 
	3, 2, 2, 2, 1053, 1054, 3, 2, 2, 2, 1054, 1095, 5, 146, 74, 19, 1055, 1064, 
	12, 17, 2, 2, 1056, 1065, 7, 61, 2, 2, 1057, 1058, 7, 74, 2, 2, 1058, 1065, 
	7, 61, 2, 2, 1059, 1060, 7, 51, 2, 2, 1060, 1065, 7, 61, 2, 2, 1061, 1062, 
	7, 51, 2, 2, 1062, 1063, 7, 74, 2, 2, 1063, 1065, 7, 61, 2, 2, 1064, 1056, 
	3, 2, 2, 2, 1064, 1057, 3, 2, 2, 2, 1064, 1059, 3, 2, 2, 2, 1064, 1061, 
	3, 2, 2, 2, 1065, 1066, 3, 2, 2, 2, 1066, 1095, 5, 146, 74, 18, 1067, 1068, 
	12, 13, 2, 2, 1068, 1069, 7, 9, 2, 2, 1069, 1095, 5, 146, 74, 14, 1070, 
	1071, 12, 12, 2, 2, 1071, 1072, 7, 81, 2, 2, 1072, 1095, 5, 146, 74, 13, 
	1073, 1074, 12, 11, 2, 2, 1074, 1075, 7, 126, 2, 2, 1075, 1076, 5, 146, 
	74, 2, 1076, 1077, 7, 118, 2, 2, 1077, 1078, 5, 146, 74, 12, 1078, 1095, 
	3, 2, 2, 2, 1079, 1080, 12, 25, 2, 2, 1080, 1081, 7, 142, 2, 2, 1081, 1082, 
	5, 146, 74, 2, 1082, 1083, 7, 143, 2, 2, 1083, 1095, 3, 2, 2, 2, 1084, 
	1090, 12, 16, 2, 2, 1085, 1086, 7, 62, 2, 2, 1086, 1091, 7, 75, 2, 2, 1087, 
	1088, 7, 62, 2, 2, 1088, 1089, 7, 74, 2, 2, 1089, 1091, 7, 75, 2, 2, 1090, 
	1085, 3, 2, 2, 2, 1090, 1087, 3, 2, 2, 2, 1091, 1095, 3, 2, 2, 2, 1092, 
	1093, 12, 3, 2, 2, 1093, 1095, 5, 136, 69, 2, 1094, 1022, 3, 2, 2, 2, 1094, 
	1025, 3, 2, 2, 2, 1094, 1028, 3, 2, 2, 2, 1094, 1031, 3, 2, 2, 2, 1094, 
	1034, 3, 2, 2, 2, 1094, 1040, 3, 2, 2, 2, 1094, 1055, 3, 2, 2, 2, 1094, 
	1067, 3, 2, 2, 2, 1094, 1070, 3, 2, 2, 2, 1094, 1073, 3, 2, 2, 2, 1094, 
	1079, 3, 2, 2, 2, 1094, 1084, 3, 2, 2, 2, 1094, 1092, 3, 2, 2, 2, 1095, 
	1098, 3, 2, 2, 2, 1096, 1094, 3, 2, 2, 2, 1096, 1097, 3, 2, 2, 2, 1097, 
	147, 3, 2, 2, 2, 1098, 1096, 3, 2, 2, 2, 1099, 1100, 9, 12, 2, 2, 1100, 
	149, 3, 2, 2, 2, 1101, 1103, 5, 152, 77, 2, 1102, 1101, 3, 2, 2, 2, 1102, 
	1103, 3, 2, 2, 2, 1103, 151, 3, 2, 2, 2, 1104, 1109, 5, 146, 74, 2, 1105, 
	1106, 7, 119, 2, 2, 1106, 1108, 5, 146, 74, 2, 1107, 1105, 3, 2, 2, 2, 
	1108, 1111, 3, 2, 2, 2, 1109, 1107, 3, 2, 2, 2, 1109, 1110, 3, 2, 2, 2, 
	1110, 153, 3, 2, 2, 2, 1111, 1109, 3, 2, 2, 2, 1112, 1113, 7, 142, 2, 2, 
	1113, 1114, 5, 150, 76, 2, 1114, 1115, 7, 143, 2, 2, 1115, 155, 3, 2, 2, 
	2, 1116, 1118, 5, 162, 82, 2, 1117, 1119, 5, 158, 80, 2, 1118, 1117, 3, 
	2, 2, 2, 1118, 1119, 3, 2, 2, 2, 1119, 1120, 3, 2, 2, 2, 1120, 1121, 5, 
	160, 81, 2, 1121, 157, 3, 2, 2, 2, 1122, 1131, 7, 121, 2, 2, 1123, 1128, 
	5, 146, 74, 2, 1124, 1125, 7, 119, 2, 2, 1125, 1127, 5, 146, 74, 2, 1126, 
	1124, 3, 2, 2, 2, 1127, 1130, 3, 2, 2, 2, 1128, 1126, 3, 2, 2, 2, 1128, 
	1129, 3, 2, 2, 2, 1129, 1132, 3, 2, 2, 2, 1130, 1128, 3, 2, 2, 2, 1131, 
	1123, 3, 2, 2, 2, 1131, 1132, 3, 2, 2, 2, 1132, 1133, 3, 2, 2, 2, 1133, 
	1134, 7, 122, 2, 2, 1134, 159, 3, 2, 2, 2, 1135, 1144, 7, 121, 2, 2, 1136, 
	1141, 5, 146, 74, 2, 1137, 1138, 7, 119, 2, 2, 1138, 1140, 5, 146, 74, 
	2, 1139, 1137, 3, 2, 2, 2, 1140, 1143, 3, 2, 2, 2, 1141, 1139, 3, 2, 2, 
	2, 1141, 1142, 3, 2, 2, 2, 1142, 1145, 3, 2, 2, 2, 1143, 1141, 3, 2, 2, 
	2, 1144, 1136, 3, 2, 2, 2, 1144, 1145, 3, 2, 2, 2, 1145, 1146, 3, 2, 2, 
	2, 1146, 1147, 7, 122, 2, 2, 1147, 161, 3, 2, 2, 2, 1148, 1149, 5, 164, 
	83, 2, 1149, 163, 3, 2, 2, 2, 1150, 1155, 7, 178, 2, 2, 1151, 1155, 7, 
	175, 2, 2, 1152, 1155, 5, 58, 30, 2, 1153, 1155, 5, 166, 84, 2, 1154, 1150, 
	3, 2, 2, 2, 1154, 1151, 3, 2, 2, 2, 1154, 1152, 3, 2, 2, 2, 1154, 1153, 
	3, 2, 2, 2, 1155, 165, 3, 2, 2, 2, 1156, 1157, 9, 13, 2, 2, 1157, 167, 
	3, 2, 2, 2, 1158, 1159, 5, 164, 83, 2, 1159, 1160, 7, 132, 2, 2, 1160, 
	1161, 5, 164, 83, 2, 1161, 1164, 3, 2, 2, 2, 1162, 1164, 5, 164, 83, 2, 
	1163, 1158, 3, 2, 2, 2, 1163, 1162, 3, 2, 2, 2, 1164, 169, 3, 2, 2, 2, 
	1165, 1166, 9, 14, 2, 2, 1166, 171, 3, 2, 2, 2, 1167, 1168, 7, 180, 2, 
	2, 1168, 1169, 8, 87, 1, 2, 1169, 173, 3, 2, 2, 2, 135, 176, 194, 202, 
	206, 209, 212, 216, 219, 222, 225, 228, 231, 234, 237, 240, 243, 246, 249, 
	252, 259, 267, 270, 273, 283, 288, 291, 297, 301, 305, 307, 318, 321, 326, 
	330, 343, 356, 375, 381, 390, 401, 408, 414, 418, 424, 431, 437, 445, 456, 
	459, 462, 469, 471, 473, 476, 482, 489, 492, 495, 500, 514, 520, 526, 532, 
	537, 543, 545, 553, 560, 568, 594, 604, 621, 631, 650, 662, 683, 694, 703, 
	721, 724, 730, 735, 739, 746, 749, 753, 755, 758, 762, 767, 771, 780, 786, 
	790, 808, 812, 819, 824, 828, 832, 840, 846, 856, 868, 882, 889, 893, 897, 
	908, 916, 921, 924, 941, 951, 965, 993, 1003, 1006, 1020, 1052, 1064, 1090, 
	1094, 1096, 1102, 1109, 1118, 1128, 1131, 1141, 1144, 1154, 1163,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "':'", "','", "';'", "'('", "')'", "'->'", 
	"'<'", "'>'", "'?'", "'*'", "'+'", "'||'", "'|'", "'$'", "'.'", "'%'", 
	"'-'", "'/'", "'=='", "'='", "'!='", "'<>'", "'<='", "'>='", "'['", "']'", 
	"'{'", "'}'", "'Array'", "'Tuple'", "'Nullable'", "'Float32'", "'Float64'", 
	"'UInt8'", "'UInt16'", "'UInt32'", "'UInt64'", "'Int8'", "'Int16'", "'Int32'", 
	"'Int64'", "'Enum8'", "'Enum16'", "'UUID'", "'Date'", "'DateTime'", "'String'", 
	"'FixedString'", "'Null'", "'IntervalYear'", "'IntervalMonth'", "'IntervalWeek'", 
	"'IntervalDay'", "'IntervalHour'", "'IntervalMinute'", "'IntervalSecond'", 
	"'AggregateFunction'",
}
var symbolicNames = []string{
	"", "LINE_COMMENT", "K_ADD", "K_AFTER", "K_ALL", "K_ALIAS", "K_ALTER", 
	"K_AND", "K_ANY", "K_ARRAY", "K_AS", "K_ASCENDING", "K_ASC", "K_ASYNC", 
	"K_ATTACH", "K_BETWEEN", "K_BY", "K_CASE", "K_CAST", "K_CHECK", "K_CLUSTER", 
	"K_COLUMN", "K_COLLATE", "K_CODEC", "K_CREATE", "K_CROSS", "K_DAY", "K_DELETE", 
	"K_DESCRIBE", "K_DESCENDING", "K_DESC", "K_DATABASE", "K_DATABASES", "K_DEFAULT", 
	"K_DETACH", "K_DISK", "K_DISTINCT", "K_DROP", "K_ELSE", "K_END", "K_ENGINE", 
	"K_EXISTS", "K_FETCH", "K_FINAL", "K_FIRST", "K_FROM", "K_FREEZE", "K_FORMAT", 
	"K_FULL", "K_GLOBAL", "K_GROUP", "K_HAVING", "K_HOUR", "K_ID", "K_IF", 
	"K_INNER", "K_INSERT", "K_INTERVAL", "K_INTO", "K_IN", "K_IS", "K_JOIN", 
	"K_KILL", "K_LAST", "K_LEFT", "K_LIKE", "K_LIMIT", "K_MAIN", "K_MATERIALIZED", 
	"K_MINUTE", "K_MODIFY", "K_MONTH", "K_NOT", "K_NULL", "K_NULLS", "K_OFFSET", 
	"K_ON", "K_OPTIMIZE", "K_ORDER", "K_OR", "K_OUTFILE", "K_PARTITION", "K_POPULATE", 
	"K_PREWHERE", "K_PROCESSLIST", "K_QUERY", "K_RENAME", "K_RETURN", "K_RIGHT", 
	"K_SAMPLE", "K_SECOND", "K_SELECT", "K_SET", "K_SETTINGS", "K_SHOW", "K_SYNC", 
	"K_TABLE", "K_TABLES", "K_TEMPORARY", "K_TEST", "K_THEN", "K_TOTALS", "K_TO", 
	"K_TTL", "K_OUTER", "K_VALUES", "K_VOLUME", "K_VIEW", "K_UNION", "K_USE", 
	"K_USING", "K_WEEK", "K_WHEN", "K_WHERE", "K_WITH", "K_YEAR", "COLON", 
	"COMMA", "SEMI", "LPAREN", "RPAREN", "RARROW", "LT", "GT", "QUESTION", 
	"STAR", "PLUS", "CONCAT", "OR", "DOLLAR", "DOT", "PERCENT", "MINUS", "DIVIDE", 
	"EQUALS", "ASSIGN", "NOT_EQUALS", "NOT_EQUALS2", "LE", "GE", "LBRAKET", 
	"RBRAKET", "LCURLY", "RCURLY", "T_ARRAY", "T_TUPLE", "T_NULLABLE", "T_FLOAT32", 
	"T_FLOAT64", "T_UINT8", "T_UINT16", "T_UINT32", "T_UINT64", "T_INT8", "T_INT16", 
	"T_INT32", "T_INT64", "T_ENUM8", "T_ENUM16", "T_UUID", "T_DATE", "T_DATETIME", 
	"T_STRING", "T_FIXEDSTRING", "T_NULL", "T_INTERVAL_YEAR", "T_INTERVAL_MONTH", 
	"T_INTERVAL_WEEK", "T_INTERVAL_DAY", "T_INTERVAL_HOUR", "T_INTERVAL_MINUTE", 
	"T_INTERVAL_SECOND", "T_AGGREGATE_FUNCTION", "IDENTIFIER", "NUMERIC_LITERAL", 
	"STRING_LITERAL", "QUOTED_LITERAL", "SPACES", "UNEXPECTED_CHAR",
}

var ruleNames = []string{
	"parse", "query", "select_query", "select_query_main", "select_with_step", 
	"select_select_step", "select_from_step", "select_array_join_step", "select_sample_step", 
	"sample_ratio", "select_join_step", "select_join_right_part", "select_prewhere_step", 
	"select_where_step", "select_groupby_step", "select_having_step", "select_orderby_step", 
	"select_limit_step", "select_limitby_step", "settings_step", "select_format_step", 
	"insert_query", "create_query", "rename_query", "drop_query", "alter_query", 
	"alter_query_element", "clickhouse_type", "simple_type", "enum_entry", 
	"use_query", "set_query", "assignment_list", "assignment", "kill_query_query", 
	"optimize_query", "table_properties_query", "show_tables_query", "show_processlist_query", 
	"check_query", "full_table_name", "partition_name", "cluster_name", "database_name", 
	"table_name", "format_name", "query_outfile_step", "engine", "identifier_with_optional_parameters", 
	"identifier_with_parameters", "order_by_expression_list", "order_by_element", 
	"table_ttl_list", "partition_by_element", "table_ttl_declaration", "nested_table", 
	"name_type_pair_list", "name_type_pair", "compound_name_type_pair", "column_declaration_list", 
	"column_declaration", "column_name", "column_type", "column_name_list", 
	"select_expr_list", "select_expr", "select_alias", "alias", "alias_name", 
	"table_function", "subquery", "expression_with_optional_alias", "expr", 
	"interval_unit", "expression_list", "not_empty_expression_list", "array", 
	"function", "function_parameters", "function_arguments", "function_name", 
	"identifier", "keyword", "compound_identifier", "literal", "err",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type ClickHouseParser struct {
	*antlr.BaseParser
}

func NewClickHouseParser(input antlr.TokenStream) *ClickHouseParser {
	this := new(ClickHouseParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ClickHouseParser.g4"

	return this
}

// ClickHouseParser tokens.
const (
	ClickHouseParserEOF = antlr.TokenEOF
	ClickHouseParserLINE_COMMENT = 1
	ClickHouseParserK_ADD = 2
	ClickHouseParserK_AFTER = 3
	ClickHouseParserK_ALL = 4
	ClickHouseParserK_ALIAS = 5
	ClickHouseParserK_ALTER = 6
	ClickHouseParserK_AND = 7
	ClickHouseParserK_ANY = 8
	ClickHouseParserK_ARRAY = 9
	ClickHouseParserK_AS = 10
	ClickHouseParserK_ASCENDING = 11
	ClickHouseParserK_ASC = 12
	ClickHouseParserK_ASYNC = 13
	ClickHouseParserK_ATTACH = 14
	ClickHouseParserK_BETWEEN = 15
	ClickHouseParserK_BY = 16
	ClickHouseParserK_CASE = 17
	ClickHouseParserK_CAST = 18
	ClickHouseParserK_CHECK = 19
	ClickHouseParserK_CLUSTER = 20
	ClickHouseParserK_COLUMN = 21
	ClickHouseParserK_COLLATE = 22
	ClickHouseParserK_CODEC = 23
	ClickHouseParserK_CREATE = 24
	ClickHouseParserK_CROSS = 25
	ClickHouseParserK_DAY = 26
	ClickHouseParserK_DELETE = 27
	ClickHouseParserK_DESCRIBE = 28
	ClickHouseParserK_DESCENDING = 29
	ClickHouseParserK_DESC = 30
	ClickHouseParserK_DATABASE = 31
	ClickHouseParserK_DATABASES = 32
	ClickHouseParserK_DEFAULT = 33
	ClickHouseParserK_DETACH = 34
	ClickHouseParserK_DISK = 35
	ClickHouseParserK_DISTINCT = 36
	ClickHouseParserK_DROP = 37
	ClickHouseParserK_ELSE = 38
	ClickHouseParserK_END = 39
	ClickHouseParserK_ENGINE = 40
	ClickHouseParserK_EXISTS = 41
	ClickHouseParserK_FETCH = 42
	ClickHouseParserK_FINAL = 43
	ClickHouseParserK_FIRST = 44
	ClickHouseParserK_FROM = 45
	ClickHouseParserK_FREEZE = 46
	ClickHouseParserK_FORMAT = 47
	ClickHouseParserK_FULL = 48
	ClickHouseParserK_GLOBAL = 49
	ClickHouseParserK_GROUP = 50
	ClickHouseParserK_HAVING = 51
	ClickHouseParserK_HOUR = 52
	ClickHouseParserK_ID = 53
	ClickHouseParserK_IF = 54
	ClickHouseParserK_INNER = 55
	ClickHouseParserK_INSERT = 56
	ClickHouseParserK_INTERVAL = 57
	ClickHouseParserK_INTO = 58
	ClickHouseParserK_IN = 59
	ClickHouseParserK_IS = 60
	ClickHouseParserK_JOIN = 61
	ClickHouseParserK_KILL = 62
	ClickHouseParserK_LAST = 63
	ClickHouseParserK_LEFT = 64
	ClickHouseParserK_LIKE = 65
	ClickHouseParserK_LIMIT = 66
	ClickHouseParserK_MAIN = 67
	ClickHouseParserK_MATERIALIZED = 68
	ClickHouseParserK_MINUTE = 69
	ClickHouseParserK_MODIFY = 70
	ClickHouseParserK_MONTH = 71
	ClickHouseParserK_NOT = 72
	ClickHouseParserK_NULL = 73
	ClickHouseParserK_NULLS = 74
	ClickHouseParserK_OFFSET = 75
	ClickHouseParserK_ON = 76
	ClickHouseParserK_OPTIMIZE = 77
	ClickHouseParserK_ORDER = 78
	ClickHouseParserK_OR = 79
	ClickHouseParserK_OUTFILE = 80
	ClickHouseParserK_PARTITION = 81
	ClickHouseParserK_POPULATE = 82
	ClickHouseParserK_PREWHERE = 83
	ClickHouseParserK_PROCESSLIST = 84
	ClickHouseParserK_QUERY = 85
	ClickHouseParserK_RENAME = 86
	ClickHouseParserK_RETURN = 87
	ClickHouseParserK_RIGHT = 88
	ClickHouseParserK_SAMPLE = 89
	ClickHouseParserK_SECOND = 90
	ClickHouseParserK_SELECT = 91
	ClickHouseParserK_SET = 92
	ClickHouseParserK_SETTINGS = 93
	ClickHouseParserK_SHOW = 94
	ClickHouseParserK_SYNC = 95
	ClickHouseParserK_TABLE = 96
	ClickHouseParserK_TABLES = 97
	ClickHouseParserK_TEMPORARY = 98
	ClickHouseParserK_TEST = 99
	ClickHouseParserK_THEN = 100
	ClickHouseParserK_TOTALS = 101
	ClickHouseParserK_TO = 102
	ClickHouseParserK_TTL = 103
	ClickHouseParserK_OUTER = 104
	ClickHouseParserK_VALUES = 105
	ClickHouseParserK_VOLUME = 106
	ClickHouseParserK_VIEW = 107
	ClickHouseParserK_UNION = 108
	ClickHouseParserK_USE = 109
	ClickHouseParserK_USING = 110
	ClickHouseParserK_WEEK = 111
	ClickHouseParserK_WHEN = 112
	ClickHouseParserK_WHERE = 113
	ClickHouseParserK_WITH = 114
	ClickHouseParserK_YEAR = 115
	ClickHouseParserCOLON = 116
	ClickHouseParserCOMMA = 117
	ClickHouseParserSEMI = 118
	ClickHouseParserLPAREN = 119
	ClickHouseParserRPAREN = 120
	ClickHouseParserRARROW = 121
	ClickHouseParserLT = 122
	ClickHouseParserGT = 123
	ClickHouseParserQUESTION = 124
	ClickHouseParserSTAR = 125
	ClickHouseParserPLUS = 126
	ClickHouseParserCONCAT = 127
	ClickHouseParserOR = 128
	ClickHouseParserDOLLAR = 129
	ClickHouseParserDOT = 130
	ClickHouseParserPERCENT = 131
	ClickHouseParserMINUS = 132
	ClickHouseParserDIVIDE = 133
	ClickHouseParserEQUALS = 134
	ClickHouseParserASSIGN = 135
	ClickHouseParserNOT_EQUALS = 136
	ClickHouseParserNOT_EQUALS2 = 137
	ClickHouseParserLE = 138
	ClickHouseParserGE = 139
	ClickHouseParserLBRAKET = 140
	ClickHouseParserRBRAKET = 141
	ClickHouseParserLCURLY = 142
	ClickHouseParserRCURLY = 143
	ClickHouseParserT_ARRAY = 144
	ClickHouseParserT_TUPLE = 145
	ClickHouseParserT_NULLABLE = 146
	ClickHouseParserT_FLOAT32 = 147
	ClickHouseParserT_FLOAT64 = 148
	ClickHouseParserT_UINT8 = 149
	ClickHouseParserT_UINT16 = 150
	ClickHouseParserT_UINT32 = 151
	ClickHouseParserT_UINT64 = 152
	ClickHouseParserT_INT8 = 153
	ClickHouseParserT_INT16 = 154
	ClickHouseParserT_INT32 = 155
	ClickHouseParserT_INT64 = 156
	ClickHouseParserT_ENUM8 = 157
	ClickHouseParserT_ENUM16 = 158
	ClickHouseParserT_UUID = 159
	ClickHouseParserT_DATE = 160
	ClickHouseParserT_DATETIME = 161
	ClickHouseParserT_STRING = 162
	ClickHouseParserT_FIXEDSTRING = 163
	ClickHouseParserT_NULL = 164
	ClickHouseParserT_INTERVAL_YEAR = 165
	ClickHouseParserT_INTERVAL_MONTH = 166
	ClickHouseParserT_INTERVAL_WEEK = 167
	ClickHouseParserT_INTERVAL_DAY = 168
	ClickHouseParserT_INTERVAL_HOUR = 169
	ClickHouseParserT_INTERVAL_MINUTE = 170
	ClickHouseParserT_INTERVAL_SECOND = 171
	ClickHouseParserT_AGGREGATE_FUNCTION = 172
	ClickHouseParserIDENTIFIER = 173
	ClickHouseParserNUMERIC_LITERAL = 174
	ClickHouseParserSTRING_LITERAL = 175
	ClickHouseParserQUOTED_LITERAL = 176
	ClickHouseParserSPACES = 177
	ClickHouseParserUNEXPECTED_CHAR = 178
)

// ClickHouseParser rules.
const (
	ClickHouseParserRULE_parse = 0
	ClickHouseParserRULE_query = 1
	ClickHouseParserRULE_select_query = 2
	ClickHouseParserRULE_select_query_main = 3
	ClickHouseParserRULE_select_with_step = 4
	ClickHouseParserRULE_select_select_step = 5
	ClickHouseParserRULE_select_from_step = 6
	ClickHouseParserRULE_select_array_join_step = 7
	ClickHouseParserRULE_select_sample_step = 8
	ClickHouseParserRULE_sample_ratio = 9
	ClickHouseParserRULE_select_join_step = 10
	ClickHouseParserRULE_select_join_right_part = 11
	ClickHouseParserRULE_select_prewhere_step = 12
	ClickHouseParserRULE_select_where_step = 13
	ClickHouseParserRULE_select_groupby_step = 14
	ClickHouseParserRULE_select_having_step = 15
	ClickHouseParserRULE_select_orderby_step = 16
	ClickHouseParserRULE_select_limit_step = 17
	ClickHouseParserRULE_select_limitby_step = 18
	ClickHouseParserRULE_settings_step = 19
	ClickHouseParserRULE_select_format_step = 20
	ClickHouseParserRULE_insert_query = 21
	ClickHouseParserRULE_create_query = 22
	ClickHouseParserRULE_rename_query = 23
	ClickHouseParserRULE_drop_query = 24
	ClickHouseParserRULE_alter_query = 25
	ClickHouseParserRULE_alter_query_element = 26
	ClickHouseParserRULE_clickhouse_type = 27
	ClickHouseParserRULE_simple_type = 28
	ClickHouseParserRULE_enum_entry = 29
	ClickHouseParserRULE_use_query = 30
	ClickHouseParserRULE_set_query = 31
	ClickHouseParserRULE_assignment_list = 32
	ClickHouseParserRULE_assignment = 33
	ClickHouseParserRULE_kill_query_query = 34
	ClickHouseParserRULE_optimize_query = 35
	ClickHouseParserRULE_table_properties_query = 36
	ClickHouseParserRULE_show_tables_query = 37
	ClickHouseParserRULE_show_processlist_query = 38
	ClickHouseParserRULE_check_query = 39
	ClickHouseParserRULE_full_table_name = 40
	ClickHouseParserRULE_partition_name = 41
	ClickHouseParserRULE_cluster_name = 42
	ClickHouseParserRULE_database_name = 43
	ClickHouseParserRULE_table_name = 44
	ClickHouseParserRULE_format_name = 45
	ClickHouseParserRULE_query_outfile_step = 46
	ClickHouseParserRULE_engine = 47
	ClickHouseParserRULE_identifier_with_optional_parameters = 48
	ClickHouseParserRULE_identifier_with_parameters = 49
	ClickHouseParserRULE_order_by_expression_list = 50
	ClickHouseParserRULE_order_by_element = 51
	ClickHouseParserRULE_table_ttl_list = 52
	ClickHouseParserRULE_partition_by_element = 53
	ClickHouseParserRULE_table_ttl_declaration = 54
	ClickHouseParserRULE_nested_table = 55
	ClickHouseParserRULE_name_type_pair_list = 56
	ClickHouseParserRULE_name_type_pair = 57
	ClickHouseParserRULE_compound_name_type_pair = 58
	ClickHouseParserRULE_column_declaration_list = 59
	ClickHouseParserRULE_column_declaration = 60
	ClickHouseParserRULE_column_name = 61
	ClickHouseParserRULE_column_type = 62
	ClickHouseParserRULE_column_name_list = 63
	ClickHouseParserRULE_select_expr_list = 64
	ClickHouseParserRULE_select_expr = 65
	ClickHouseParserRULE_select_alias = 66
	ClickHouseParserRULE_alias = 67
	ClickHouseParserRULE_alias_name = 68
	ClickHouseParserRULE_table_function = 69
	ClickHouseParserRULE_subquery = 70
	ClickHouseParserRULE_expression_with_optional_alias = 71
	ClickHouseParserRULE_expr = 72
	ClickHouseParserRULE_interval_unit = 73
	ClickHouseParserRULE_expression_list = 74
	ClickHouseParserRULE_not_empty_expression_list = 75
	ClickHouseParserRULE_array = 76
	ClickHouseParserRULE_function = 77
	ClickHouseParserRULE_function_parameters = 78
	ClickHouseParserRULE_function_arguments = 79
	ClickHouseParserRULE_function_name = 80
	ClickHouseParserRULE_identifier = 81
	ClickHouseParserRULE_keyword = 82
	ClickHouseParserRULE_compound_identifier = 83
	ClickHouseParserRULE_literal = 84
	ClickHouseParserRULE_err = 85
)

// IParseContext is an interface to support dynamic dispatch.
type IParseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParseContext differentiates from other interfaces.
	IsParseContext()
}

type ParseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseContext() *ParseContext {
	var p = new(ParseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_parse
	return p
}

func (*ParseContext) IsParseContext() {}

func NewParseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseContext {
	var p = new(ParseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_parse

	return p
}

func (s *ParseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseContext) EOF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEOF, 0)
}

func (s *ParseContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ParseContext) Err() IErrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IErrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IErrContext)
}

func (s *ParseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterParse(s)
	}
}

func (s *ParseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitParse(s)
	}
}




func (p *ClickHouseParser) Parse() (localctx IParseContext) {
	localctx = NewParseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ClickHouseParserRULE_parse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(174)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserK_ALTER, ClickHouseParserK_ATTACH, ClickHouseParserK_CHECK, ClickHouseParserK_CREATE, ClickHouseParserK_DESCRIBE, ClickHouseParserK_DESC, ClickHouseParserK_DETACH, ClickHouseParserK_DROP, ClickHouseParserK_EXISTS, ClickHouseParserK_INSERT, ClickHouseParserK_KILL, ClickHouseParserK_OPTIMIZE, ClickHouseParserK_RENAME, ClickHouseParserK_SELECT, ClickHouseParserK_SET, ClickHouseParserK_SHOW, ClickHouseParserK_USE, ClickHouseParserK_WITH:
		{
			p.SetState(172)
			p.Query()
		}


	case ClickHouseParserUNEXPECTED_CHAR:
		{
			p.SetState(173)
			p.Err()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(176)
		p.Match(ClickHouseParserEOF)
	}



	return localctx
}


// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) Show_tables_query() IShow_tables_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShow_tables_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShow_tables_queryContext)
}

func (s *QueryContext) Select_query() ISelect_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_queryContext)
}

func (s *QueryContext) Insert_query() IInsert_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsert_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsert_queryContext)
}

func (s *QueryContext) Create_query() ICreate_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_queryContext)
}

func (s *QueryContext) Rename_query() IRename_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRename_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRename_queryContext)
}

func (s *QueryContext) Drop_query() IDrop_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrop_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrop_queryContext)
}

func (s *QueryContext) Alter_query() IAlter_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlter_queryContext)
}

func (s *QueryContext) Use_query() IUse_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_queryContext)
}

func (s *QueryContext) Set_query() ISet_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_queryContext)
}

func (s *QueryContext) Optimize_query() IOptimize_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptimize_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptimize_queryContext)
}

func (s *QueryContext) Table_properties_query() ITable_properties_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_properties_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_properties_queryContext)
}

func (s *QueryContext) Show_processlist_query() IShow_processlist_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShow_processlist_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShow_processlist_queryContext)
}

func (s *QueryContext) Check_query() ICheck_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheck_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheck_queryContext)
}

func (s *QueryContext) Kill_query_query() IKill_query_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKill_query_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKill_query_queryContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitQuery(s)
	}
}




func (p *ClickHouseParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ClickHouseParserRULE_query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(192)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(178)
			p.Show_tables_query()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(179)
			p.Select_query()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(180)
			p.Insert_query()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(181)
			p.Create_query()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(182)
			p.Rename_query()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(183)
			p.Drop_query()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(184)
			p.Alter_query()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(185)
			p.Use_query()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(186)
			p.Set_query()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(187)
			p.Optimize_query()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(188)
			p.Table_properties_query()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(189)
			p.Show_processlist_query()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(190)
			p.Check_query()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(191)
			p.Kill_query_query()
		}

	}


	return localctx
}


// ISelect_queryContext is an interface to support dynamic dispatch.
type ISelect_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_queryContext differentiates from other interfaces.
	IsSelect_queryContext()
}

type Select_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_queryContext() *Select_queryContext {
	var p = new(Select_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_query
	return p
}

func (*Select_queryContext) IsSelect_queryContext() {}

func NewSelect_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_queryContext {
	var p = new(Select_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_query

	return p
}

func (s *Select_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_queryContext) AllSelect_query_main() []ISelect_query_mainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelect_query_mainContext)(nil)).Elem())
	var tst = make([]ISelect_query_mainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelect_query_mainContext)
		}
	}

	return tst
}

func (s *Select_queryContext) Select_query_main(i int) ISelect_query_mainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_query_mainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelect_query_mainContext)
}

func (s *Select_queryContext) AllK_UNION() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserK_UNION)
}

func (s *Select_queryContext) K_UNION(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_UNION, i)
}

func (s *Select_queryContext) AllK_ALL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserK_ALL)
}

func (s *Select_queryContext) K_ALL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ALL, i)
}

func (s *Select_queryContext) Query_outfile_step() IQuery_outfile_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_outfile_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_outfile_stepContext)
}

func (s *Select_queryContext) Select_format_step() ISelect_format_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_format_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_format_stepContext)
}

func (s *Select_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_query(s)
	}
}

func (s *Select_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_query(s)
	}
}




func (p *ClickHouseParser) Select_query() (localctx ISelect_queryContext) {
	localctx = NewSelect_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ClickHouseParserRULE_select_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(194)
		p.Select_query_main()
	}
	p.SetState(200)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserK_UNION {
		{
			p.SetState(195)
			p.Match(ClickHouseParserK_UNION)
		}
		{
			p.SetState(196)
			p.Match(ClickHouseParserK_ALL)
		}
		{
			p.SetState(197)
			p.Select_query_main()
		}


		p.SetState(202)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(204)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_INTO {
		{
			p.SetState(203)
			p.Query_outfile_step()
		}

	}
	p.SetState(207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_FORMAT {
		{
			p.SetState(206)
			p.Select_format_step()
		}

	}



	return localctx
}


// ISelect_query_mainContext is an interface to support dynamic dispatch.
type ISelect_query_mainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_query_mainContext differentiates from other interfaces.
	IsSelect_query_mainContext()
}

type Select_query_mainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_query_mainContext() *Select_query_mainContext {
	var p = new(Select_query_mainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_query_main
	return p
}

func (*Select_query_mainContext) IsSelect_query_mainContext() {}

func NewSelect_query_mainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_query_mainContext {
	var p = new(Select_query_mainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_query_main

	return p
}

func (s *Select_query_mainContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_query_mainContext) Select_select_step() ISelect_select_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_select_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_select_stepContext)
}

func (s *Select_query_mainContext) Select_with_step() ISelect_with_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_with_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_with_stepContext)
}

func (s *Select_query_mainContext) Select_from_step() ISelect_from_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_from_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_from_stepContext)
}

func (s *Select_query_mainContext) K_FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FINAL, 0)
}

func (s *Select_query_mainContext) Select_sample_step() ISelect_sample_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_sample_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_sample_stepContext)
}

func (s *Select_query_mainContext) Select_array_join_step() ISelect_array_join_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_array_join_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_array_join_stepContext)
}

func (s *Select_query_mainContext) Select_join_step() ISelect_join_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_join_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_join_stepContext)
}

func (s *Select_query_mainContext) Select_prewhere_step() ISelect_prewhere_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_prewhere_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_prewhere_stepContext)
}

func (s *Select_query_mainContext) Select_where_step() ISelect_where_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_where_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_where_stepContext)
}

func (s *Select_query_mainContext) Select_groupby_step() ISelect_groupby_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_groupby_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_groupby_stepContext)
}

func (s *Select_query_mainContext) Select_having_step() ISelect_having_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_having_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_having_stepContext)
}

func (s *Select_query_mainContext) Select_orderby_step() ISelect_orderby_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_orderby_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_orderby_stepContext)
}

func (s *Select_query_mainContext) Select_limitby_step() ISelect_limitby_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_limitby_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_limitby_stepContext)
}

func (s *Select_query_mainContext) Select_limit_step() ISelect_limit_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_limit_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_limit_stepContext)
}

func (s *Select_query_mainContext) Settings_step() ISettings_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISettings_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISettings_stepContext)
}

func (s *Select_query_mainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_query_mainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_query_mainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_query_main(s)
	}
}

func (s *Select_query_mainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_query_main(s)
	}
}




func (p *ClickHouseParser) Select_query_main() (localctx ISelect_query_mainContext) {
	localctx = NewSelect_query_mainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ClickHouseParserRULE_select_query_main)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_WITH {
		{
			p.SetState(209)
			p.Select_with_step()
		}

	}
	{
		p.SetState(212)
		p.Select_select_step()
	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_FROM {
		{
			p.SetState(213)
			p.Select_from_step()
		}

	}
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_FINAL {
		{
			p.SetState(216)
			p.Match(ClickHouseParserK_FINAL)
		}

	}
	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_SAMPLE {
		{
			p.SetState(219)
			p.Select_sample_step()
		}

	}
	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_ARRAY || _la == ClickHouseParserK_LEFT {
		{
			p.SetState(222)
			p.Select_array_join_step()
		}

	}
	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ClickHouseParserK_ALL) | (1 << ClickHouseParserK_ANY) | (1 << ClickHouseParserK_CROSS))) != 0) || _la == ClickHouseParserK_GLOBAL {
		{
			p.SetState(225)
			p.Select_join_step()
		}

	}
	p.SetState(229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_PREWHERE {
		{
			p.SetState(228)
			p.Select_prewhere_step()
		}

	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_WHERE {
		{
			p.SetState(231)
			p.Select_where_step()
		}

	}
	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_GROUP {
		{
			p.SetState(234)
			p.Select_groupby_step()
		}

	}
	p.SetState(238)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_HAVING {
		{
			p.SetState(237)
			p.Select_having_step()
		}

	}
	p.SetState(241)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(240)
			p.Select_orderby_step()
		}


	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(243)
			p.Select_limitby_step()
		}


	}
	p.SetState(247)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_LIMIT {
		{
			p.SetState(246)
			p.Select_limit_step()
		}

	}
	p.SetState(250)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_SETTINGS {
		{
			p.SetState(249)
			p.Settings_step()
		}

	}



	return localctx
}


// ISelect_with_stepContext is an interface to support dynamic dispatch.
type ISelect_with_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_with_stepContext differentiates from other interfaces.
	IsSelect_with_stepContext()
}

type Select_with_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_with_stepContext() *Select_with_stepContext {
	var p = new(Select_with_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_with_step
	return p
}

func (*Select_with_stepContext) IsSelect_with_stepContext() {}

func NewSelect_with_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_with_stepContext {
	var p = new(Select_with_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_with_step

	return p
}

func (s *Select_with_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_with_stepContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_WITH, 0)
}

func (s *Select_with_stepContext) Select_expr_list() ISelect_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_expr_listContext)
}

func (s *Select_with_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_with_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_with_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_with_step(s)
	}
}

func (s *Select_with_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_with_step(s)
	}
}




func (p *ClickHouseParser) Select_with_step() (localctx ISelect_with_stepContext) {
	localctx = NewSelect_with_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ClickHouseParserRULE_select_with_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(252)
		p.Match(ClickHouseParserK_WITH)
	}
	{
		p.SetState(253)
		p.Select_expr_list()
	}



	return localctx
}


// ISelect_select_stepContext is an interface to support dynamic dispatch.
type ISelect_select_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_select_stepContext differentiates from other interfaces.
	IsSelect_select_stepContext()
}

type Select_select_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_select_stepContext() *Select_select_stepContext {
	var p = new(Select_select_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_select_step
	return p
}

func (*Select_select_stepContext) IsSelect_select_stepContext() {}

func NewSelect_select_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_select_stepContext {
	var p = new(Select_select_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_select_step

	return p
}

func (s *Select_select_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_select_stepContext) K_SELECT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SELECT, 0)
}

func (s *Select_select_stepContext) Select_expr_list() ISelect_expr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_expr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_expr_listContext)
}

func (s *Select_select_stepContext) K_DISTINCT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DISTINCT, 0)
}

func (s *Select_select_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_select_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_select_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_select_step(s)
	}
}

func (s *Select_select_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_select_step(s)
	}
}




func (p *ClickHouseParser) Select_select_step() (localctx ISelect_select_stepContext) {
	localctx = NewSelect_select_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ClickHouseParserRULE_select_select_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(255)
		p.Match(ClickHouseParserK_SELECT)
	}
	p.SetState(257)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(256)
			p.Match(ClickHouseParserK_DISTINCT)
		}


	}
	{
		p.SetState(259)
		p.Select_expr_list()
	}



	return localctx
}


// ISelect_from_stepContext is an interface to support dynamic dispatch.
type ISelect_from_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_from_stepContext differentiates from other interfaces.
	IsSelect_from_stepContext()
}

type Select_from_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_from_stepContext() *Select_from_stepContext {
	var p = new(Select_from_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_from_step
	return p
}

func (*Select_from_stepContext) IsSelect_from_stepContext() {}

func NewSelect_from_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_from_stepContext {
	var p = new(Select_from_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_from_step

	return p
}

func (s *Select_from_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_from_stepContext) K_FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FROM, 0)
}

func (s *Select_from_stepContext) Full_table_name() IFull_table_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_table_nameContext)
}

func (s *Select_from_stepContext) Table_function() ITable_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_functionContext)
}

func (s *Select_from_stepContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Select_from_stepContext) Select_alias() ISelect_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_aliasContext)
}

func (s *Select_from_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_from_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_from_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_from_step(s)
	}
}

func (s *Select_from_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_from_step(s)
	}
}




func (p *ClickHouseParser) Select_from_step() (localctx ISelect_from_stepContext) {
	localctx = NewSelect_from_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ClickHouseParserRULE_select_from_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(ClickHouseParserK_FROM)
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(262)
			p.Full_table_name()
		}


	case 2:
		{
			p.SetState(263)
			p.Table_function()
		}


	case 3:
		{
			p.SetState(264)
			p.Subquery()
		}

	}
	p.SetState(268)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(267)
			p.Select_alias()
		}


	}



	return localctx
}


// ISelect_array_join_stepContext is an interface to support dynamic dispatch.
type ISelect_array_join_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_array_join_stepContext differentiates from other interfaces.
	IsSelect_array_join_stepContext()
}

type Select_array_join_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_array_join_stepContext() *Select_array_join_stepContext {
	var p = new(Select_array_join_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_array_join_step
	return p
}

func (*Select_array_join_stepContext) IsSelect_array_join_stepContext() {}

func NewSelect_array_join_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_array_join_stepContext {
	var p = new(Select_array_join_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_array_join_step

	return p
}

func (s *Select_array_join_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_array_join_stepContext) K_ARRAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ARRAY, 0)
}

func (s *Select_array_join_stepContext) K_JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_JOIN, 0)
}

func (s *Select_array_join_stepContext) Not_empty_expression_list() INot_empty_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_empty_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_empty_expression_listContext)
}

func (s *Select_array_join_stepContext) K_LEFT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LEFT, 0)
}

func (s *Select_array_join_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_array_join_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_array_join_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_array_join_step(s)
	}
}

func (s *Select_array_join_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_array_join_step(s)
	}
}




func (p *ClickHouseParser) Select_array_join_step() (localctx ISelect_array_join_stepContext) {
	localctx = NewSelect_array_join_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ClickHouseParserRULE_select_array_join_step)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_LEFT {
		{
			p.SetState(270)
			p.Match(ClickHouseParserK_LEFT)
		}

	}
	{
		p.SetState(273)
		p.Match(ClickHouseParserK_ARRAY)
	}
	{
		p.SetState(274)
		p.Match(ClickHouseParserK_JOIN)
	}
	{
		p.SetState(275)
		p.Not_empty_expression_list()
	}



	return localctx
}


// ISelect_sample_stepContext is an interface to support dynamic dispatch.
type ISelect_sample_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_sample_stepContext differentiates from other interfaces.
	IsSelect_sample_stepContext()
}

type Select_sample_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_sample_stepContext() *Select_sample_stepContext {
	var p = new(Select_sample_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_sample_step
	return p
}

func (*Select_sample_stepContext) IsSelect_sample_stepContext() {}

func NewSelect_sample_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_sample_stepContext {
	var p = new(Select_sample_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_sample_step

	return p
}

func (s *Select_sample_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_sample_stepContext) K_SAMPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SAMPLE, 0)
}

func (s *Select_sample_stepContext) AllSample_ratio() []ISample_ratioContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISample_ratioContext)(nil)).Elem())
	var tst = make([]ISample_ratioContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISample_ratioContext)
		}
	}

	return tst
}

func (s *Select_sample_stepContext) Sample_ratio(i int) ISample_ratioContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISample_ratioContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISample_ratioContext)
}

func (s *Select_sample_stepContext) K_OFFSET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OFFSET, 0)
}

func (s *Select_sample_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_sample_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_sample_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_sample_step(s)
	}
}

func (s *Select_sample_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_sample_step(s)
	}
}




func (p *ClickHouseParser) Select_sample_step() (localctx ISelect_sample_stepContext) {
	localctx = NewSelect_sample_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ClickHouseParserRULE_select_sample_step)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(277)
		p.Match(ClickHouseParserK_SAMPLE)
	}
	{
		p.SetState(278)
		p.Sample_ratio()
	}
	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_OFFSET {
		{
			p.SetState(279)
			p.Match(ClickHouseParserK_OFFSET)
		}
		{
			p.SetState(280)
			p.Sample_ratio()
		}

	}



	return localctx
}


// ISample_ratioContext is an interface to support dynamic dispatch.
type ISample_ratioContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSample_ratioContext differentiates from other interfaces.
	IsSample_ratioContext()
}

type Sample_ratioContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_ratioContext() *Sample_ratioContext {
	var p = new(Sample_ratioContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sample_ratio
	return p
}

func (*Sample_ratioContext) IsSample_ratioContext() {}

func NewSample_ratioContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_ratioContext {
	var p = new(Sample_ratioContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_sample_ratio

	return p
}

func (s *Sample_ratioContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_ratioContext) AllNUMERIC_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserNUMERIC_LITERAL)
}

func (s *Sample_ratioContext) NUMERIC_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNUMERIC_LITERAL, i)
}

func (s *Sample_ratioContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDIVIDE, 0)
}

func (s *Sample_ratioContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_ratioContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sample_ratioContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSample_ratio(s)
	}
}

func (s *Sample_ratioContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSample_ratio(s)
	}
}




func (p *ClickHouseParser) Sample_ratio() (localctx ISample_ratioContext) {
	localctx = NewSample_ratioContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ClickHouseParserRULE_sample_ratio)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Match(ClickHouseParserNUMERIC_LITERAL)
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserDIVIDE {
		{
			p.SetState(284)
			p.Match(ClickHouseParserDIVIDE)
		}
		{
			p.SetState(285)
			p.Match(ClickHouseParserNUMERIC_LITERAL)
		}

	}



	return localctx
}


// ISelect_join_stepContext is an interface to support dynamic dispatch.
type ISelect_join_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_join_stepContext differentiates from other interfaces.
	IsSelect_join_stepContext()
}

type Select_join_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_join_stepContext() *Select_join_stepContext {
	var p = new(Select_join_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_join_step
	return p
}

func (*Select_join_stepContext) IsSelect_join_stepContext() {}

func NewSelect_join_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_join_stepContext {
	var p = new(Select_join_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_join_step

	return p
}

func (s *Select_join_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_join_stepContext) K_JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_JOIN, 0)
}

func (s *Select_join_stepContext) Select_join_right_part() ISelect_join_right_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_join_right_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_join_right_partContext)
}

func (s *Select_join_stepContext) K_ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ANY, 0)
}

func (s *Select_join_stepContext) K_ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ALL, 0)
}

func (s *Select_join_stepContext) K_INNER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_INNER, 0)
}

func (s *Select_join_stepContext) K_LEFT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LEFT, 0)
}

func (s *Select_join_stepContext) K_RIGHT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_RIGHT, 0)
}

func (s *Select_join_stepContext) K_FULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FULL, 0)
}

func (s *Select_join_stepContext) K_USING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_USING, 0)
}

func (s *Select_join_stepContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *Select_join_stepContext) Not_empty_expression_list() INot_empty_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_empty_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_empty_expression_listContext)
}

func (s *Select_join_stepContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *Select_join_stepContext) K_GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_GLOBAL, 0)
}

func (s *Select_join_stepContext) K_OUTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OUTER, 0)
}

func (s *Select_join_stepContext) K_CROSS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CROSS, 0)
}

func (s *Select_join_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_join_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_join_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_join_step(s)
	}
}

func (s *Select_join_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_join_step(s)
	}
}




func (p *ClickHouseParser) Select_join_step() (localctx ISelect_join_stepContext) {
	localctx = NewSelect_join_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ClickHouseParserRULE_select_join_step)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(289)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_GLOBAL {
			{
				p.SetState(288)
				p.Match(ClickHouseParserK_GLOBAL)
			}

		}
		p.SetState(291)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserK_ALL || _la == ClickHouseParserK_ANY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		p.SetState(305)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserK_INNER:
			{
				p.SetState(292)
				p.Match(ClickHouseParserK_INNER)
			}


		case ClickHouseParserK_LEFT:
			{
				p.SetState(293)
				p.Match(ClickHouseParserK_LEFT)
			}
			p.SetState(295)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ClickHouseParserK_OUTER {
				{
					p.SetState(294)
					p.Match(ClickHouseParserK_OUTER)
				}

			}


		case ClickHouseParserK_RIGHT:
			{
				p.SetState(297)
				p.Match(ClickHouseParserK_RIGHT)
			}
			p.SetState(299)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ClickHouseParserK_OUTER {
				{
					p.SetState(298)
					p.Match(ClickHouseParserK_OUTER)
				}

			}


		case ClickHouseParserK_FULL:
			{
				p.SetState(301)
				p.Match(ClickHouseParserK_FULL)
			}
			p.SetState(303)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ClickHouseParserK_OUTER {
				{
					p.SetState(302)
					p.Match(ClickHouseParserK_OUTER)
				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(307)
			p.Match(ClickHouseParserK_JOIN)
		}
		{
			p.SetState(308)
			p.Select_join_right_part()
		}
		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(309)
				p.Match(ClickHouseParserK_USING)
			}
			{
				p.SetState(310)
				p.Match(ClickHouseParserLPAREN)
			}
			{
				p.SetState(311)
				p.Not_empty_expression_list()
			}
			{
				p.SetState(312)
				p.Match(ClickHouseParserRPAREN)
			}


		case 2:
			{
				p.SetState(314)
				p.Match(ClickHouseParserK_USING)
			}
			{
				p.SetState(315)
				p.Not_empty_expression_list()
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(319)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_GLOBAL {
			{
				p.SetState(318)
				p.Match(ClickHouseParserK_GLOBAL)
			}

		}
		{
			p.SetState(321)
			p.Match(ClickHouseParserK_CROSS)
		}
		{
			p.SetState(322)
			p.Match(ClickHouseParserK_JOIN)
		}
		{
			p.SetState(323)
			p.Select_join_right_part()
		}

	}


	return localctx
}


// ISelect_join_right_partContext is an interface to support dynamic dispatch.
type ISelect_join_right_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_join_right_partContext differentiates from other interfaces.
	IsSelect_join_right_partContext()
}

type Select_join_right_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_join_right_partContext() *Select_join_right_partContext {
	var p = new(Select_join_right_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_join_right_part
	return p
}

func (*Select_join_right_partContext) IsSelect_join_right_partContext() {}

func NewSelect_join_right_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_join_right_partContext {
	var p = new(Select_join_right_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_join_right_part

	return p
}

func (s *Select_join_right_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_join_right_partContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Select_join_right_partContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Select_join_right_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_join_right_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_join_right_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_join_right_part(s)
	}
}

func (s *Select_join_right_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_join_right_part(s)
	}
}




func (p *ClickHouseParser) Select_join_right_part() (localctx ISelect_join_right_partContext) {
	localctx = NewSelect_join_right_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ClickHouseParserRULE_select_join_right_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(328)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserK_ADD, ClickHouseParserK_AFTER, ClickHouseParserK_ALL, ClickHouseParserK_ALIAS, ClickHouseParserK_ALTER, ClickHouseParserK_AND, ClickHouseParserK_ANY, ClickHouseParserK_ARRAY, ClickHouseParserK_AS, ClickHouseParserK_ASCENDING, ClickHouseParserK_ASC, ClickHouseParserK_ASYNC, ClickHouseParserK_ATTACH, ClickHouseParserK_BETWEEN, ClickHouseParserK_BY, ClickHouseParserK_CASE, ClickHouseParserK_CHECK, ClickHouseParserK_COLUMN, ClickHouseParserK_COLLATE, ClickHouseParserK_CREATE, ClickHouseParserK_CROSS, ClickHouseParserK_DESCRIBE, ClickHouseParserK_DESCENDING, ClickHouseParserK_DESC, ClickHouseParserK_DATABASE, ClickHouseParserK_DATABASES, ClickHouseParserK_DEFAULT, ClickHouseParserK_DETACH, ClickHouseParserK_DISTINCT, ClickHouseParserK_DROP, ClickHouseParserK_ELSE, ClickHouseParserK_END, ClickHouseParserK_ENGINE, ClickHouseParserK_EXISTS, ClickHouseParserK_FINAL, ClickHouseParserK_FIRST, ClickHouseParserK_FROM, ClickHouseParserK_FORMAT, ClickHouseParserK_FULL, ClickHouseParserK_GLOBAL, ClickHouseParserK_GROUP, ClickHouseParserK_HAVING, ClickHouseParserK_ID, ClickHouseParserK_IF, ClickHouseParserK_INNER, ClickHouseParserK_INSERT, ClickHouseParserK_INTO, ClickHouseParserK_IN, ClickHouseParserK_IS, ClickHouseParserK_JOIN, ClickHouseParserK_KILL, ClickHouseParserK_LAST, ClickHouseParserK_LEFT, ClickHouseParserK_LIKE, ClickHouseParserK_LIMIT, ClickHouseParserK_MAIN, ClickHouseParserK_MATERIALIZED, ClickHouseParserK_MODIFY, ClickHouseParserK_NOT, ClickHouseParserK_NULL, ClickHouseParserK_NULLS, ClickHouseParserK_OFFSET, ClickHouseParserK_ON, ClickHouseParserK_OPTIMIZE, ClickHouseParserK_ORDER, ClickHouseParserK_OR, ClickHouseParserK_OUTFILE, ClickHouseParserK_PARTITION, ClickHouseParserK_POPULATE, ClickHouseParserK_PREWHERE, ClickHouseParserK_PROCESSLIST, ClickHouseParserK_QUERY, ClickHouseParserK_RENAME, ClickHouseParserK_RETURN, ClickHouseParserK_RIGHT, ClickHouseParserK_SAMPLE, ClickHouseParserK_SELECT, ClickHouseParserK_SET, ClickHouseParserK_SETTINGS, ClickHouseParserK_SHOW, ClickHouseParserK_SYNC, ClickHouseParserK_TABLE, ClickHouseParserK_TABLES, ClickHouseParserK_TEMPORARY, ClickHouseParserK_TEST, ClickHouseParserK_THEN, ClickHouseParserK_TOTALS, ClickHouseParserK_TO, ClickHouseParserK_OUTER, ClickHouseParserK_VALUES, ClickHouseParserK_VIEW, ClickHouseParserK_UNION, ClickHouseParserK_USE, ClickHouseParserK_USING, ClickHouseParserK_WHEN, ClickHouseParserK_WHERE, ClickHouseParserK_WITH, ClickHouseParserT_FLOAT32, ClickHouseParserT_FLOAT64, ClickHouseParserT_UINT8, ClickHouseParserT_UINT16, ClickHouseParserT_UINT32, ClickHouseParserT_UINT64, ClickHouseParserT_INT8, ClickHouseParserT_INT16, ClickHouseParserT_INT32, ClickHouseParserT_INT64, ClickHouseParserT_ENUM8, ClickHouseParserT_ENUM16, ClickHouseParserT_UUID, ClickHouseParserT_DATE, ClickHouseParserT_DATETIME, ClickHouseParserT_STRING, ClickHouseParserT_FIXEDSTRING, ClickHouseParserT_NULL, ClickHouseParserT_INTERVAL_YEAR, ClickHouseParserT_INTERVAL_MONTH, ClickHouseParserT_INTERVAL_WEEK, ClickHouseParserT_INTERVAL_DAY, ClickHouseParserT_INTERVAL_HOUR, ClickHouseParserT_INTERVAL_MINUTE, ClickHouseParserT_INTERVAL_SECOND, ClickHouseParserIDENTIFIER, ClickHouseParserQUOTED_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(326)
			p.Identifier()
		}


	case ClickHouseParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(327)
			p.Subquery()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISelect_prewhere_stepContext is an interface to support dynamic dispatch.
type ISelect_prewhere_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_prewhere_stepContext differentiates from other interfaces.
	IsSelect_prewhere_stepContext()
}

type Select_prewhere_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_prewhere_stepContext() *Select_prewhere_stepContext {
	var p = new(Select_prewhere_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_prewhere_step
	return p
}

func (*Select_prewhere_stepContext) IsSelect_prewhere_stepContext() {}

func NewSelect_prewhere_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_prewhere_stepContext {
	var p = new(Select_prewhere_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_prewhere_step

	return p
}

func (s *Select_prewhere_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_prewhere_stepContext) K_PREWHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_PREWHERE, 0)
}

func (s *Select_prewhere_stepContext) Expression_with_optional_alias() IExpression_with_optional_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_with_optional_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_with_optional_aliasContext)
}

func (s *Select_prewhere_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_prewhere_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_prewhere_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_prewhere_step(s)
	}
}

func (s *Select_prewhere_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_prewhere_step(s)
	}
}




func (p *ClickHouseParser) Select_prewhere_step() (localctx ISelect_prewhere_stepContext) {
	localctx = NewSelect_prewhere_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ClickHouseParserRULE_select_prewhere_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(330)
		p.Match(ClickHouseParserK_PREWHERE)
	}
	{
		p.SetState(331)
		p.Expression_with_optional_alias()
	}



	return localctx
}


// ISelect_where_stepContext is an interface to support dynamic dispatch.
type ISelect_where_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_where_stepContext differentiates from other interfaces.
	IsSelect_where_stepContext()
}

type Select_where_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_where_stepContext() *Select_where_stepContext {
	var p = new(Select_where_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_where_step
	return p
}

func (*Select_where_stepContext) IsSelect_where_stepContext() {}

func NewSelect_where_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_where_stepContext {
	var p = new(Select_where_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_where_step

	return p
}

func (s *Select_where_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_where_stepContext) K_WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_WHERE, 0)
}

func (s *Select_where_stepContext) Expression_with_optional_alias() IExpression_with_optional_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_with_optional_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_with_optional_aliasContext)
}

func (s *Select_where_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_where_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_where_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_where_step(s)
	}
}

func (s *Select_where_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_where_step(s)
	}
}




func (p *ClickHouseParser) Select_where_step() (localctx ISelect_where_stepContext) {
	localctx = NewSelect_where_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ClickHouseParserRULE_select_where_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Match(ClickHouseParserK_WHERE)
	}
	{
		p.SetState(334)
		p.Expression_with_optional_alias()
	}



	return localctx
}


// ISelect_groupby_stepContext is an interface to support dynamic dispatch.
type ISelect_groupby_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_groupby_stepContext differentiates from other interfaces.
	IsSelect_groupby_stepContext()
}

type Select_groupby_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_groupby_stepContext() *Select_groupby_stepContext {
	var p = new(Select_groupby_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_groupby_step
	return p
}

func (*Select_groupby_stepContext) IsSelect_groupby_stepContext() {}

func NewSelect_groupby_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_groupby_stepContext {
	var p = new(Select_groupby_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_groupby_step

	return p
}

func (s *Select_groupby_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_groupby_stepContext) K_GROUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_GROUP, 0)
}

func (s *Select_groupby_stepContext) K_BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_BY, 0)
}

func (s *Select_groupby_stepContext) Not_empty_expression_list() INot_empty_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_empty_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_empty_expression_listContext)
}

func (s *Select_groupby_stepContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_WITH, 0)
}

func (s *Select_groupby_stepContext) K_TOTALS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TOTALS, 0)
}

func (s *Select_groupby_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_groupby_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_groupby_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_groupby_step(s)
	}
}

func (s *Select_groupby_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_groupby_step(s)
	}
}




func (p *ClickHouseParser) Select_groupby_step() (localctx ISelect_groupby_stepContext) {
	localctx = NewSelect_groupby_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ClickHouseParserRULE_select_groupby_step)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(336)
		p.Match(ClickHouseParserK_GROUP)
	}
	{
		p.SetState(337)
		p.Match(ClickHouseParserK_BY)
	}
	{
		p.SetState(338)
		p.Not_empty_expression_list()
	}
	p.SetState(341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_WITH {
		{
			p.SetState(339)
			p.Match(ClickHouseParserK_WITH)
		}
		{
			p.SetState(340)
			p.Match(ClickHouseParserK_TOTALS)
		}

	}



	return localctx
}


// ISelect_having_stepContext is an interface to support dynamic dispatch.
type ISelect_having_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_having_stepContext differentiates from other interfaces.
	IsSelect_having_stepContext()
}

type Select_having_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_having_stepContext() *Select_having_stepContext {
	var p = new(Select_having_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_having_step
	return p
}

func (*Select_having_stepContext) IsSelect_having_stepContext() {}

func NewSelect_having_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_having_stepContext {
	var p = new(Select_having_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_having_step

	return p
}

func (s *Select_having_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_having_stepContext) K_HAVING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_HAVING, 0)
}

func (s *Select_having_stepContext) Expression_with_optional_alias() IExpression_with_optional_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_with_optional_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_with_optional_aliasContext)
}

func (s *Select_having_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_having_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_having_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_having_step(s)
	}
}

func (s *Select_having_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_having_step(s)
	}
}




func (p *ClickHouseParser) Select_having_step() (localctx ISelect_having_stepContext) {
	localctx = NewSelect_having_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ClickHouseParserRULE_select_having_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(343)
		p.Match(ClickHouseParserK_HAVING)
	}
	{
		p.SetState(344)
		p.Expression_with_optional_alias()
	}



	return localctx
}


// ISelect_orderby_stepContext is an interface to support dynamic dispatch.
type ISelect_orderby_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_orderby_stepContext differentiates from other interfaces.
	IsSelect_orderby_stepContext()
}

type Select_orderby_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_orderby_stepContext() *Select_orderby_stepContext {
	var p = new(Select_orderby_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_orderby_step
	return p
}

func (*Select_orderby_stepContext) IsSelect_orderby_stepContext() {}

func NewSelect_orderby_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_orderby_stepContext {
	var p = new(Select_orderby_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_orderby_step

	return p
}

func (s *Select_orderby_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_orderby_stepContext) K_ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ORDER, 0)
}

func (s *Select_orderby_stepContext) K_BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_BY, 0)
}

func (s *Select_orderby_stepContext) Order_by_expression_list() IOrder_by_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_expression_listContext)
}

func (s *Select_orderby_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_orderby_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_orderby_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_orderby_step(s)
	}
}

func (s *Select_orderby_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_orderby_step(s)
	}
}




func (p *ClickHouseParser) Select_orderby_step() (localctx ISelect_orderby_stepContext) {
	localctx = NewSelect_orderby_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ClickHouseParserRULE_select_orderby_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Match(ClickHouseParserK_ORDER)
	}
	{
		p.SetState(347)
		p.Match(ClickHouseParserK_BY)
	}
	{
		p.SetState(348)
		p.Order_by_expression_list()
	}



	return localctx
}


// ISelect_limit_stepContext is an interface to support dynamic dispatch.
type ISelect_limit_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_limit_stepContext differentiates from other interfaces.
	IsSelect_limit_stepContext()
}

type Select_limit_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_limit_stepContext() *Select_limit_stepContext {
	var p = new(Select_limit_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_limit_step
	return p
}

func (*Select_limit_stepContext) IsSelect_limit_stepContext() {}

func NewSelect_limit_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_limit_stepContext {
	var p = new(Select_limit_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_limit_step

	return p
}

func (s *Select_limit_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_limit_stepContext) K_LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LIMIT, 0)
}

func (s *Select_limit_stepContext) AllNUMERIC_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserNUMERIC_LITERAL)
}

func (s *Select_limit_stepContext) NUMERIC_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNUMERIC_LITERAL, i)
}

func (s *Select_limit_stepContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, 0)
}

func (s *Select_limit_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_limit_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_limit_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_limit_step(s)
	}
}

func (s *Select_limit_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_limit_step(s)
	}
}




func (p *ClickHouseParser) Select_limit_step() (localctx ISelect_limit_stepContext) {
	localctx = NewSelect_limit_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ClickHouseParserRULE_select_limit_step)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Match(ClickHouseParserK_LIMIT)
	}
	{
		p.SetState(351)
		p.Match(ClickHouseParserNUMERIC_LITERAL)
	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserCOMMA {
		{
			p.SetState(352)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(353)
			p.Match(ClickHouseParserNUMERIC_LITERAL)
		}

	}



	return localctx
}


// ISelect_limitby_stepContext is an interface to support dynamic dispatch.
type ISelect_limitby_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_limitby_stepContext differentiates from other interfaces.
	IsSelect_limitby_stepContext()
}

type Select_limitby_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_limitby_stepContext() *Select_limitby_stepContext {
	var p = new(Select_limitby_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_limitby_step
	return p
}

func (*Select_limitby_stepContext) IsSelect_limitby_stepContext() {}

func NewSelect_limitby_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_limitby_stepContext {
	var p = new(Select_limitby_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_limitby_step

	return p
}

func (s *Select_limitby_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_limitby_stepContext) K_LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LIMIT, 0)
}

func (s *Select_limitby_stepContext) NUMERIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNUMERIC_LITERAL, 0)
}

func (s *Select_limitby_stepContext) K_BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_BY, 0)
}

func (s *Select_limitby_stepContext) Not_empty_expression_list() INot_empty_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_empty_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_empty_expression_listContext)
}

func (s *Select_limitby_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_limitby_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_limitby_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_limitby_step(s)
	}
}

func (s *Select_limitby_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_limitby_step(s)
	}
}




func (p *ClickHouseParser) Select_limitby_step() (localctx ISelect_limitby_stepContext) {
	localctx = NewSelect_limitby_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ClickHouseParserRULE_select_limitby_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(356)
		p.Match(ClickHouseParserK_LIMIT)
	}
	{
		p.SetState(357)
		p.Match(ClickHouseParserNUMERIC_LITERAL)
	}
	{
		p.SetState(358)
		p.Match(ClickHouseParserK_BY)
	}
	{
		p.SetState(359)
		p.Not_empty_expression_list()
	}



	return localctx
}


// ISettings_stepContext is an interface to support dynamic dispatch.
type ISettings_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSettings_stepContext differentiates from other interfaces.
	IsSettings_stepContext()
}

type Settings_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettings_stepContext() *Settings_stepContext {
	var p = new(Settings_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settings_step
	return p
}

func (*Settings_stepContext) IsSettings_stepContext() {}

func NewSettings_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Settings_stepContext {
	var p = new(Settings_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_settings_step

	return p
}

func (s *Settings_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Settings_stepContext) K_SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SETTINGS, 0)
}

func (s *Settings_stepContext) Assignment_list() IAssignment_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_listContext)
}

func (s *Settings_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Settings_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Settings_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSettings_step(s)
	}
}

func (s *Settings_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSettings_step(s)
	}
}




func (p *ClickHouseParser) Settings_step() (localctx ISettings_stepContext) {
	localctx = NewSettings_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ClickHouseParserRULE_settings_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(361)
		p.Match(ClickHouseParserK_SETTINGS)
	}
	{
		p.SetState(362)
		p.Assignment_list()
	}



	return localctx
}


// ISelect_format_stepContext is an interface to support dynamic dispatch.
type ISelect_format_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_format_stepContext differentiates from other interfaces.
	IsSelect_format_stepContext()
}

type Select_format_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_format_stepContext() *Select_format_stepContext {
	var p = new(Select_format_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_format_step
	return p
}

func (*Select_format_stepContext) IsSelect_format_stepContext() {}

func NewSelect_format_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_format_stepContext {
	var p = new(Select_format_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_format_step

	return p
}

func (s *Select_format_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_format_stepContext) K_FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FORMAT, 0)
}

func (s *Select_format_stepContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Select_format_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_format_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_format_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_format_step(s)
	}
}

func (s *Select_format_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_format_step(s)
	}
}




func (p *ClickHouseParser) Select_format_step() (localctx ISelect_format_stepContext) {
	localctx = NewSelect_format_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ClickHouseParserRULE_select_format_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(364)
		p.Match(ClickHouseParserK_FORMAT)
	}
	{
		p.SetState(365)
		p.Identifier()
	}



	return localctx
}


// IInsert_queryContext is an interface to support dynamic dispatch.
type IInsert_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsert_queryContext differentiates from other interfaces.
	IsInsert_queryContext()
}

type Insert_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_queryContext() *Insert_queryContext {
	var p = new(Insert_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_insert_query
	return p
}

func (*Insert_queryContext) IsInsert_queryContext() {}

func NewInsert_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_queryContext {
	var p = new(Insert_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_insert_query

	return p
}

func (s *Insert_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_queryContext) K_INSERT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_INSERT, 0)
}

func (s *Insert_queryContext) K_INTO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_INTO, 0)
}

func (s *Insert_queryContext) Full_table_name() IFull_table_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_table_nameContext)
}

func (s *Insert_queryContext) K_VALUES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_VALUES, 0)
}

func (s *Insert_queryContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *Insert_queryContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *Insert_queryContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *Insert_queryContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Insert_queryContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserRPAREN)
}

func (s *Insert_queryContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, i)
}

func (s *Insert_queryContext) K_FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FORMAT, 0)
}

func (s *Insert_queryContext) Format_name() IFormat_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormat_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormat_nameContext)
}

func (s *Insert_queryContext) Select_query() ISelect_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_queryContext)
}

func (s *Insert_queryContext) K_ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ID, 0)
}

func (s *Insert_queryContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASSIGN, 0)
}

func (s *Insert_queryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Insert_queryContext) Column_name_list() IColumn_name_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_name_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Insert_queryContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Insert_queryContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Insert_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Insert_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterInsert_query(s)
	}
}

func (s *Insert_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitInsert_query(s)
	}
}




func (p *ClickHouseParser) Insert_query() (localctx IInsert_queryContext) {
	localctx = NewInsert_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ClickHouseParserRULE_insert_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(ClickHouseParserK_INSERT)
	}
	{
		p.SetState(368)
		p.Match(ClickHouseParserK_INTO)
	}
	{
		p.SetState(369)
		p.Full_table_name()
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_ID {
		{
			p.SetState(370)
			p.Match(ClickHouseParserK_ID)
		}
		{
			p.SetState(371)
			p.Match(ClickHouseParserASSIGN)
		}
		{
			p.SetState(372)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserLPAREN {
		{
			p.SetState(375)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(376)
			p.Column_name_list()
		}
		{
			p.SetState(377)
			p.Match(ClickHouseParserRPAREN)
		}

	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserK_VALUES:
		{
			p.SetState(381)
			p.Match(ClickHouseParserK_VALUES)
		}
		{
			p.SetState(382)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(383)
			p.Literal()
		}
		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(384)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(385)
				p.Literal()
			}


			p.SetState(390)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(391)
			p.Match(ClickHouseParserRPAREN)
		}
		p.SetState(406)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(392)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(393)
				p.Match(ClickHouseParserLPAREN)
			}
			{
				p.SetState(394)
				p.Literal()
			}
			p.SetState(399)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for _la == ClickHouseParserCOMMA {
				{
					p.SetState(395)
					p.Match(ClickHouseParserCOMMA)
				}
				{
					p.SetState(396)
					p.Literal()
				}


				p.SetState(401)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(402)
				p.Match(ClickHouseParserRPAREN)
			}


			p.SetState(408)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}


	case ClickHouseParserK_FORMAT:
		{
			p.SetState(409)
			p.Match(ClickHouseParserK_FORMAT)
		}
		{
			p.SetState(410)
			p.Format_name()
		}


	case ClickHouseParserK_SELECT, ClickHouseParserK_WITH:
		{
			p.SetState(411)
			p.Select_query()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// ICreate_queryContext is an interface to support dynamic dispatch.
type ICreate_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSampleExpr returns the sampleExpr rule contexts.
	GetSampleExpr() IExprContext


	// SetSampleExpr sets the sampleExpr rule contexts.
	SetSampleExpr(IExprContext)


	// IsCreate_queryContext differentiates from other interfaces.
	IsCreate_queryContext()
}

type Create_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	sampleExpr IExprContext 
}

func NewEmptyCreate_queryContext() *Create_queryContext {
	var p = new(Create_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_create_query
	return p
}

func (*Create_queryContext) IsCreate_queryContext() {}

func NewCreate_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_queryContext {
	var p = new(Create_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_create_query

	return p
}

func (s *Create_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_queryContext) GetSampleExpr() IExprContext { return s.sampleExpr }


func (s *Create_queryContext) SetSampleExpr(v IExprContext) { s.sampleExpr = v }


func (s *Create_queryContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CREATE, 0)
}

func (s *Create_queryContext) K_ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ATTACH, 0)
}

func (s *Create_queryContext) K_DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DATABASE, 0)
}

func (s *Create_queryContext) Database_name() IDatabase_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabase_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabase_nameContext)
}

func (s *Create_queryContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLE, 0)
}

func (s *Create_queryContext) AllFull_table_name() []IFull_table_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem())
	var tst = make([]IFull_table_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFull_table_nameContext)
		}
	}

	return tst
}

func (s *Create_queryContext) Full_table_name(i int) IFull_table_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFull_table_nameContext)
}

func (s *Create_queryContext) K_VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_VIEW, 0)
}

func (s *Create_queryContext) K_AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AS, 0)
}

func (s *Create_queryContext) Select_query() ISelect_queryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_queryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_queryContext)
}

func (s *Create_queryContext) K_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TEMPORARY, 0)
}

func (s *Create_queryContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *Create_queryContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *Create_queryContext) Column_declaration_list() IColumn_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_declaration_listContext)
}

func (s *Create_queryContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserRPAREN)
}

func (s *Create_queryContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, i)
}

func (s *Create_queryContext) AllEngine() []IEngineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEngineContext)(nil)).Elem())
	var tst = make([]IEngineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEngineContext)
		}
	}

	return tst
}

func (s *Create_queryContext) Engine(i int) IEngineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEngineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEngineContext)
}

func (s *Create_queryContext) Partition_by_element() IPartition_by_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartition_by_elementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartition_by_elementContext)
}

func (s *Create_queryContext) K_ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ORDER, 0)
}

func (s *Create_queryContext) AllK_BY() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserK_BY)
}

func (s *Create_queryContext) K_BY(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_BY, i)
}

func (s *Create_queryContext) Order_by_expression_list() IOrder_by_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_expression_listContext)
}

func (s *Create_queryContext) K_IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_IF, 0)
}

func (s *Create_queryContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NOT, 0)
}

func (s *Create_queryContext) K_EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_EXISTS, 0)
}

func (s *Create_queryContext) K_ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ON, 0)
}

func (s *Create_queryContext) K_CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CLUSTER, 0)
}

func (s *Create_queryContext) Cluster_name() ICluster_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICluster_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICluster_nameContext)
}

func (s *Create_queryContext) K_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_MATERIALIZED, 0)
}

func (s *Create_queryContext) K_POPULATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_POPULATE, 0)
}

func (s *Create_queryContext) K_SAMPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SAMPLE, 0)
}

func (s *Create_queryContext) Table_ttl_list() ITable_ttl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_ttl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_ttl_listContext)
}

func (s *Create_queryContext) Settings_step() ISettings_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISettings_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISettings_stepContext)
}

func (s *Create_queryContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreate_query(s)
	}
}

func (s *Create_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreate_query(s)
	}
}




func (p *ClickHouseParser) Create_query() (localctx ICreate_queryContext) {
	localctx = NewCreate_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ClickHouseParserRULE_create_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(414)
	_la = p.GetTokenStream().LA(1)

	if !(_la == ClickHouseParserK_ATTACH || _la == ClickHouseParserK_CREATE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_TEMPORARY {
		{
			p.SetState(415)
			p.Match(ClickHouseParserK_TEMPORARY)
		}

	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserK_DATABASE:
		{
			p.SetState(418)
			p.Match(ClickHouseParserK_DATABASE)
		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(419)
				p.Match(ClickHouseParserK_IF)
			}
			{
				p.SetState(420)
				p.Match(ClickHouseParserK_NOT)
			}
			{
				p.SetState(421)
				p.Match(ClickHouseParserK_EXISTS)
			}


		}
		{
			p.SetState(424)
			p.Database_name()
		}


	case ClickHouseParserK_TABLE:
		{
			p.SetState(425)
			p.Match(ClickHouseParserK_TABLE)
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(426)
				p.Match(ClickHouseParserK_IF)
			}
			{
				p.SetState(427)
				p.Match(ClickHouseParserK_NOT)
			}
			{
				p.SetState(428)
				p.Match(ClickHouseParserK_EXISTS)
			}


		}
		{
			p.SetState(431)
			p.Full_table_name()
		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_ON {
			{
				p.SetState(432)
				p.Match(ClickHouseParserK_ON)
			}
			{
				p.SetState(433)
				p.Match(ClickHouseParserK_CLUSTER)
			}
			{
				p.SetState(434)
				p.Cluster_name()
			}

		}
		p.SetState(471)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserLPAREN:
			{
				p.SetState(437)
				p.Match(ClickHouseParserLPAREN)
			}
			{
				p.SetState(438)
				p.Column_declaration_list()
			}
			{
				p.SetState(439)
				p.Match(ClickHouseParserRPAREN)
			}
			{
				p.SetState(440)
				p.Engine()
			}
			p.SetState(443)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ClickHouseParserK_AS {
				{
					p.SetState(441)
					p.Match(ClickHouseParserK_AS)
				}
				{
					p.SetState(442)
					p.Select_query()
				}

			}
			{
				p.SetState(445)
				p.Partition_by_element()
			}
			{
				p.SetState(446)
				p.Match(ClickHouseParserK_ORDER)
			}
			{
				p.SetState(447)
				p.Match(ClickHouseParserK_BY)
			}
			{
				p.SetState(448)
				p.Match(ClickHouseParserLPAREN)
			}
			{
				p.SetState(449)
				p.Order_by_expression_list()
			}
			{
				p.SetState(450)
				p.Match(ClickHouseParserRPAREN)
			}
			p.SetState(454)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ClickHouseParserK_SAMPLE {
				{
					p.SetState(451)
					p.Match(ClickHouseParserK_SAMPLE)
				}
				{
					p.SetState(452)
					p.Match(ClickHouseParserK_BY)
				}
				{
					p.SetState(453)

					var _x = p.expr(0)

					localctx.(*Create_queryContext).sampleExpr = _x
				}

			}
			p.SetState(457)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ClickHouseParserK_TTL {
				{
					p.SetState(456)
					p.Table_ttl_list()
				}

			}
			p.SetState(460)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ClickHouseParserK_SETTINGS {
				{
					p.SetState(459)
					p.Settings_step()
				}

			}


		case ClickHouseParserK_ENGINE:
			{
				p.SetState(462)
				p.Engine()
			}
			{
				p.SetState(463)
				p.Match(ClickHouseParserK_AS)
			}
			p.SetState(469)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(464)
					p.Select_query()
				}


			case 2:
				{
					p.SetState(465)
					p.Full_table_name()
				}
				p.SetState(467)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == ClickHouseParserK_ENGINE {
					{
						p.SetState(466)
						p.Engine()
					}

				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	case ClickHouseParserK_MATERIALIZED, ClickHouseParserK_VIEW:
		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_MATERIALIZED {
			{
				p.SetState(473)
				p.Match(ClickHouseParserK_MATERIALIZED)
			}

		}
		{
			p.SetState(476)
			p.Match(ClickHouseParserK_VIEW)
		}
		p.SetState(480)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(477)
				p.Match(ClickHouseParserK_IF)
			}
			{
				p.SetState(478)
				p.Match(ClickHouseParserK_NOT)
			}
			{
				p.SetState(479)
				p.Match(ClickHouseParserK_EXISTS)
			}


		}
		{
			p.SetState(482)
			p.Full_table_name()
		}
		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserLPAREN {
			{
				p.SetState(483)
				p.Match(ClickHouseParserLPAREN)
			}
			{
				p.SetState(484)
				p.Column_declaration_list()
			}
			{
				p.SetState(485)
				p.Match(ClickHouseParserRPAREN)
			}

		}
		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_ENGINE {
			{
				p.SetState(489)
				p.Engine()
			}

		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_POPULATE {
			{
				p.SetState(492)
				p.Match(ClickHouseParserK_POPULATE)
			}

		}
		{
			p.SetState(495)
			p.Match(ClickHouseParserK_AS)
		}
		{
			p.SetState(496)
			p.Select_query()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IRename_queryContext is an interface to support dynamic dispatch.
type IRename_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRename_queryContext differentiates from other interfaces.
	IsRename_queryContext()
}

type Rename_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRename_queryContext() *Rename_queryContext {
	var p = new(Rename_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_rename_query
	return p
}

func (*Rename_queryContext) IsRename_queryContext() {}

func NewRename_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rename_queryContext {
	var p = new(Rename_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_rename_query

	return p
}

func (s *Rename_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Rename_queryContext) K_RENAME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_RENAME, 0)
}

func (s *Rename_queryContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLE, 0)
}

func (s *Rename_queryContext) AllFull_table_name() []IFull_table_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem())
	var tst = make([]IFull_table_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFull_table_nameContext)
		}
	}

	return tst
}

func (s *Rename_queryContext) Full_table_name(i int) IFull_table_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFull_table_nameContext)
}

func (s *Rename_queryContext) AllK_TO() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserK_TO)
}

func (s *Rename_queryContext) K_TO(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TO, i)
}

func (s *Rename_queryContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Rename_queryContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Rename_queryContext) K_ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ON, 0)
}

func (s *Rename_queryContext) K_CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CLUSTER, 0)
}

func (s *Rename_queryContext) Cluster_name() ICluster_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICluster_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICluster_nameContext)
}

func (s *Rename_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rename_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Rename_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterRename_query(s)
	}
}

func (s *Rename_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitRename_query(s)
	}
}




func (p *ClickHouseParser) Rename_query() (localctx IRename_queryContext) {
	localctx = NewRename_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ClickHouseParserRULE_rename_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)
		p.Match(ClickHouseParserK_RENAME)
	}
	{
		p.SetState(501)
		p.Match(ClickHouseParserK_TABLE)
	}
	{
		p.SetState(502)
		p.Full_table_name()
	}
	{
		p.SetState(503)
		p.Match(ClickHouseParserK_TO)
	}
	{
		p.SetState(504)
		p.Full_table_name()
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(505)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(506)
			p.Full_table_name()
		}
		{
			p.SetState(507)
			p.Match(ClickHouseParserK_TO)
		}
		{
			p.SetState(508)
			p.Full_table_name()
		}


		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_ON {
		{
			p.SetState(515)
			p.Match(ClickHouseParserK_ON)
		}
		{
			p.SetState(516)
			p.Match(ClickHouseParserK_CLUSTER)
		}
		{
			p.SetState(517)
			p.Cluster_name()
		}

	}



	return localctx
}


// IDrop_queryContext is an interface to support dynamic dispatch.
type IDrop_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrop_queryContext differentiates from other interfaces.
	IsDrop_queryContext()
}

type Drop_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_queryContext() *Drop_queryContext {
	var p = new(Drop_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_drop_query
	return p
}

func (*Drop_queryContext) IsDrop_queryContext() {}

func NewDrop_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_queryContext {
	var p = new(Drop_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_drop_query

	return p
}

func (s *Drop_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_queryContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DROP, 0)
}

func (s *Drop_queryContext) K_DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DETACH, 0)
}

func (s *Drop_queryContext) K_DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DATABASE, 0)
}

func (s *Drop_queryContext) Database_name() IDatabase_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabase_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabase_nameContext)
}

func (s *Drop_queryContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLE, 0)
}

func (s *Drop_queryContext) Full_table_name() IFull_table_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_table_nameContext)
}

func (s *Drop_queryContext) K_IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_IF, 0)
}

func (s *Drop_queryContext) K_EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_EXISTS, 0)
}

func (s *Drop_queryContext) K_ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ON, 0)
}

func (s *Drop_queryContext) K_CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CLUSTER, 0)
}

func (s *Drop_queryContext) Cluster_name() ICluster_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICluster_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICluster_nameContext)
}

func (s *Drop_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDrop_query(s)
	}
}

func (s *Drop_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDrop_query(s)
	}
}




func (p *ClickHouseParser) Drop_query() (localctx IDrop_queryContext) {
	localctx = NewDrop_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ClickHouseParserRULE_drop_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(520)
	_la = p.GetTokenStream().LA(1)

	if !(_la == ClickHouseParserK_DETACH || _la == ClickHouseParserK_DROP) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(543)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserK_DATABASE:
		{
			p.SetState(521)
			p.Match(ClickHouseParserK_DATABASE)
		}
		p.SetState(524)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(522)
				p.Match(ClickHouseParserK_IF)
			}
			{
				p.SetState(523)
				p.Match(ClickHouseParserK_EXISTS)
			}


		}
		{
			p.SetState(526)
			p.Database_name()
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_ON {
			{
				p.SetState(527)
				p.Match(ClickHouseParserK_ON)
			}
			{
				p.SetState(528)
				p.Match(ClickHouseParserK_CLUSTER)
			}
			{
				p.SetState(529)
				p.Cluster_name()
			}

		}


	case ClickHouseParserK_TABLE:
		{
			p.SetState(532)
			p.Match(ClickHouseParserK_TABLE)
		}
		p.SetState(535)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(533)
				p.Match(ClickHouseParserK_IF)
			}
			{
				p.SetState(534)
				p.Match(ClickHouseParserK_EXISTS)
			}


		}
		{
			p.SetState(537)
			p.Full_table_name()
		}
		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_ON {
			{
				p.SetState(538)
				p.Match(ClickHouseParserK_ON)
			}
			{
				p.SetState(539)
				p.Match(ClickHouseParserK_CLUSTER)
			}
			{
				p.SetState(540)
				p.Cluster_name()
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IAlter_queryContext is an interface to support dynamic dispatch.
type IAlter_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_queryContext differentiates from other interfaces.
	IsAlter_queryContext()
}

type Alter_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_queryContext() *Alter_queryContext {
	var p = new(Alter_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alter_query
	return p
}

func (*Alter_queryContext) IsAlter_queryContext() {}

func NewAlter_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_queryContext {
	var p = new(Alter_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alter_query

	return p
}

func (s *Alter_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_queryContext) K_ALTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ALTER, 0)
}

func (s *Alter_queryContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLE, 0)
}

func (s *Alter_queryContext) Full_table_name() IFull_table_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_table_nameContext)
}

func (s *Alter_queryContext) AllAlter_query_element() []IAlter_query_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlter_query_elementContext)(nil)).Elem())
	var tst = make([]IAlter_query_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlter_query_elementContext)
		}
	}

	return tst
}

func (s *Alter_queryContext) Alter_query_element(i int) IAlter_query_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlter_query_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlter_query_elementContext)
}

func (s *Alter_queryContext) K_ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ON, 0)
}

func (s *Alter_queryContext) K_CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CLUSTER, 0)
}

func (s *Alter_queryContext) Cluster_name() ICluster_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICluster_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICluster_nameContext)
}

func (s *Alter_queryContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Alter_queryContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Alter_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlter_query(s)
	}
}

func (s *Alter_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlter_query(s)
	}
}




func (p *ClickHouseParser) Alter_query() (localctx IAlter_queryContext) {
	localctx = NewAlter_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ClickHouseParserRULE_alter_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(545)
		p.Match(ClickHouseParserK_ALTER)
	}
	{
		p.SetState(546)
		p.Match(ClickHouseParserK_TABLE)
	}
	{
		p.SetState(547)
		p.Full_table_name()
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_ON {
		{
			p.SetState(548)
			p.Match(ClickHouseParserK_ON)
		}
		{
			p.SetState(549)
			p.Match(ClickHouseParserK_CLUSTER)
		}
		{
			p.SetState(550)
			p.Cluster_name()
		}

	}
	{
		p.SetState(553)
		p.Alter_query_element()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(554)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(555)
			p.Alter_query_element()
		}


		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAlter_query_elementContext is an interface to support dynamic dispatch.
type IAlter_query_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlter_query_elementContext differentiates from other interfaces.
	IsAlter_query_elementContext()
}

type Alter_query_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_query_elementContext() *Alter_query_elementContext {
	var p = new(Alter_query_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alter_query_element
	return p
}

func (*Alter_query_elementContext) IsAlter_query_elementContext() {}

func NewAlter_query_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_query_elementContext {
	var p = new(Alter_query_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alter_query_element

	return p
}

func (s *Alter_query_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_query_elementContext) K_ADD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ADD, 0)
}

func (s *Alter_query_elementContext) K_COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_COLUMN, 0)
}

func (s *Alter_query_elementContext) Compound_name_type_pair() ICompound_name_type_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_name_type_pairContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_name_type_pairContext)
}

func (s *Alter_query_elementContext) K_AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AFTER, 0)
}

func (s *Alter_query_elementContext) Column_name() IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Alter_query_elementContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DROP, 0)
}

func (s *Alter_query_elementContext) K_MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_MODIFY, 0)
}

func (s *Alter_query_elementContext) K_ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ATTACH, 0)
}

func (s *Alter_query_elementContext) K_PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_PARTITION, 0)
}

func (s *Alter_query_elementContext) Partition_name() IPartition_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartition_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartition_nameContext)
}

func (s *Alter_query_elementContext) K_DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DETACH, 0)
}

func (s *Alter_query_elementContext) K_FETCH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FETCH, 0)
}

func (s *Alter_query_elementContext) K_FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FROM, 0)
}

func (s *Alter_query_elementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Alter_query_elementContext) K_FREEZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FREEZE, 0)
}

func (s *Alter_query_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_query_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_query_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlter_query_element(s)
	}
}

func (s *Alter_query_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlter_query_element(s)
	}
}




func (p *ClickHouseParser) Alter_query_element() (localctx IAlter_query_elementContext) {
	localctx = NewAlter_query_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ClickHouseParserRULE_alter_query_element)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(561)
			p.Match(ClickHouseParserK_ADD)
		}
		{
			p.SetState(562)
			p.Match(ClickHouseParserK_COLUMN)
		}
		{
			p.SetState(563)
			p.Compound_name_type_pair()
		}
		p.SetState(566)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_AFTER {
			{
				p.SetState(564)
				p.Match(ClickHouseParserK_AFTER)
			}
			{
				p.SetState(565)
				p.Column_name()
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(568)
			p.Match(ClickHouseParserK_DROP)
		}
		{
			p.SetState(569)
			p.Match(ClickHouseParserK_COLUMN)
		}
		{
			p.SetState(570)
			p.Column_name()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(571)
			p.Match(ClickHouseParserK_MODIFY)
		}
		{
			p.SetState(572)
			p.Match(ClickHouseParserK_COLUMN)
		}
		{
			p.SetState(573)
			p.Compound_name_type_pair()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(574)
			p.Match(ClickHouseParserK_ATTACH)
		}
		{
			p.SetState(575)
			p.Match(ClickHouseParserK_PARTITION)
		}
		{
			p.SetState(576)
			p.Partition_name()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(577)
			p.Match(ClickHouseParserK_DETACH)
		}
		{
			p.SetState(578)
			p.Match(ClickHouseParserK_PARTITION)
		}
		{
			p.SetState(579)
			p.Partition_name()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(580)
			p.Match(ClickHouseParserK_DROP)
		}
		{
			p.SetState(581)
			p.Match(ClickHouseParserK_PARTITION)
		}
		{
			p.SetState(582)
			p.Partition_name()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(583)
			p.Match(ClickHouseParserK_FETCH)
		}
		{
			p.SetState(584)
			p.Match(ClickHouseParserK_PARTITION)
		}
		{
			p.SetState(585)
			p.Partition_name()
		}
		{
			p.SetState(586)
			p.Match(ClickHouseParserK_FROM)
		}
		{
			p.SetState(587)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(589)
			p.Match(ClickHouseParserK_FREEZE)
		}
		{
			p.SetState(590)
			p.Match(ClickHouseParserK_PARTITION)
		}
		{
			p.SetState(591)
			p.Partition_name()
		}

	}


	return localctx
}


// IClickhouse_typeContext is an interface to support dynamic dispatch.
type IClickhouse_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClickhouse_typeContext differentiates from other interfaces.
	IsClickhouse_typeContext()
}

type Clickhouse_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClickhouse_typeContext() *Clickhouse_typeContext {
	var p = new(Clickhouse_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_clickhouse_type
	return p
}

func (*Clickhouse_typeContext) IsClickhouse_typeContext() {}

func NewClickhouse_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clickhouse_typeContext {
	var p = new(Clickhouse_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_clickhouse_type

	return p
}

func (s *Clickhouse_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Clickhouse_typeContext) Simple_type() ISimple_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_typeContext)
}

func (s *Clickhouse_typeContext) T_AGGREGATE_FUNCTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_AGGREGATE_FUNCTION, 0)
}

func (s *Clickhouse_typeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *Clickhouse_typeContext) Function_name() IFunction_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Clickhouse_typeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *Clickhouse_typeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Clickhouse_typeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Clickhouse_typeContext) AllClickhouse_type() []IClickhouse_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClickhouse_typeContext)(nil)).Elem())
	var tst = make([]IClickhouse_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClickhouse_typeContext)
		}
	}

	return tst
}

func (s *Clickhouse_typeContext) Clickhouse_type(i int) IClickhouse_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClickhouse_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClickhouse_typeContext)
}

func (s *Clickhouse_typeContext) T_ARRAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_ARRAY, 0)
}

func (s *Clickhouse_typeContext) T_TUPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_TUPLE, 0)
}

func (s *Clickhouse_typeContext) T_NULLABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_NULLABLE, 0)
}

func (s *Clickhouse_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clickhouse_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Clickhouse_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterClickhouse_type(s)
	}
}

func (s *Clickhouse_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitClickhouse_type(s)
	}
}




func (p *ClickHouseParser) Clickhouse_type() (localctx IClickhouse_typeContext) {
	localctx = NewClickhouse_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ClickHouseParserRULE_clickhouse_type)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(629)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserT_FLOAT32, ClickHouseParserT_FLOAT64, ClickHouseParserT_UINT8, ClickHouseParserT_UINT16, ClickHouseParserT_UINT32, ClickHouseParserT_UINT64, ClickHouseParserT_INT8, ClickHouseParserT_INT16, ClickHouseParserT_INT32, ClickHouseParserT_INT64, ClickHouseParserT_ENUM8, ClickHouseParserT_ENUM16, ClickHouseParserT_UUID, ClickHouseParserT_DATE, ClickHouseParserT_DATETIME, ClickHouseParserT_STRING, ClickHouseParserT_FIXEDSTRING, ClickHouseParserT_NULL, ClickHouseParserT_INTERVAL_YEAR, ClickHouseParserT_INTERVAL_MONTH, ClickHouseParserT_INTERVAL_WEEK, ClickHouseParserT_INTERVAL_DAY, ClickHouseParserT_INTERVAL_HOUR, ClickHouseParserT_INTERVAL_MINUTE, ClickHouseParserT_INTERVAL_SECOND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(594)
			p.Simple_type()
		}


	case ClickHouseParserT_AGGREGATE_FUNCTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(595)
			p.Match(ClickHouseParserT_AGGREGATE_FUNCTION)
		}
		{
			p.SetState(596)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(597)
			p.Function_name()
		}
		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(598)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(599)
				p.Clickhouse_type()
			}


			p.SetState(604)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(605)
			p.Match(ClickHouseParserRPAREN)
		}


	case ClickHouseParserT_ARRAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(607)
			p.Match(ClickHouseParserT_ARRAY)
		}
		{
			p.SetState(608)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(609)
			p.Clickhouse_type()
		}
		{
			p.SetState(610)
			p.Match(ClickHouseParserRPAREN)
		}


	case ClickHouseParserT_TUPLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(612)
			p.Match(ClickHouseParserT_TUPLE)
		}
		{
			p.SetState(613)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(614)
			p.Clickhouse_type()
		}
		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(615)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(616)
				p.Clickhouse_type()
			}


			p.SetState(621)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(622)
			p.Match(ClickHouseParserRPAREN)
		}


	case ClickHouseParserT_NULLABLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(624)
			p.Match(ClickHouseParserT_NULLABLE)
		}
		{
			p.SetState(625)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(626)
			p.Clickhouse_type()
		}
		{
			p.SetState(627)
			p.Match(ClickHouseParserRPAREN)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISimple_typeContext is an interface to support dynamic dispatch.
type ISimple_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_typeContext differentiates from other interfaces.
	IsSimple_typeContext()
}

type Simple_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_typeContext() *Simple_typeContext {
	var p = new(Simple_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_simple_type
	return p
}

func (*Simple_typeContext) IsSimple_typeContext() {}

func NewSimple_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_typeContext {
	var p = new(Simple_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_simple_type

	return p
}

func (s *Simple_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_typeContext) T_UINT8() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_UINT8, 0)
}

func (s *Simple_typeContext) T_UINT16() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_UINT16, 0)
}

func (s *Simple_typeContext) T_UINT32() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_UINT32, 0)
}

func (s *Simple_typeContext) T_UINT64() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_UINT64, 0)
}

func (s *Simple_typeContext) T_INT8() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INT8, 0)
}

func (s *Simple_typeContext) T_INT16() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INT16, 0)
}

func (s *Simple_typeContext) T_INT32() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INT32, 0)
}

func (s *Simple_typeContext) T_INT64() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INT64, 0)
}

func (s *Simple_typeContext) T_FLOAT32() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_FLOAT32, 0)
}

func (s *Simple_typeContext) T_FLOAT64() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_FLOAT64, 0)
}

func (s *Simple_typeContext) T_ENUM8() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_ENUM8, 0)
}

func (s *Simple_typeContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *Simple_typeContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *Simple_typeContext) AllEnum_entry() []IEnum_entryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnum_entryContext)(nil)).Elem())
	var tst = make([]IEnum_entryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnum_entryContext)
		}
	}

	return tst
}

func (s *Simple_typeContext) Enum_entry(i int) IEnum_entryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_entryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnum_entryContext)
}

func (s *Simple_typeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *Simple_typeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Simple_typeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Simple_typeContext) T_ENUM16() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_ENUM16, 0)
}

func (s *Simple_typeContext) T_UUID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_UUID, 0)
}

func (s *Simple_typeContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_DATE, 0)
}

func (s *Simple_typeContext) T_DATETIME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_DATETIME, 0)
}

func (s *Simple_typeContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_STRING, 0)
}

func (s *Simple_typeContext) T_INTERVAL_YEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INTERVAL_YEAR, 0)
}

func (s *Simple_typeContext) T_INTERVAL_MONTH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INTERVAL_MONTH, 0)
}

func (s *Simple_typeContext) T_INTERVAL_WEEK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INTERVAL_WEEK, 0)
}

func (s *Simple_typeContext) T_INTERVAL_DAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INTERVAL_DAY, 0)
}

func (s *Simple_typeContext) T_INTERVAL_HOUR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INTERVAL_HOUR, 0)
}

func (s *Simple_typeContext) T_INTERVAL_MINUTE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INTERVAL_MINUTE, 0)
}

func (s *Simple_typeContext) T_INTERVAL_SECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_INTERVAL_SECOND, 0)
}

func (s *Simple_typeContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_NULL, 0)
}

func (s *Simple_typeContext) T_FIXEDSTRING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserT_FIXEDSTRING, 0)
}

func (s *Simple_typeContext) NUMERIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNUMERIC_LITERAL, 0)
}

func (s *Simple_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Simple_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSimple_type(s)
	}
}

func (s *Simple_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSimple_type(s)
	}
}




func (p *ClickHouseParser) Simple_type() (localctx ISimple_typeContext) {
	localctx = NewSimple_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ClickHouseParserRULE_simple_type)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(681)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserT_UINT8:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.Match(ClickHouseParserT_UINT8)
		}


	case ClickHouseParserT_UINT16:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.Match(ClickHouseParserT_UINT16)
		}


	case ClickHouseParserT_UINT32:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(633)
			p.Match(ClickHouseParserT_UINT32)
		}


	case ClickHouseParserT_UINT64:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(634)
			p.Match(ClickHouseParserT_UINT64)
		}


	case ClickHouseParserT_INT8:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(635)
			p.Match(ClickHouseParserT_INT8)
		}


	case ClickHouseParserT_INT16:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(636)
			p.Match(ClickHouseParserT_INT16)
		}


	case ClickHouseParserT_INT32:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(637)
			p.Match(ClickHouseParserT_INT32)
		}


	case ClickHouseParserT_INT64:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(638)
			p.Match(ClickHouseParserT_INT64)
		}


	case ClickHouseParserT_FLOAT32:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(639)
			p.Match(ClickHouseParserT_FLOAT32)
		}


	case ClickHouseParserT_FLOAT64:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(640)
			p.Match(ClickHouseParserT_FLOAT64)
		}


	case ClickHouseParserT_ENUM8:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(641)
			p.Match(ClickHouseParserT_ENUM8)
		}
		{
			p.SetState(642)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(643)
			p.Enum_entry()
		}
		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(644)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(645)
				p.Enum_entry()
			}


			p.SetState(650)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(651)
			p.Match(ClickHouseParserRPAREN)
		}


	case ClickHouseParserT_ENUM16:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(653)
			p.Match(ClickHouseParserT_ENUM16)
		}
		{
			p.SetState(654)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(655)
			p.Enum_entry()
		}
		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(656)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(657)
				p.Enum_entry()
			}


			p.SetState(662)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(663)
			p.Match(ClickHouseParserRPAREN)
		}


	case ClickHouseParserT_UUID:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(665)
			p.Match(ClickHouseParserT_UUID)
		}


	case ClickHouseParserT_DATE:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(666)
			p.Match(ClickHouseParserT_DATE)
		}


	case ClickHouseParserT_DATETIME:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(667)
			p.Match(ClickHouseParserT_DATETIME)
		}


	case ClickHouseParserT_STRING:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(668)
			p.Match(ClickHouseParserT_STRING)
		}


	case ClickHouseParserT_INTERVAL_YEAR:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(669)
			p.Match(ClickHouseParserT_INTERVAL_YEAR)
		}


	case ClickHouseParserT_INTERVAL_MONTH:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(670)
			p.Match(ClickHouseParserT_INTERVAL_MONTH)
		}


	case ClickHouseParserT_INTERVAL_WEEK:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(671)
			p.Match(ClickHouseParserT_INTERVAL_WEEK)
		}


	case ClickHouseParserT_INTERVAL_DAY:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(672)
			p.Match(ClickHouseParserT_INTERVAL_DAY)
		}


	case ClickHouseParserT_INTERVAL_HOUR:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(673)
			p.Match(ClickHouseParserT_INTERVAL_HOUR)
		}


	case ClickHouseParserT_INTERVAL_MINUTE:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(674)
			p.Match(ClickHouseParserT_INTERVAL_MINUTE)
		}


	case ClickHouseParserT_INTERVAL_SECOND:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(675)
			p.Match(ClickHouseParserT_INTERVAL_SECOND)
		}


	case ClickHouseParserT_NULL:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(676)
			p.Match(ClickHouseParserT_NULL)
		}


	case ClickHouseParserT_FIXEDSTRING:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(677)
			p.Match(ClickHouseParserT_FIXEDSTRING)
		}
		{
			p.SetState(678)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(679)
			p.Match(ClickHouseParserNUMERIC_LITERAL)
		}
		{
			p.SetState(680)
			p.Match(ClickHouseParserLPAREN)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IEnum_entryContext is an interface to support dynamic dispatch.
type IEnum_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_entryContext differentiates from other interfaces.
	IsEnum_entryContext()
}

type Enum_entryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_entryContext() *Enum_entryContext {
	var p = new(Enum_entryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_enum_entry
	return p
}

func (*Enum_entryContext) IsEnum_entryContext() {}

func NewEnum_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_entryContext {
	var p = new(Enum_entryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_enum_entry

	return p
}

func (s *Enum_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_entryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Enum_entryContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASSIGN, 0)
}

func (s *Enum_entryContext) NUMERIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNUMERIC_LITERAL, 0)
}

func (s *Enum_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Enum_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterEnum_entry(s)
	}
}

func (s *Enum_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitEnum_entry(s)
	}
}




func (p *ClickHouseParser) Enum_entry() (localctx IEnum_entryContext) {
	localctx = NewEnum_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ClickHouseParserRULE_enum_entry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Match(ClickHouseParserSTRING_LITERAL)
	}
	{
		p.SetState(684)
		p.Match(ClickHouseParserASSIGN)
	}
	{
		p.SetState(685)
		p.Match(ClickHouseParserNUMERIC_LITERAL)
	}



	return localctx
}


// IUse_queryContext is an interface to support dynamic dispatch.
type IUse_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUse_queryContext differentiates from other interfaces.
	IsUse_queryContext()
}

type Use_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_queryContext() *Use_queryContext {
	var p = new(Use_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_use_query
	return p
}

func (*Use_queryContext) IsUse_queryContext() {}

func NewUse_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_queryContext {
	var p = new(Use_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_use_query

	return p
}

func (s *Use_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_queryContext) K_USE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_USE, 0)
}

func (s *Use_queryContext) Database_name() IDatabase_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabase_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabase_nameContext)
}

func (s *Use_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Use_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterUse_query(s)
	}
}

func (s *Use_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitUse_query(s)
	}
}




func (p *ClickHouseParser) Use_query() (localctx IUse_queryContext) {
	localctx = NewUse_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ClickHouseParserRULE_use_query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(687)
		p.Match(ClickHouseParserK_USE)
	}
	{
		p.SetState(688)
		p.Database_name()
	}



	return localctx
}


// ISet_queryContext is an interface to support dynamic dispatch.
type ISet_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_queryContext differentiates from other interfaces.
	IsSet_queryContext()
}

type Set_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_queryContext() *Set_queryContext {
	var p = new(Set_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_set_query
	return p
}

func (*Set_queryContext) IsSet_queryContext() {}

func NewSet_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_queryContext {
	var p = new(Set_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_set_query

	return p
}

func (s *Set_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_queryContext) K_SET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SET, 0)
}

func (s *Set_queryContext) Assignment_list() IAssignment_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_listContext)
}

func (s *Set_queryContext) K_GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_GLOBAL, 0)
}

func (s *Set_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSet_query(s)
	}
}

func (s *Set_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSet_query(s)
	}
}




func (p *ClickHouseParser) Set_query() (localctx ISet_queryContext) {
	localctx = NewSet_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ClickHouseParserRULE_set_query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(ClickHouseParserK_SET)
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(691)
			p.Match(ClickHouseParserK_GLOBAL)
		}


	}
	{
		p.SetState(694)
		p.Assignment_list()
	}



	return localctx
}


// IAssignment_listContext is an interface to support dynamic dispatch.
type IAssignment_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_listContext differentiates from other interfaces.
	IsAssignment_listContext()
}

type Assignment_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_listContext() *Assignment_listContext {
	var p = new(Assignment_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignment_list
	return p
}

func (*Assignment_listContext) IsAssignment_listContext() {}

func NewAssignment_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_listContext {
	var p = new(Assignment_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_assignment_list

	return p
}

func (s *Assignment_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_listContext) AllAssignment() []IAssignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentContext)(nil)).Elem())
	var tst = make([]IAssignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentContext)
		}
	}

	return tst
}

func (s *Assignment_listContext) Assignment(i int) IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *Assignment_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Assignment_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Assignment_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAssignment_list(s)
	}
}

func (s *Assignment_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAssignment_list(s)
	}
}




func (p *ClickHouseParser) Assignment_list() (localctx IAssignment_listContext) {
	localctx = NewAssignment_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ClickHouseParserRULE_assignment_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.Assignment()
	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(697)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(698)
			p.Assignment()
		}


		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASSIGN, 0)
}

func (s *AssignmentContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}




func (p *ClickHouseParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ClickHouseParserRULE_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Identifier()
	}
	{
		p.SetState(705)
		p.Match(ClickHouseParserASSIGN)
	}
	{
		p.SetState(706)
		p.Literal()
	}



	return localctx
}


// IKill_query_queryContext is an interface to support dynamic dispatch.
type IKill_query_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKill_query_queryContext differentiates from other interfaces.
	IsKill_query_queryContext()
}

type Kill_query_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKill_query_queryContext() *Kill_query_queryContext {
	var p = new(Kill_query_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_kill_query_query
	return p
}

func (*Kill_query_queryContext) IsKill_query_queryContext() {}

func NewKill_query_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Kill_query_queryContext {
	var p = new(Kill_query_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_kill_query_query

	return p
}

func (s *Kill_query_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Kill_query_queryContext) K_KILL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_KILL, 0)
}

func (s *Kill_query_queryContext) K_QUERY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_QUERY, 0)
}

func (s *Kill_query_queryContext) K_WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_WHERE, 0)
}

func (s *Kill_query_queryContext) Expression_with_optional_alias() IExpression_with_optional_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_with_optional_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_with_optional_aliasContext)
}

func (s *Kill_query_queryContext) K_SYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SYNC, 0)
}

func (s *Kill_query_queryContext) K_ASYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ASYNC, 0)
}

func (s *Kill_query_queryContext) K_TEST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TEST, 0)
}

func (s *Kill_query_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Kill_query_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Kill_query_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterKill_query_query(s)
	}
}

func (s *Kill_query_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitKill_query_query(s)
	}
}




func (p *ClickHouseParser) Kill_query_query() (localctx IKill_query_queryContext) {
	localctx = NewKill_query_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ClickHouseParserRULE_kill_query_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(ClickHouseParserK_KILL)
	}
	{
		p.SetState(709)
		p.Match(ClickHouseParserK_QUERY)
	}
	{
		p.SetState(710)
		p.Match(ClickHouseParserK_WHERE)
	}
	{
		p.SetState(711)
		p.Expression_with_optional_alias()
	}
	p.SetState(712)
	_la = p.GetTokenStream().LA(1)

	if !(_la == ClickHouseParserK_ASYNC || _la == ClickHouseParserK_SYNC || _la == ClickHouseParserK_TEST) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IOptimize_queryContext is an interface to support dynamic dispatch.
type IOptimize_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptimize_queryContext differentiates from other interfaces.
	IsOptimize_queryContext()
}

type Optimize_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimize_queryContext() *Optimize_queryContext {
	var p = new(Optimize_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_optimize_query
	return p
}

func (*Optimize_queryContext) IsOptimize_queryContext() {}

func NewOptimize_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Optimize_queryContext {
	var p = new(Optimize_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_optimize_query

	return p
}

func (s *Optimize_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Optimize_queryContext) K_OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OPTIMIZE, 0)
}

func (s *Optimize_queryContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLE, 0)
}

func (s *Optimize_queryContext) Full_table_name() IFull_table_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_table_nameContext)
}

func (s *Optimize_queryContext) K_PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_PARTITION, 0)
}

func (s *Optimize_queryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Optimize_queryContext) K_FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FINAL, 0)
}

func (s *Optimize_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Optimize_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Optimize_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOptimize_query(s)
	}
}

func (s *Optimize_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOptimize_query(s)
	}
}




func (p *ClickHouseParser) Optimize_query() (localctx IOptimize_queryContext) {
	localctx = NewOptimize_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ClickHouseParserRULE_optimize_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)
		p.Match(ClickHouseParserK_OPTIMIZE)
	}
	{
		p.SetState(715)
		p.Match(ClickHouseParserK_TABLE)
	}
	{
		p.SetState(716)
		p.Full_table_name()
	}
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_PARTITION {
		{
			p.SetState(717)
			p.Match(ClickHouseParserK_PARTITION)
		}
		{
			p.SetState(718)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_FINAL {
		{
			p.SetState(721)
			p.Match(ClickHouseParserK_FINAL)
		}

	}



	return localctx
}


// ITable_properties_queryContext is an interface to support dynamic dispatch.
type ITable_properties_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_properties_queryContext differentiates from other interfaces.
	IsTable_properties_queryContext()
}

type Table_properties_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_properties_queryContext() *Table_properties_queryContext {
	var p = new(Table_properties_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_table_properties_query
	return p
}

func (*Table_properties_queryContext) IsTable_properties_queryContext() {}

func NewTable_properties_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_properties_queryContext {
	var p = new(Table_properties_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_table_properties_query

	return p
}

func (s *Table_properties_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_properties_queryContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLE, 0)
}

func (s *Table_properties_queryContext) Full_table_name() IFull_table_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_table_nameContext)
}

func (s *Table_properties_queryContext) K_EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_EXISTS, 0)
}

func (s *Table_properties_queryContext) K_SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SHOW, 0)
}

func (s *Table_properties_queryContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CREATE, 0)
}

func (s *Table_properties_queryContext) K_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DESCRIBE, 0)
}

func (s *Table_properties_queryContext) K_DESC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DESC, 0)
}

func (s *Table_properties_queryContext) Query_outfile_step() IQuery_outfile_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_outfile_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_outfile_stepContext)
}

func (s *Table_properties_queryContext) K_FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FORMAT, 0)
}

func (s *Table_properties_queryContext) Format_name() IFormat_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormat_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormat_nameContext)
}

func (s *Table_properties_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_properties_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_properties_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTable_properties_query(s)
	}
}

func (s *Table_properties_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTable_properties_query(s)
	}
}




func (p *ClickHouseParser) Table_properties_query() (localctx ITable_properties_queryContext) {
	localctx = NewTable_properties_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ClickHouseParserRULE_table_properties_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(728)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserK_EXISTS:
		{
			p.SetState(724)
			p.Match(ClickHouseParserK_EXISTS)
		}


	case ClickHouseParserK_DESCRIBE, ClickHouseParserK_DESC:
		p.SetState(725)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserK_DESCRIBE || _la == ClickHouseParserK_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}


	case ClickHouseParserK_SHOW:
		{
			p.SetState(726)
			p.Match(ClickHouseParserK_SHOW)
		}
		{
			p.SetState(727)
			p.Match(ClickHouseParserK_CREATE)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(730)
		p.Match(ClickHouseParserK_TABLE)
	}
	{
		p.SetState(731)
		p.Full_table_name()
	}
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_INTO {
		{
			p.SetState(732)
			p.Query_outfile_step()
		}

	}
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_FORMAT {
		{
			p.SetState(735)
			p.Match(ClickHouseParserK_FORMAT)
		}
		{
			p.SetState(736)
			p.Format_name()
		}

	}



	return localctx
}


// IShow_tables_queryContext is an interface to support dynamic dispatch.
type IShow_tables_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShow_tables_queryContext differentiates from other interfaces.
	IsShow_tables_queryContext()
}

type Show_tables_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShow_tables_queryContext() *Show_tables_queryContext {
	var p = new(Show_tables_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_show_tables_query
	return p
}

func (*Show_tables_queryContext) IsShow_tables_queryContext() {}

func NewShow_tables_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Show_tables_queryContext {
	var p = new(Show_tables_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_show_tables_query

	return p
}

func (s *Show_tables_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Show_tables_queryContext) K_SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SHOW, 0)
}

func (s *Show_tables_queryContext) K_DATABASES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DATABASES, 0)
}

func (s *Show_tables_queryContext) K_TABLES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLES, 0)
}

func (s *Show_tables_queryContext) Query_outfile_step() IQuery_outfile_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_outfile_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_outfile_stepContext)
}

func (s *Show_tables_queryContext) K_FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FORMAT, 0)
}

func (s *Show_tables_queryContext) Format_name() IFormat_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormat_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormat_nameContext)
}

func (s *Show_tables_queryContext) K_FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FROM, 0)
}

func (s *Show_tables_queryContext) Database_name() IDatabase_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabase_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabase_nameContext)
}

func (s *Show_tables_queryContext) K_LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LIKE, 0)
}

func (s *Show_tables_queryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Show_tables_queryContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NOT, 0)
}

func (s *Show_tables_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Show_tables_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Show_tables_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShow_tables_query(s)
	}
}

func (s *Show_tables_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShow_tables_query(s)
	}
}




func (p *ClickHouseParser) Show_tables_query() (localctx IShow_tables_queryContext) {
	localctx = NewShow_tables_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ClickHouseParserRULE_show_tables_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(ClickHouseParserK_SHOW)
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserK_DATABASES:
		{
			p.SetState(740)
			p.Match(ClickHouseParserK_DATABASES)
		}


	case ClickHouseParserK_TABLES:
		{
			p.SetState(741)
			p.Match(ClickHouseParserK_TABLES)
		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_FROM {
			{
				p.SetState(742)
				p.Match(ClickHouseParserK_FROM)
			}
			{
				p.SetState(743)
				p.Database_name()
			}

		}
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ClickHouseParserK_LIKE || _la == ClickHouseParserK_NOT {
			p.SetState(747)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ClickHouseParserK_NOT {
				{
					p.SetState(746)
					p.Match(ClickHouseParserK_NOT)
				}

			}
			{
				p.SetState(749)
				p.Match(ClickHouseParserK_LIKE)
			}
			{
				p.SetState(750)
				p.Match(ClickHouseParserSTRING_LITERAL)
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_INTO {
		{
			p.SetState(755)
			p.Query_outfile_step()
		}

	}
	p.SetState(760)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_FORMAT {
		{
			p.SetState(758)
			p.Match(ClickHouseParserK_FORMAT)
		}
		{
			p.SetState(759)
			p.Format_name()
		}

	}



	return localctx
}


// IShow_processlist_queryContext is an interface to support dynamic dispatch.
type IShow_processlist_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShow_processlist_queryContext differentiates from other interfaces.
	IsShow_processlist_queryContext()
}

type Show_processlist_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShow_processlist_queryContext() *Show_processlist_queryContext {
	var p = new(Show_processlist_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_show_processlist_query
	return p
}

func (*Show_processlist_queryContext) IsShow_processlist_queryContext() {}

func NewShow_processlist_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Show_processlist_queryContext {
	var p = new(Show_processlist_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_show_processlist_query

	return p
}

func (s *Show_processlist_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Show_processlist_queryContext) K_SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SHOW, 0)
}

func (s *Show_processlist_queryContext) K_PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_PROCESSLIST, 0)
}

func (s *Show_processlist_queryContext) Query_outfile_step() IQuery_outfile_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuery_outfile_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuery_outfile_stepContext)
}

func (s *Show_processlist_queryContext) K_FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FORMAT, 0)
}

func (s *Show_processlist_queryContext) Format_name() IFormat_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormat_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormat_nameContext)
}

func (s *Show_processlist_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Show_processlist_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Show_processlist_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShow_processlist_query(s)
	}
}

func (s *Show_processlist_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShow_processlist_query(s)
	}
}




func (p *ClickHouseParser) Show_processlist_query() (localctx IShow_processlist_queryContext) {
	localctx = NewShow_processlist_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ClickHouseParserRULE_show_processlist_query)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.Match(ClickHouseParserK_SHOW)
	}
	{
		p.SetState(763)
		p.Match(ClickHouseParserK_PROCESSLIST)
	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_INTO {
		{
			p.SetState(764)
			p.Query_outfile_step()
		}

	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_FORMAT {
		{
			p.SetState(767)
			p.Match(ClickHouseParserK_FORMAT)
		}
		{
			p.SetState(768)
			p.Format_name()
		}

	}



	return localctx
}


// ICheck_queryContext is an interface to support dynamic dispatch.
type ICheck_queryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheck_queryContext differentiates from other interfaces.
	IsCheck_queryContext()
}

type Check_queryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheck_queryContext() *Check_queryContext {
	var p = new(Check_queryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_check_query
	return p
}

func (*Check_queryContext) IsCheck_queryContext() {}

func NewCheck_queryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Check_queryContext {
	var p = new(Check_queryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_check_query

	return p
}

func (s *Check_queryContext) GetParser() antlr.Parser { return s.parser }

func (s *Check_queryContext) K_CHECK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CHECK, 0)
}

func (s *Check_queryContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLE, 0)
}

func (s *Check_queryContext) Full_table_name() IFull_table_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_table_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_table_nameContext)
}

func (s *Check_queryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Check_queryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Check_queryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCheck_query(s)
	}
}

func (s *Check_queryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCheck_query(s)
	}
}




func (p *ClickHouseParser) Check_query() (localctx ICheck_queryContext) {
	localctx = NewCheck_queryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ClickHouseParserRULE_check_query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.Match(ClickHouseParserK_CHECK)
	}
	{
		p.SetState(772)
		p.Match(ClickHouseParserK_TABLE)
	}
	{
		p.SetState(773)
		p.Full_table_name()
	}



	return localctx
}


// IFull_table_nameContext is an interface to support dynamic dispatch.
type IFull_table_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFull_table_nameContext differentiates from other interfaces.
	IsFull_table_nameContext()
}

type Full_table_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_table_nameContext() *Full_table_nameContext {
	var p = new(Full_table_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_full_table_name
	return p
}

func (*Full_table_nameContext) IsFull_table_nameContext() {}

func NewFull_table_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_table_nameContext {
	var p = new(Full_table_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_full_table_name

	return p
}

func (s *Full_table_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_table_nameContext) Table_name() ITable_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Full_table_nameContext) Database_name() IDatabase_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabase_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabase_nameContext)
}

func (s *Full_table_nameContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *Full_table_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_table_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Full_table_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFull_table_name(s)
	}
}

func (s *Full_table_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFull_table_name(s)
	}
}




func (p *ClickHouseParser) Full_table_name() (localctx IFull_table_nameContext) {
	localctx = NewFull_table_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ClickHouseParserRULE_full_table_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(778)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(775)
			p.Database_name()
		}
		{
			p.SetState(776)
			p.Match(ClickHouseParserDOT)
		}


	}
	{
		p.SetState(780)
		p.Table_name()
	}



	return localctx
}


// IPartition_nameContext is an interface to support dynamic dispatch.
type IPartition_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartition_nameContext differentiates from other interfaces.
	IsPartition_nameContext()
}

type Partition_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_nameContext() *Partition_nameContext {
	var p = new(Partition_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_partition_name
	return p
}

func (*Partition_nameContext) IsPartition_nameContext() {}

func NewPartition_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_nameContext {
	var p = new(Partition_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_partition_name

	return p
}

func (s *Partition_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Partition_nameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Partition_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Partition_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPartition_name(s)
	}
}

func (s *Partition_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPartition_name(s)
	}
}




func (p *ClickHouseParser) Partition_name() (localctx IPartition_nameContext) {
	localctx = NewPartition_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ClickHouseParserRULE_partition_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(784)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserK_ADD, ClickHouseParserK_AFTER, ClickHouseParserK_ALL, ClickHouseParserK_ALIAS, ClickHouseParserK_ALTER, ClickHouseParserK_AND, ClickHouseParserK_ANY, ClickHouseParserK_ARRAY, ClickHouseParserK_AS, ClickHouseParserK_ASCENDING, ClickHouseParserK_ASC, ClickHouseParserK_ASYNC, ClickHouseParserK_ATTACH, ClickHouseParserK_BETWEEN, ClickHouseParserK_BY, ClickHouseParserK_CASE, ClickHouseParserK_CHECK, ClickHouseParserK_COLUMN, ClickHouseParserK_COLLATE, ClickHouseParserK_CREATE, ClickHouseParserK_CROSS, ClickHouseParserK_DESCRIBE, ClickHouseParserK_DESCENDING, ClickHouseParserK_DESC, ClickHouseParserK_DATABASE, ClickHouseParserK_DATABASES, ClickHouseParserK_DEFAULT, ClickHouseParserK_DETACH, ClickHouseParserK_DISTINCT, ClickHouseParserK_DROP, ClickHouseParserK_ELSE, ClickHouseParserK_END, ClickHouseParserK_ENGINE, ClickHouseParserK_EXISTS, ClickHouseParserK_FINAL, ClickHouseParserK_FIRST, ClickHouseParserK_FROM, ClickHouseParserK_FORMAT, ClickHouseParserK_FULL, ClickHouseParserK_GLOBAL, ClickHouseParserK_GROUP, ClickHouseParserK_HAVING, ClickHouseParserK_ID, ClickHouseParserK_IF, ClickHouseParserK_INNER, ClickHouseParserK_INSERT, ClickHouseParserK_INTO, ClickHouseParserK_IN, ClickHouseParserK_IS, ClickHouseParserK_JOIN, ClickHouseParserK_KILL, ClickHouseParserK_LAST, ClickHouseParserK_LEFT, ClickHouseParserK_LIKE, ClickHouseParserK_LIMIT, ClickHouseParserK_MAIN, ClickHouseParserK_MATERIALIZED, ClickHouseParserK_MODIFY, ClickHouseParserK_NOT, ClickHouseParserK_NULL, ClickHouseParserK_NULLS, ClickHouseParserK_OFFSET, ClickHouseParserK_ON, ClickHouseParserK_OPTIMIZE, ClickHouseParserK_ORDER, ClickHouseParserK_OR, ClickHouseParserK_OUTFILE, ClickHouseParserK_PARTITION, ClickHouseParserK_POPULATE, ClickHouseParserK_PREWHERE, ClickHouseParserK_PROCESSLIST, ClickHouseParserK_QUERY, ClickHouseParserK_RENAME, ClickHouseParserK_RETURN, ClickHouseParserK_RIGHT, ClickHouseParserK_SAMPLE, ClickHouseParserK_SELECT, ClickHouseParserK_SET, ClickHouseParserK_SETTINGS, ClickHouseParserK_SHOW, ClickHouseParserK_SYNC, ClickHouseParserK_TABLE, ClickHouseParserK_TABLES, ClickHouseParserK_TEMPORARY, ClickHouseParserK_TEST, ClickHouseParserK_THEN, ClickHouseParserK_TOTALS, ClickHouseParserK_TO, ClickHouseParserK_OUTER, ClickHouseParserK_VALUES, ClickHouseParserK_VIEW, ClickHouseParserK_UNION, ClickHouseParserK_USE, ClickHouseParserK_USING, ClickHouseParserK_WHEN, ClickHouseParserK_WHERE, ClickHouseParserK_WITH, ClickHouseParserT_FLOAT32, ClickHouseParserT_FLOAT64, ClickHouseParserT_UINT8, ClickHouseParserT_UINT16, ClickHouseParserT_UINT32, ClickHouseParserT_UINT64, ClickHouseParserT_INT8, ClickHouseParserT_INT16, ClickHouseParserT_INT32, ClickHouseParserT_INT64, ClickHouseParserT_ENUM8, ClickHouseParserT_ENUM16, ClickHouseParserT_UUID, ClickHouseParserT_DATE, ClickHouseParserT_DATETIME, ClickHouseParserT_STRING, ClickHouseParserT_FIXEDSTRING, ClickHouseParserT_NULL, ClickHouseParserT_INTERVAL_YEAR, ClickHouseParserT_INTERVAL_MONTH, ClickHouseParserT_INTERVAL_WEEK, ClickHouseParserT_INTERVAL_DAY, ClickHouseParserT_INTERVAL_HOUR, ClickHouseParserT_INTERVAL_MINUTE, ClickHouseParserT_INTERVAL_SECOND, ClickHouseParserIDENTIFIER, ClickHouseParserQUOTED_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(782)
			p.Identifier()
		}


	case ClickHouseParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(783)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ICluster_nameContext is an interface to support dynamic dispatch.
type ICluster_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCluster_nameContext differentiates from other interfaces.
	IsCluster_nameContext()
}

type Cluster_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCluster_nameContext() *Cluster_nameContext {
	var p = new(Cluster_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_cluster_name
	return p
}

func (*Cluster_nameContext) IsCluster_nameContext() {}

func NewCluster_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cluster_nameContext {
	var p = new(Cluster_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_cluster_name

	return p
}

func (s *Cluster_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Cluster_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cluster_nameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Cluster_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cluster_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cluster_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCluster_name(s)
	}
}

func (s *Cluster_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCluster_name(s)
	}
}




func (p *ClickHouseParser) Cluster_name() (localctx ICluster_nameContext) {
	localctx = NewCluster_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ClickHouseParserRULE_cluster_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(788)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserK_ADD, ClickHouseParserK_AFTER, ClickHouseParserK_ALL, ClickHouseParserK_ALIAS, ClickHouseParserK_ALTER, ClickHouseParserK_AND, ClickHouseParserK_ANY, ClickHouseParserK_ARRAY, ClickHouseParserK_AS, ClickHouseParserK_ASCENDING, ClickHouseParserK_ASC, ClickHouseParserK_ASYNC, ClickHouseParserK_ATTACH, ClickHouseParserK_BETWEEN, ClickHouseParserK_BY, ClickHouseParserK_CASE, ClickHouseParserK_CHECK, ClickHouseParserK_COLUMN, ClickHouseParserK_COLLATE, ClickHouseParserK_CREATE, ClickHouseParserK_CROSS, ClickHouseParserK_DESCRIBE, ClickHouseParserK_DESCENDING, ClickHouseParserK_DESC, ClickHouseParserK_DATABASE, ClickHouseParserK_DATABASES, ClickHouseParserK_DEFAULT, ClickHouseParserK_DETACH, ClickHouseParserK_DISTINCT, ClickHouseParserK_DROP, ClickHouseParserK_ELSE, ClickHouseParserK_END, ClickHouseParserK_ENGINE, ClickHouseParserK_EXISTS, ClickHouseParserK_FINAL, ClickHouseParserK_FIRST, ClickHouseParserK_FROM, ClickHouseParserK_FORMAT, ClickHouseParserK_FULL, ClickHouseParserK_GLOBAL, ClickHouseParserK_GROUP, ClickHouseParserK_HAVING, ClickHouseParserK_ID, ClickHouseParserK_IF, ClickHouseParserK_INNER, ClickHouseParserK_INSERT, ClickHouseParserK_INTO, ClickHouseParserK_IN, ClickHouseParserK_IS, ClickHouseParserK_JOIN, ClickHouseParserK_KILL, ClickHouseParserK_LAST, ClickHouseParserK_LEFT, ClickHouseParserK_LIKE, ClickHouseParserK_LIMIT, ClickHouseParserK_MAIN, ClickHouseParserK_MATERIALIZED, ClickHouseParserK_MODIFY, ClickHouseParserK_NOT, ClickHouseParserK_NULL, ClickHouseParserK_NULLS, ClickHouseParserK_OFFSET, ClickHouseParserK_ON, ClickHouseParserK_OPTIMIZE, ClickHouseParserK_ORDER, ClickHouseParserK_OR, ClickHouseParserK_OUTFILE, ClickHouseParserK_PARTITION, ClickHouseParserK_POPULATE, ClickHouseParserK_PREWHERE, ClickHouseParserK_PROCESSLIST, ClickHouseParserK_QUERY, ClickHouseParserK_RENAME, ClickHouseParserK_RETURN, ClickHouseParserK_RIGHT, ClickHouseParserK_SAMPLE, ClickHouseParserK_SELECT, ClickHouseParserK_SET, ClickHouseParserK_SETTINGS, ClickHouseParserK_SHOW, ClickHouseParserK_SYNC, ClickHouseParserK_TABLE, ClickHouseParserK_TABLES, ClickHouseParserK_TEMPORARY, ClickHouseParserK_TEST, ClickHouseParserK_THEN, ClickHouseParserK_TOTALS, ClickHouseParserK_TO, ClickHouseParserK_OUTER, ClickHouseParserK_VALUES, ClickHouseParserK_VIEW, ClickHouseParserK_UNION, ClickHouseParserK_USE, ClickHouseParserK_USING, ClickHouseParserK_WHEN, ClickHouseParserK_WHERE, ClickHouseParserK_WITH, ClickHouseParserT_FLOAT32, ClickHouseParserT_FLOAT64, ClickHouseParserT_UINT8, ClickHouseParserT_UINT16, ClickHouseParserT_UINT32, ClickHouseParserT_UINT64, ClickHouseParserT_INT8, ClickHouseParserT_INT16, ClickHouseParserT_INT32, ClickHouseParserT_INT64, ClickHouseParserT_ENUM8, ClickHouseParserT_ENUM16, ClickHouseParserT_UUID, ClickHouseParserT_DATE, ClickHouseParserT_DATETIME, ClickHouseParserT_STRING, ClickHouseParserT_FIXEDSTRING, ClickHouseParserT_NULL, ClickHouseParserT_INTERVAL_YEAR, ClickHouseParserT_INTERVAL_MONTH, ClickHouseParserT_INTERVAL_WEEK, ClickHouseParserT_INTERVAL_DAY, ClickHouseParserT_INTERVAL_HOUR, ClickHouseParserT_INTERVAL_MINUTE, ClickHouseParserT_INTERVAL_SECOND, ClickHouseParserIDENTIFIER, ClickHouseParserQUOTED_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(786)
			p.Identifier()
		}


	case ClickHouseParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(787)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IDatabase_nameContext is an interface to support dynamic dispatch.
type IDatabase_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabase_nameContext differentiates from other interfaces.
	IsDatabase_nameContext()
}

type Database_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabase_nameContext() *Database_nameContext {
	var p = new(Database_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_database_name
	return p
}

func (*Database_nameContext) IsDatabase_nameContext() {}

func NewDatabase_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Database_nameContext {
	var p = new(Database_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_database_name

	return p
}

func (s *Database_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Database_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Database_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Database_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Database_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDatabase_name(s)
	}
}

func (s *Database_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDatabase_name(s)
	}
}




func (p *ClickHouseParser) Database_name() (localctx IDatabase_nameContext) {
	localctx = NewDatabase_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ClickHouseParserRULE_database_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.Identifier()
	}



	return localctx
}


// ITable_nameContext is an interface to support dynamic dispatch.
type ITable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_nameContext differentiates from other interfaces.
	IsTable_nameContext()
}

type Table_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_nameContext() *Table_nameContext {
	var p = new(Table_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_table_name
	return p
}

func (*Table_nameContext) IsTable_nameContext() {}

func NewTable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_nameContext {
	var p = new(Table_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_table_name

	return p
}

func (s *Table_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Table_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTable_name(s)
	}
}

func (s *Table_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTable_name(s)
	}
}




func (p *ClickHouseParser) Table_name() (localctx ITable_nameContext) {
	localctx = NewTable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ClickHouseParserRULE_table_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Identifier()
	}



	return localctx
}


// IFormat_nameContext is an interface to support dynamic dispatch.
type IFormat_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormat_nameContext differentiates from other interfaces.
	IsFormat_nameContext()
}

type Format_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormat_nameContext() *Format_nameContext {
	var p = new(Format_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_format_name
	return p
}

func (*Format_nameContext) IsFormat_nameContext() {}

func NewFormat_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Format_nameContext {
	var p = new(Format_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_format_name

	return p
}

func (s *Format_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Format_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Format_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Format_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Format_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFormat_name(s)
	}
}

func (s *Format_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFormat_name(s)
	}
}




func (p *ClickHouseParser) Format_name() (localctx IFormat_nameContext) {
	localctx = NewFormat_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ClickHouseParserRULE_format_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(794)
		p.Identifier()
	}



	return localctx
}


// IQuery_outfile_stepContext is an interface to support dynamic dispatch.
type IQuery_outfile_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuery_outfile_stepContext differentiates from other interfaces.
	IsQuery_outfile_stepContext()
}

type Query_outfile_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_outfile_stepContext() *Query_outfile_stepContext {
	var p = new(Query_outfile_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_query_outfile_step
	return p
}

func (*Query_outfile_stepContext) IsQuery_outfile_stepContext() {}

func NewQuery_outfile_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_outfile_stepContext {
	var p = new(Query_outfile_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_query_outfile_step

	return p
}

func (s *Query_outfile_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_outfile_stepContext) K_INTO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_INTO, 0)
}

func (s *Query_outfile_stepContext) K_OUTFILE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OUTFILE, 0)
}

func (s *Query_outfile_stepContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Query_outfile_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_outfile_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Query_outfile_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterQuery_outfile_step(s)
	}
}

func (s *Query_outfile_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitQuery_outfile_step(s)
	}
}




func (p *ClickHouseParser) Query_outfile_step() (localctx IQuery_outfile_stepContext) {
	localctx = NewQuery_outfile_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ClickHouseParserRULE_query_outfile_step)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Match(ClickHouseParserK_INTO)
	}
	{
		p.SetState(797)
		p.Match(ClickHouseParserK_OUTFILE)
	}
	{
		p.SetState(798)
		p.Match(ClickHouseParserSTRING_LITERAL)
	}



	return localctx
}


// IEngineContext is an interface to support dynamic dispatch.
type IEngineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEngineContext differentiates from other interfaces.
	IsEngineContext()
}

type EngineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineContext() *EngineContext {
	var p = new(EngineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_engine
	return p
}

func (*EngineContext) IsEngineContext() {}

func NewEngineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineContext {
	var p = new(EngineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_engine

	return p
}

func (s *EngineContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineContext) K_ENGINE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ENGINE, 0)
}

func (s *EngineContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASSIGN, 0)
}

func (s *EngineContext) Identifier_with_optional_parameters() IIdentifier_with_optional_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_with_optional_parametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_with_optional_parametersContext)
}

func (s *EngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterEngine(s)
	}
}

func (s *EngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitEngine(s)
	}
}




func (p *ClickHouseParser) Engine() (localctx IEngineContext) {
	localctx = NewEngineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ClickHouseParserRULE_engine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Match(ClickHouseParserK_ENGINE)
	}
	{
		p.SetState(801)
		p.Match(ClickHouseParserASSIGN)
	}
	{
		p.SetState(802)
		p.Identifier_with_optional_parameters()
	}



	return localctx
}


// IIdentifier_with_optional_parametersContext is an interface to support dynamic dispatch.
type IIdentifier_with_optional_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifier_with_optional_parametersContext differentiates from other interfaces.
	IsIdentifier_with_optional_parametersContext()
}

type Identifier_with_optional_parametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_with_optional_parametersContext() *Identifier_with_optional_parametersContext {
	var p = new(Identifier_with_optional_parametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_identifier_with_optional_parameters
	return p
}

func (*Identifier_with_optional_parametersContext) IsIdentifier_with_optional_parametersContext() {}

func NewIdentifier_with_optional_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_with_optional_parametersContext {
	var p = new(Identifier_with_optional_parametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_identifier_with_optional_parameters

	return p
}

func (s *Identifier_with_optional_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_with_optional_parametersContext) Identifier_with_parameters() IIdentifier_with_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_with_parametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_with_parametersContext)
}

func (s *Identifier_with_optional_parametersContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Identifier_with_optional_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_with_optional_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Identifier_with_optional_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterIdentifier_with_optional_parameters(s)
	}
}

func (s *Identifier_with_optional_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitIdentifier_with_optional_parameters(s)
	}
}




func (p *ClickHouseParser) Identifier_with_optional_parameters() (localctx IIdentifier_with_optional_parametersContext) {
	localctx = NewIdentifier_with_optional_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ClickHouseParserRULE_identifier_with_optional_parameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(804)
			p.Identifier_with_parameters()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(805)
			p.Identifier()
		}

	}


	return localctx
}


// IIdentifier_with_parametersContext is an interface to support dynamic dispatch.
type IIdentifier_with_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifier_with_parametersContext differentiates from other interfaces.
	IsIdentifier_with_parametersContext()
}

type Identifier_with_parametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_with_parametersContext() *Identifier_with_parametersContext {
	var p = new(Identifier_with_parametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_identifier_with_parameters
	return p
}

func (*Identifier_with_parametersContext) IsIdentifier_with_parametersContext() {}

func NewIdentifier_with_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_with_parametersContext {
	var p = new(Identifier_with_parametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_identifier_with_parameters

	return p
}

func (s *Identifier_with_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_with_parametersContext) Function() IFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}

func (s *Identifier_with_parametersContext) Nested_table() INested_tableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_tableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_tableContext)
}

func (s *Identifier_with_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_with_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Identifier_with_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterIdentifier_with_parameters(s)
	}
}

func (s *Identifier_with_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitIdentifier_with_parameters(s)
	}
}




func (p *ClickHouseParser) Identifier_with_parameters() (localctx IIdentifier_with_parametersContext) {
	localctx = NewIdentifier_with_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ClickHouseParserRULE_identifier_with_parameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(808)
			p.Function()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(809)
			p.Nested_table()
		}

	}


	return localctx
}


// IOrder_by_expression_listContext is an interface to support dynamic dispatch.
type IOrder_by_expression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrder_by_expression_listContext differentiates from other interfaces.
	IsOrder_by_expression_listContext()
}

type Order_by_expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_expression_listContext() *Order_by_expression_listContext {
	var p = new(Order_by_expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_order_by_expression_list
	return p
}

func (*Order_by_expression_listContext) IsOrder_by_expression_listContext() {}

func NewOrder_by_expression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_expression_listContext {
	var p = new(Order_by_expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_order_by_expression_list

	return p
}

func (s *Order_by_expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_expression_listContext) AllOrder_by_element() []IOrder_by_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrder_by_elementContext)(nil)).Elem())
	var tst = make([]IOrder_by_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrder_by_elementContext)
		}
	}

	return tst
}

func (s *Order_by_expression_listContext) Order_by_element(i int) IOrder_by_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_by_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrder_by_elementContext)
}

func (s *Order_by_expression_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Order_by_expression_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Order_by_expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Order_by_expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOrder_by_expression_list(s)
	}
}

func (s *Order_by_expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOrder_by_expression_list(s)
	}
}




func (p *ClickHouseParser) Order_by_expression_list() (localctx IOrder_by_expression_listContext) {
	localctx = NewOrder_by_expression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ClickHouseParserRULE_order_by_expression_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.Order_by_element()
	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(813)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(814)
			p.Order_by_element()
		}


		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IOrder_by_elementContext is an interface to support dynamic dispatch.
type IOrder_by_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrder_by_elementContext differentiates from other interfaces.
	IsOrder_by_elementContext()
}

type Order_by_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_elementContext() *Order_by_elementContext {
	var p = new(Order_by_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_order_by_element
	return p
}

func (*Order_by_elementContext) IsOrder_by_elementContext() {}

func NewOrder_by_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_elementContext {
	var p = new(Order_by_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_order_by_element

	return p
}

func (s *Order_by_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_elementContext) Expression_with_optional_alias() IExpression_with_optional_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_with_optional_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_with_optional_aliasContext)
}

func (s *Order_by_elementContext) K_NULLS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NULLS, 0)
}

func (s *Order_by_elementContext) K_COLLATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_COLLATE, 0)
}

func (s *Order_by_elementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Order_by_elementContext) K_DESC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DESC, 0)
}

func (s *Order_by_elementContext) K_DESCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DESCENDING, 0)
}

func (s *Order_by_elementContext) K_ASC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ASC, 0)
}

func (s *Order_by_elementContext) K_ASCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ASCENDING, 0)
}

func (s *Order_by_elementContext) K_FIRST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FIRST, 0)
}

func (s *Order_by_elementContext) K_LAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LAST, 0)
}

func (s *Order_by_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Order_by_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOrder_by_element(s)
	}
}

func (s *Order_by_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOrder_by_element(s)
	}
}




func (p *ClickHouseParser) Order_by_element() (localctx IOrder_by_elementContext) {
	localctx = NewOrder_by_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ClickHouseParserRULE_order_by_element)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Expression_with_optional_alias()
	}
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ClickHouseParserK_ASCENDING) | (1 << ClickHouseParserK_ASC) | (1 << ClickHouseParserK_DESCENDING) | (1 << ClickHouseParserK_DESC))) != 0) {
		p.SetState(821)
		_la = p.GetTokenStream().LA(1)

		if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ClickHouseParserK_ASCENDING) | (1 << ClickHouseParserK_ASC) | (1 << ClickHouseParserK_DESCENDING) | (1 << ClickHouseParserK_DESC))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_NULLS {
		{
			p.SetState(824)
			p.Match(ClickHouseParserK_NULLS)
		}
		p.SetState(825)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserK_FIRST || _la == ClickHouseParserK_LAST) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_COLLATE {
		{
			p.SetState(828)
			p.Match(ClickHouseParserK_COLLATE)
		}
		{
			p.SetState(829)
			p.Match(ClickHouseParserSTRING_LITERAL)
		}

	}



	return localctx
}


// ITable_ttl_listContext is an interface to support dynamic dispatch.
type ITable_ttl_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_ttl_listContext differentiates from other interfaces.
	IsTable_ttl_listContext()
}

type Table_ttl_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_ttl_listContext() *Table_ttl_listContext {
	var p = new(Table_ttl_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_table_ttl_list
	return p
}

func (*Table_ttl_listContext) IsTable_ttl_listContext() {}

func NewTable_ttl_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_ttl_listContext {
	var p = new(Table_ttl_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_table_ttl_list

	return p
}

func (s *Table_ttl_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_ttl_listContext) K_TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TTL, 0)
}

func (s *Table_ttl_listContext) AllTable_ttl_declaration() []ITable_ttl_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_ttl_declarationContext)(nil)).Elem())
	var tst = make([]ITable_ttl_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_ttl_declarationContext)
		}
	}

	return tst
}

func (s *Table_ttl_listContext) Table_ttl_declaration(i int) ITable_ttl_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_ttl_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_ttl_declarationContext)
}

func (s *Table_ttl_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Table_ttl_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Table_ttl_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_ttl_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_ttl_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTable_ttl_list(s)
	}
}

func (s *Table_ttl_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTable_ttl_list(s)
	}
}




func (p *ClickHouseParser) Table_ttl_list() (localctx ITable_ttl_listContext) {
	localctx = NewTable_ttl_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ClickHouseParserRULE_table_ttl_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.Match(ClickHouseParserK_TTL)
	}
	{
		p.SetState(833)
		p.Table_ttl_declaration()
	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(834)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(835)
			p.Table_ttl_declaration()
		}


		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IPartition_by_elementContext is an interface to support dynamic dispatch.
type IPartition_by_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionExpr returns the partitionExpr rule contexts.
	GetPartitionExpr() IExprContext


	// SetPartitionExpr sets the partitionExpr rule contexts.
	SetPartitionExpr(IExprContext)


	// IsPartition_by_elementContext differentiates from other interfaces.
	IsPartition_by_elementContext()
}

type Partition_by_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	partitionExpr IExprContext 
}

func NewEmptyPartition_by_elementContext() *Partition_by_elementContext {
	var p = new(Partition_by_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_partition_by_element
	return p
}

func (*Partition_by_elementContext) IsPartition_by_elementContext() {}

func NewPartition_by_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_by_elementContext {
	var p = new(Partition_by_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_partition_by_element

	return p
}

func (s *Partition_by_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_by_elementContext) GetPartitionExpr() IExprContext { return s.partitionExpr }


func (s *Partition_by_elementContext) SetPartitionExpr(v IExprContext) { s.partitionExpr = v }


func (s *Partition_by_elementContext) K_PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_PARTITION, 0)
}

func (s *Partition_by_elementContext) K_BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_BY, 0)
}

func (s *Partition_by_elementContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Partition_by_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_by_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Partition_by_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPartition_by_element(s)
	}
}

func (s *Partition_by_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPartition_by_element(s)
	}
}




func (p *ClickHouseParser) Partition_by_element() (localctx IPartition_by_elementContext) {
	localctx = NewPartition_by_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ClickHouseParserRULE_partition_by_element)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_PARTITION {
		{
			p.SetState(841)
			p.Match(ClickHouseParserK_PARTITION)
		}
		{
			p.SetState(842)
			p.Match(ClickHouseParserK_BY)
		}
		{
			p.SetState(843)

			var _x = p.expr(0)

			localctx.(*Partition_by_elementContext).partitionExpr = _x
		}

	}



	return localctx
}


// ITable_ttl_declarationContext is an interface to support dynamic dispatch.
type ITable_ttl_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDiskVal returns the diskVal token.
	GetDiskVal() antlr.Token 

	// GetVolumeVal returns the volumeVal token.
	GetVolumeVal() antlr.Token 


	// SetDiskVal sets the diskVal token.
	SetDiskVal(antlr.Token) 

	// SetVolumeVal sets the volumeVal token.
	SetVolumeVal(antlr.Token) 


	// GetTtlExpr returns the ttlExpr rule contexts.
	GetTtlExpr() IExprContext


	// SetTtlExpr sets the ttlExpr rule contexts.
	SetTtlExpr(IExprContext)


	// IsTable_ttl_declarationContext differentiates from other interfaces.
	IsTable_ttl_declarationContext()
}

type Table_ttl_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	ttlExpr IExprContext 
	diskVal antlr.Token
	volumeVal antlr.Token
}

func NewEmptyTable_ttl_declarationContext() *Table_ttl_declarationContext {
	var p = new(Table_ttl_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_table_ttl_declaration
	return p
}

func (*Table_ttl_declarationContext) IsTable_ttl_declarationContext() {}

func NewTable_ttl_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_ttl_declarationContext {
	var p = new(Table_ttl_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_table_ttl_declaration

	return p
}

func (s *Table_ttl_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_ttl_declarationContext) GetDiskVal() antlr.Token { return s.diskVal }

func (s *Table_ttl_declarationContext) GetVolumeVal() antlr.Token { return s.volumeVal }


func (s *Table_ttl_declarationContext) SetDiskVal(v antlr.Token) { s.diskVal = v }

func (s *Table_ttl_declarationContext) SetVolumeVal(v antlr.Token) { s.volumeVal = v }


func (s *Table_ttl_declarationContext) GetTtlExpr() IExprContext { return s.ttlExpr }


func (s *Table_ttl_declarationContext) SetTtlExpr(v IExprContext) { s.ttlExpr = v }


func (s *Table_ttl_declarationContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Table_ttl_declarationContext) K_DELETE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DELETE, 0)
}

func (s *Table_ttl_declarationContext) K_TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TO, 0)
}

func (s *Table_ttl_declarationContext) K_DISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DISK, 0)
}

func (s *Table_ttl_declarationContext) K_VOLUME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_VOLUME, 0)
}

func (s *Table_ttl_declarationContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *Table_ttl_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_ttl_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_ttl_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTable_ttl_declaration(s)
	}
}

func (s *Table_ttl_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTable_ttl_declaration(s)
	}
}




func (p *ClickHouseParser) Table_ttl_declaration() (localctx ITable_ttl_declarationContext) {
	localctx = NewTable_ttl_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ClickHouseParserRULE_table_ttl_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)

		var _x = p.expr(0)

		localctx.(*Table_ttl_declarationContext).ttlExpr = _x
	}
	p.SetState(854)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(847)
			p.Match(ClickHouseParserK_DELETE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(848)
			p.Match(ClickHouseParserK_TO)
		}
		{
			p.SetState(849)
			p.Match(ClickHouseParserK_DISK)
		}
		{
			p.SetState(850)

			var _m = p.Match(ClickHouseParserSTRING_LITERAL)

			localctx.(*Table_ttl_declarationContext).diskVal = _m
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(851)
			p.Match(ClickHouseParserK_TO)
		}
		{
			p.SetState(852)
			p.Match(ClickHouseParserK_VOLUME)
		}
		{
			p.SetState(853)

			var _m = p.Match(ClickHouseParserSTRING_LITERAL)

			localctx.(*Table_ttl_declarationContext).volumeVal = _m
		}


	}



	return localctx
}


// INested_tableContext is an interface to support dynamic dispatch.
type INested_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNested_tableContext differentiates from other interfaces.
	IsNested_tableContext()
}

type Nested_tableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNested_tableContext() *Nested_tableContext {
	var p = new(Nested_tableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_nested_table
	return p
}

func (*Nested_tableContext) IsNested_tableContext() {}

func NewNested_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nested_tableContext {
	var p = new(Nested_tableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_nested_table

	return p
}

func (s *Nested_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Nested_tableContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Nested_tableContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *Nested_tableContext) Name_type_pair_list() IName_type_pair_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_type_pair_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_type_pair_listContext)
}

func (s *Nested_tableContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *Nested_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nested_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Nested_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterNested_table(s)
	}
}

func (s *Nested_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitNested_table(s)
	}
}




func (p *ClickHouseParser) Nested_table() (localctx INested_tableContext) {
	localctx = NewNested_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ClickHouseParserRULE_nested_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.Identifier()
	}
	{
		p.SetState(857)
		p.Match(ClickHouseParserLPAREN)
	}
	{
		p.SetState(858)
		p.Name_type_pair_list()
	}
	{
		p.SetState(859)
		p.Match(ClickHouseParserRPAREN)
	}



	return localctx
}


// IName_type_pair_listContext is an interface to support dynamic dispatch.
type IName_type_pair_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_type_pair_listContext differentiates from other interfaces.
	IsName_type_pair_listContext()
}

type Name_type_pair_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_type_pair_listContext() *Name_type_pair_listContext {
	var p = new(Name_type_pair_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_name_type_pair_list
	return p
}

func (*Name_type_pair_listContext) IsName_type_pair_listContext() {}

func NewName_type_pair_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_type_pair_listContext {
	var p = new(Name_type_pair_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_name_type_pair_list

	return p
}

func (s *Name_type_pair_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_type_pair_listContext) AllName_type_pair() []IName_type_pairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_type_pairContext)(nil)).Elem())
	var tst = make([]IName_type_pairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_type_pairContext)
		}
	}

	return tst
}

func (s *Name_type_pair_listContext) Name_type_pair(i int) IName_type_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_type_pairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_type_pairContext)
}

func (s *Name_type_pair_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Name_type_pair_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Name_type_pair_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_type_pair_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Name_type_pair_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterName_type_pair_list(s)
	}
}

func (s *Name_type_pair_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitName_type_pair_list(s)
	}
}




func (p *ClickHouseParser) Name_type_pair_list() (localctx IName_type_pair_listContext) {
	localctx = NewName_type_pair_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ClickHouseParserRULE_name_type_pair_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.Name_type_pair()
	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(862)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(863)
			p.Name_type_pair()
		}


		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IName_type_pairContext is an interface to support dynamic dispatch.
type IName_type_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_type_pairContext differentiates from other interfaces.
	IsName_type_pairContext()
}

type Name_type_pairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_type_pairContext() *Name_type_pairContext {
	var p = new(Name_type_pairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_name_type_pair
	return p
}

func (*Name_type_pairContext) IsName_type_pairContext() {}

func NewName_type_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_type_pairContext {
	var p = new(Name_type_pairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_name_type_pair

	return p
}

func (s *Name_type_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_type_pairContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Name_type_pairContext) Column_type() IColumn_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_typeContext)
}

func (s *Name_type_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_type_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Name_type_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterName_type_pair(s)
	}
}

func (s *Name_type_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitName_type_pair(s)
	}
}




func (p *ClickHouseParser) Name_type_pair() (localctx IName_type_pairContext) {
	localctx = NewName_type_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ClickHouseParserRULE_name_type_pair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.Identifier()
	}
	{
		p.SetState(870)
		p.Column_type()
	}



	return localctx
}


// ICompound_name_type_pairContext is an interface to support dynamic dispatch.
type ICompound_name_type_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_name_type_pairContext differentiates from other interfaces.
	IsCompound_name_type_pairContext()
}

type Compound_name_type_pairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_name_type_pairContext() *Compound_name_type_pairContext {
	var p = new(Compound_name_type_pairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_compound_name_type_pair
	return p
}

func (*Compound_name_type_pairContext) IsCompound_name_type_pairContext() {}

func NewCompound_name_type_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_name_type_pairContext {
	var p = new(Compound_name_type_pairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_compound_name_type_pair

	return p
}

func (s *Compound_name_type_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_name_type_pairContext) Compound_identifier() ICompound_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_identifierContext)
}

func (s *Compound_name_type_pairContext) Column_type() IColumn_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_typeContext)
}

func (s *Compound_name_type_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_name_type_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Compound_name_type_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCompound_name_type_pair(s)
	}
}

func (s *Compound_name_type_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCompound_name_type_pair(s)
	}
}




func (p *ClickHouseParser) Compound_name_type_pair() (localctx ICompound_name_type_pairContext) {
	localctx = NewCompound_name_type_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ClickHouseParserRULE_compound_name_type_pair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(872)
		p.Compound_identifier()
	}
	{
		p.SetState(873)
		p.Column_type()
	}



	return localctx
}


// IColumn_declaration_listContext is an interface to support dynamic dispatch.
type IColumn_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumn_declaration_listContext differentiates from other interfaces.
	IsColumn_declaration_listContext()
}

type Column_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_declaration_listContext() *Column_declaration_listContext {
	var p = new(Column_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_column_declaration_list
	return p
}

func (*Column_declaration_listContext) IsColumn_declaration_listContext() {}

func NewColumn_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_declaration_listContext {
	var p = new(Column_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_column_declaration_list

	return p
}

func (s *Column_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_declaration_listContext) AllColumn_declaration() []IColumn_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_declarationContext)(nil)).Elem())
	var tst = make([]IColumn_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_declarationContext)
		}
	}

	return tst
}

func (s *Column_declaration_listContext) Column_declaration(i int) IColumn_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_declarationContext)
}

func (s *Column_declaration_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Column_declaration_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Column_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumn_declaration_list(s)
	}
}

func (s *Column_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumn_declaration_list(s)
	}
}




func (p *ClickHouseParser) Column_declaration_list() (localctx IColumn_declaration_listContext) {
	localctx = NewColumn_declaration_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ClickHouseParserRULE_column_declaration_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Column_declaration()
	}
	p.SetState(880)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(876)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(877)
			p.Column_declaration()
		}


		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IColumn_declarationContext is an interface to support dynamic dispatch.
type IColumn_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTtlExpr returns the ttlExpr rule contexts.
	GetTtlExpr() IExprContext


	// SetTtlExpr sets the ttlExpr rule contexts.
	SetTtlExpr(IExprContext)


	// IsColumn_declarationContext differentiates from other interfaces.
	IsColumn_declarationContext()
}

type Column_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	ttlExpr IExprContext 
}

func NewEmptyColumn_declarationContext() *Column_declarationContext {
	var p = new(Column_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_column_declaration
	return p
}

func (*Column_declarationContext) IsColumn_declarationContext() {}

func NewColumn_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_declarationContext {
	var p = new(Column_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_column_declaration

	return p
}

func (s *Column_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_declarationContext) GetTtlExpr() IExprContext { return s.ttlExpr }


func (s *Column_declarationContext) SetTtlExpr(v IExprContext) { s.ttlExpr = v }


func (s *Column_declarationContext) Column_name() IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_declarationContext) Column_type() IColumn_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumn_typeContext)
}

func (s *Column_declarationContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *Column_declarationContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Column_declarationContext) K_CODEC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CODEC, 0)
}

func (s *Column_declarationContext) K_TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TTL, 0)
}

func (s *Column_declarationContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DEFAULT, 0)
}

func (s *Column_declarationContext) K_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_MATERIALIZED, 0)
}

func (s *Column_declarationContext) K_ALIAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ALIAS, 0)
}

func (s *Column_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumn_declaration(s)
	}
}

func (s *Column_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumn_declaration(s)
	}
}




func (p *ClickHouseParser) Column_declaration() (localctx IColumn_declarationContext) {
	localctx = NewColumn_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ClickHouseParserRULE_column_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.Column_name()
	}
	{
		p.SetState(884)
		p.Column_type()
	}
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_ALIAS || _la == ClickHouseParserK_DEFAULT || _la == ClickHouseParserK_MATERIALIZED {
		p.SetState(885)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserK_ALIAS || _la == ClickHouseParserK_DEFAULT || _la == ClickHouseParserK_MATERIALIZED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(886)
			p.expr(0)
		}

	}
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_CODEC {
		{
			p.SetState(889)
			p.Match(ClickHouseParserK_CODEC)
		}

		{
			p.SetState(890)
			p.expr(0)
		}


	}
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_TTL {
		{
			p.SetState(893)
			p.Match(ClickHouseParserK_TTL)
		}
		{
			p.SetState(894)

			var _x = p.expr(0)

			localctx.(*Column_declarationContext).ttlExpr = _x
		}

	}



	return localctx
}


// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_column_name
	return p
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumn_name(s)
	}
}




func (p *ClickHouseParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ClickHouseParserRULE_column_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.Identifier()
	}



	return localctx
}


// IColumn_typeContext is an interface to support dynamic dispatch.
type IColumn_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumn_typeContext differentiates from other interfaces.
	IsColumn_typeContext()
}

type Column_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_typeContext() *Column_typeContext {
	var p = new(Column_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_column_type
	return p
}

func (*Column_typeContext) IsColumn_typeContext() {}

func NewColumn_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_typeContext {
	var p = new(Column_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_column_type

	return p
}

func (s *Column_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_typeContext) Clickhouse_type() IClickhouse_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClickhouse_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClickhouse_typeContext)
}

func (s *Column_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumn_type(s)
	}
}

func (s *Column_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumn_type(s)
	}
}




func (p *ClickHouseParser) Column_type() (localctx IColumn_typeContext) {
	localctx = NewColumn_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ClickHouseParserRULE_column_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(899)
		p.Clickhouse_type()
	}



	return localctx
}


// IColumn_name_listContext is an interface to support dynamic dispatch.
type IColumn_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumn_name_listContext differentiates from other interfaces.
	IsColumn_name_listContext()
}

type Column_name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_name_listContext() *Column_name_listContext {
	var p = new(Column_name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_column_name_list
	return p
}

func (*Column_name_listContext) IsColumn_name_listContext() {}

func NewColumn_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_name_listContext {
	var p = new(Column_name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_column_name_list

	return p
}

func (s *Column_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_name_listContext) AllColumn_name() []IColumn_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem())
	var tst = make([]IColumn_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumn_nameContext)
		}
	}

	return tst
}

func (s *Column_name_listContext) Column_name(i int) IColumn_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumn_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_name_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Column_name_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Column_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumn_name_list(s)
	}
}

func (s *Column_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumn_name_list(s)
	}
}




func (p *ClickHouseParser) Column_name_list() (localctx IColumn_name_listContext) {
	localctx = NewColumn_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ClickHouseParserRULE_column_name_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(901)
		p.Column_name()
	}
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(902)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(903)
			p.Column_name()
		}


		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ISelect_expr_listContext is an interface to support dynamic dispatch.
type ISelect_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_expr_listContext differentiates from other interfaces.
	IsSelect_expr_listContext()
}

type Select_expr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_expr_listContext() *Select_expr_listContext {
	var p = new(Select_expr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_expr_list
	return p
}

func (*Select_expr_listContext) IsSelect_expr_listContext() {}

func NewSelect_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_expr_listContext {
	var p = new(Select_expr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_expr_list

	return p
}

func (s *Select_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_expr_listContext) AllSelect_expr() []ISelect_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelect_exprContext)(nil)).Elem())
	var tst = make([]ISelect_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelect_exprContext)
		}
	}

	return tst
}

func (s *Select_expr_listContext) Select_expr(i int) ISelect_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelect_exprContext)
}

func (s *Select_expr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Select_expr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Select_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_expr_list(s)
	}
}

func (s *Select_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_expr_list(s)
	}
}




func (p *ClickHouseParser) Select_expr_list() (localctx ISelect_expr_listContext) {
	localctx = NewSelect_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ClickHouseParserRULE_select_expr_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(909)
		p.Select_expr()
	}
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(910)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(911)
			p.Select_expr()
		}


		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ISelect_exprContext is an interface to support dynamic dispatch.
type ISelect_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_exprContext differentiates from other interfaces.
	IsSelect_exprContext()
}

type Select_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_exprContext() *Select_exprContext {
	var p = new(Select_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_expr
	return p
}

func (*Select_exprContext) IsSelect_exprContext() {}

func NewSelect_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_exprContext {
	var p = new(Select_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_expr

	return p
}

func (s *Select_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_exprContext) Select_alias() ISelect_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_aliasContext)
}

func (s *Select_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_expr(s)
	}
}

func (s *Select_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_expr(s)
	}
}




func (p *ClickHouseParser) Select_expr() (localctx ISelect_exprContext) {
	localctx = NewSelect_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ClickHouseParserRULE_select_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		p.expr(0)
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(918)
			p.Select_alias()
		}


	}



	return localctx
}


// ISelect_aliasContext is an interface to support dynamic dispatch.
type ISelect_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_aliasContext differentiates from other interfaces.
	IsSelect_aliasContext()
}

type Select_aliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_aliasContext() *Select_aliasContext {
	var p = new(Select_aliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_select_alias
	return p
}

func (*Select_aliasContext) IsSelect_aliasContext() {}

func NewSelect_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_aliasContext {
	var p = new(Select_aliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_select_alias

	return p
}

func (s *Select_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_aliasContext) Alias_name() IAlias_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_nameContext)
}

func (s *Select_aliasContext) K_AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AS, 0)
}

func (s *Select_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelect_alias(s)
	}
}

func (s *Select_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelect_alias(s)
	}
}




func (p *ClickHouseParser) Select_alias() (localctx ISelect_aliasContext) {
	localctx = NewSelect_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ClickHouseParserRULE_select_alias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(922)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(921)
			p.Match(ClickHouseParserK_AS)
		}


	}
	{
		p.SetState(924)
		p.Alias_name()
	}



	return localctx
}


// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) K_AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AS, 0)
}

func (s *AliasContext) Alias_name() IAlias_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_nameContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlias(s)
	}
}




func (p *ClickHouseParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ClickHouseParserRULE_alias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.Match(ClickHouseParserK_AS)
	}
	{
		p.SetState(927)
		p.Alias_name()
	}



	return localctx
}


// IAlias_nameContext is an interface to support dynamic dispatch.
type IAlias_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlias_nameContext differentiates from other interfaces.
	IsAlias_nameContext()
}

type Alias_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_nameContext() *Alias_nameContext {
	var p = new(Alias_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alias_name
	return p
}

func (*Alias_nameContext) IsAlias_nameContext() {}

func NewAlias_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_nameContext {
	var p = new(Alias_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alias_name

	return p
}

func (s *Alias_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Alias_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alias_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlias_name(s)
	}
}

func (s *Alias_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlias_name(s)
	}
}




func (p *ClickHouseParser) Alias_name() (localctx IAlias_nameContext) {
	localctx = NewAlias_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ClickHouseParserRULE_alias_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(929)
		p.Identifier()
	}



	return localctx
}


// ITable_functionContext is an interface to support dynamic dispatch.
type ITable_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_functionContext differentiates from other interfaces.
	IsTable_functionContext()
}

type Table_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_functionContext() *Table_functionContext {
	var p = new(Table_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_table_function
	return p
}

func (*Table_functionContext) IsTable_functionContext() {}

func NewTable_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_functionContext {
	var p = new(Table_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_table_function

	return p
}

func (s *Table_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_functionContext) Function() IFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}

func (s *Table_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTable_function(s)
	}
}

func (s *Table_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTable_function(s)
	}
}




func (p *ClickHouseParser) Table_function() (localctx ITable_functionContext) {
	localctx = NewTable_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ClickHouseParserRULE_table_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(931)
		p.Function()
	}



	return localctx
}


// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_subquery
	return p
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *SubqueryContext) Select_query_main() ISelect_query_mainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_query_mainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_query_mainContext)
}

func (s *SubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}




func (p *ClickHouseParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ClickHouseParserRULE_subquery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(933)
		p.Match(ClickHouseParserLPAREN)
	}
	{
		p.SetState(934)
		p.Select_query_main()
	}
	{
		p.SetState(935)
		p.Match(ClickHouseParserRPAREN)
	}



	return localctx
}


// IExpression_with_optional_aliasContext is an interface to support dynamic dispatch.
type IExpression_with_optional_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_with_optional_aliasContext differentiates from other interfaces.
	IsExpression_with_optional_aliasContext()
}

type Expression_with_optional_aliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_with_optional_aliasContext() *Expression_with_optional_aliasContext {
	var p = new(Expression_with_optional_aliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_expression_with_optional_alias
	return p
}

func (*Expression_with_optional_aliasContext) IsExpression_with_optional_aliasContext() {}

func NewExpression_with_optional_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_with_optional_aliasContext {
	var p = new(Expression_with_optional_aliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_expression_with_optional_alias

	return p
}

func (s *Expression_with_optional_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_with_optional_aliasContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expression_with_optional_aliasContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *Expression_with_optional_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_with_optional_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expression_with_optional_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExpression_with_optional_alias(s)
	}
}

func (s *Expression_with_optional_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExpression_with_optional_alias(s)
	}
}




func (p *ClickHouseParser) Expression_with_optional_alias() (localctx IExpression_with_optional_aliasContext) {
	localctx = NewExpression_with_optional_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ClickHouseParserRULE_expression_with_optional_alias)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		p.expr(0)
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ClickHouseParserK_AS {
		{
			p.SetState(938)
			p.Alias()
		}

	}



	return localctx
}


// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) CopyFrom(ctx *ExprContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}





type ExprConcatContext struct {
	*ExprContext
}

func NewExprConcatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprConcatContext {
	var p = new(ExprConcatContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprConcatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprConcatContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprConcatContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprConcatContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCONCAT, 0)
}


func (s *ExprConcatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprConcat(s)
	}
}

func (s *ExprConcatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprConcat(s)
	}
}


type ExprCaseContext struct {
	*ExprContext
}

func NewExprCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprCaseContext {
	var p = new(ExprCaseContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprCaseContext) K_CASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CASE, 0)
}

func (s *ExprCaseContext) K_ELSE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ELSE, 0)
}

func (s *ExprCaseContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprCaseContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprCaseContext) K_END() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_END, 0)
}

func (s *ExprCaseContext) AllK_WHEN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserK_WHEN)
}

func (s *ExprCaseContext) K_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_WHEN, i)
}

func (s *ExprCaseContext) AllK_THEN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserK_THEN)
}

func (s *ExprCaseContext) K_THEN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_THEN, i)
}


func (s *ExprCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprCase(s)
	}
}

func (s *ExprCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprCase(s)
	}
}


type ExprTupleElementContext struct {
	*ExprContext
}

func NewExprTupleElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprTupleElementContext {
	var p = new(ExprTupleElementContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprTupleElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprTupleElementContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprTupleElementContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprTupleElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}


func (s *ExprTupleElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprTupleElement(s)
	}
}

func (s *ExprTupleElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprTupleElement(s)
	}
}


type ExprNotContext struct {
	*ExprContext
}

func NewExprNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprNotContext {
	var p = new(ExprNotContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprNotContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NOT, 0)
}

func (s *ExprNotContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}


func (s *ExprNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprNot(s)
	}
}

func (s *ExprNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprNot(s)
	}
}


type ExprArrayContext struct {
	*ExprContext
}

func NewExprArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprArrayContext {
	var p = new(ExprArrayContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprArrayContext) Array() IArrayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayContext)
}


func (s *ExprArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprArray(s)
	}
}

func (s *ExprArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprArray(s)
	}
}


type ExprWithAliasContext struct {
	*ExprContext
}

func NewExprWithAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprWithAliasContext {
	var p = new(ExprWithAliasContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprWithAliasContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprWithAliasContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}


func (s *ExprWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprWithAlias(s)
	}
}

func (s *ExprWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprWithAlias(s)
	}
}


type ExprLogicalContext struct {
	*ExprContext
}

func NewExprLogicalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLogicalContext {
	var p = new(ExprLogicalContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLogicalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLogicalContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprLogicalContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprLogicalContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQUALS, 0)
}

func (s *ExprLogicalContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASSIGN, 0)
}

func (s *ExprLogicalContext) NOT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT_EQUALS, 0)
}

func (s *ExprLogicalContext) NOT_EQUALS2() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT_EQUALS2, 0)
}

func (s *ExprLogicalContext) LE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLE, 0)
}

func (s *ExprLogicalContext) GE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGE, 0)
}

func (s *ExprLogicalContext) LT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLT, 0)
}

func (s *ExprLogicalContext) GT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGT, 0)
}

func (s *ExprLogicalContext) K_LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LIKE, 0)
}

func (s *ExprLogicalContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NOT, 0)
}


func (s *ExprLogicalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprLogical(s)
	}
}

func (s *ExprLogicalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprLogical(s)
	}
}


type ExprInContext struct {
	*ExprContext
}

func NewExprInContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprInContext {
	var p = new(ExprInContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprInContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprInContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprInContext) K_IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_IN, 0)
}

func (s *ExprInContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NOT, 0)
}

func (s *ExprInContext) K_GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_GLOBAL, 0)
}


func (s *ExprInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprIn(s)
	}
}

func (s *ExprInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprIn(s)
	}
}


type ExprCastContext struct {
	*ExprContext
}

func NewExprCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprCastContext {
	var p = new(ExprCastContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprCastContext) K_CAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CAST, 0)
}

func (s *ExprCastContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ExprCastContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprCastContext) K_AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AS, 0)
}

func (s *ExprCastContext) Clickhouse_type() IClickhouse_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClickhouse_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClickhouse_typeContext)
}

func (s *ExprCastContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}


func (s *ExprCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprCast(s)
	}
}

func (s *ExprCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprCast(s)
	}
}


type ExprOrContext struct {
	*ExprContext
}

func NewExprOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprOrContext {
	var p = new(ExprOrContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprOrContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprOrContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprOrContext) K_OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OR, 0)
}


func (s *ExprOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprOr(s)
	}
}

func (s *ExprOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprOr(s)
	}
}


type ExprFunctionContext struct {
	*ExprContext
}

func NewExprFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprFunctionContext {
	var p = new(ExprFunctionContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprFunctionContext) Function() IFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}


func (s *ExprFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprFunction(s)
	}
}

func (s *ExprFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprFunction(s)
	}
}


type ExprMulContext struct {
	*ExprContext
}

func NewExprMulContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprMulContext {
	var p = new(ExprMulContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprMulContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprMulContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprMulContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprMulContext) STAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTAR, 0)
}

func (s *ExprMulContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDIVIDE, 0)
}

func (s *ExprMulContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPERCENT, 0)
}


func (s *ExprMulContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprMul(s)
	}
}

func (s *ExprMulContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprMul(s)
	}
}


type ExprIdContext struct {
	*ExprContext
}

func NewExprIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprIdContext {
	var p = new(ExprIdContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprIdContext) Compound_identifier() ICompound_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_identifierContext)
}


func (s *ExprIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprId(s)
	}
}

func (s *ExprIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprId(s)
	}
}


type ExprLambdaContext struct {
	*ExprContext
}

func NewExprLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLambdaContext {
	var p = new(ExprLambdaContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLambdaContext) RARROW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRARROW, 0)
}

func (s *ExprLambdaContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprLambdaContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ExprLambdaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ExprLambdaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExprLambdaContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ExprLambdaContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ExprLambdaContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}


func (s *ExprLambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprLambda(s)
	}
}

func (s *ExprLambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprLambda(s)
	}
}


type ExprTernaryContext struct {
	*ExprContext
}

func NewExprTernaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprTernaryContext {
	var p = new(ExprTernaryContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprTernaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprTernaryContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprTernaryContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprTernaryContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUESTION, 0)
}

func (s *ExprTernaryContext) COLON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLON, 0)
}


func (s *ExprTernaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprTernary(s)
	}
}

func (s *ExprTernaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprTernary(s)
	}
}


type ExprParenContext struct {
	*ExprContext
}

func NewExprParenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprParenContext {
	var p = new(ExprParenContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprParenContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ExprParenContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprParenContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}


func (s *ExprParenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprParen(s)
	}
}

func (s *ExprParenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprParen(s)
	}
}


type ExprBetweenContext struct {
	*ExprContext
}

func NewExprBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprBetweenContext {
	var p = new(ExprBetweenContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprBetweenContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprBetweenContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprBetweenContext) K_BETWEEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_BETWEEN, 0)
}

func (s *ExprBetweenContext) K_AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AND, 0)
}


func (s *ExprBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprBetween(s)
	}
}

func (s *ExprBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprBetween(s)
	}
}


type ExprSubqueryContext struct {
	*ExprContext
}

func NewExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprSubqueryContext {
	var p = new(ExprSubqueryContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSubqueryContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}


func (s *ExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprSubquery(s)
	}
}

func (s *ExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprSubquery(s)
	}
}


type ExprStarContext struct {
	*ExprContext
}

func NewExprStarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprStarContext {
	var p = new(ExprStarContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprStarContext) STAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTAR, 0)
}


func (s *ExprStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprStar(s)
	}
}

func (s *ExprStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprStar(s)
	}
}


type ExprIntervalContext struct {
	*ExprContext
}

func NewExprIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprIntervalContext {
	var p = new(ExprIntervalContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprIntervalContext) K_INTERVAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_INTERVAL, 0)
}

func (s *ExprIntervalContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprIntervalContext) Interval_unit() IInterval_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterval_unitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterval_unitContext)
}


func (s *ExprIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprInterval(s)
	}
}

func (s *ExprIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprInterval(s)
	}
}


type ExprAndContext struct {
	*ExprContext
}

func NewExprAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprAndContext {
	var p = new(ExprAndContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprAndContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprAndContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprAndContext) K_AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AND, 0)
}


func (s *ExprAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprAnd(s)
	}
}

func (s *ExprAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprAnd(s)
	}
}


type ExprArrayElementContext struct {
	*ExprContext
}

func NewExprArrayElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprArrayElementContext {
	var p = new(ExprArrayElementContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprArrayElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprArrayElementContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprArrayElementContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprArrayElementContext) LBRAKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLBRAKET, 0)
}

func (s *ExprArrayElementContext) RBRAKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRBRAKET, 0)
}


func (s *ExprArrayElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprArrayElement(s)
	}
}

func (s *ExprArrayElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprArrayElement(s)
	}
}


type ExprIsNullContext struct {
	*ExprContext
}

func NewExprIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprIsNullContext {
	var p = new(ExprIsNullContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprIsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprIsNullContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprIsNullContext) K_IS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_IS, 0)
}

func (s *ExprIsNullContext) K_NULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NULL, 0)
}

func (s *ExprIsNullContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NOT, 0)
}


func (s *ExprIsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprIsNull(s)
	}
}

func (s *ExprIsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprIsNull(s)
	}
}


type ExprListContext struct {
	*ExprContext
}

func NewExprListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprListContext {
	var p = new(ExprListContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ExprListContext) Not_empty_expression_list() INot_empty_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_empty_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_empty_expression_listContext)
}

func (s *ExprListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}


func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprList(s)
	}
}


type ExprLiteralContext struct {
	*ExprContext
}

func NewExprLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprLiteralContext {
	var p = new(ExprLiteralContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprLiteralContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}


func (s *ExprLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprLiteral(s)
	}
}

func (s *ExprLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprLiteral(s)
	}
}


type ExprUnaryMinusContext struct {
	*ExprContext
}

func NewExprUnaryMinusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprUnaryMinusContext {
	var p = new(ExprUnaryMinusContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprUnaryMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprUnaryMinusContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMINUS, 0)
}

func (s *ExprUnaryMinusContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}


func (s *ExprUnaryMinusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprUnaryMinus(s)
	}
}

func (s *ExprUnaryMinusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprUnaryMinus(s)
	}
}


type ExprAddContext struct {
	*ExprContext
}

func NewExprAddContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprAddContext {
	var p = new(ExprAddContext)

	p.ExprContext = NewEmptyExprContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExprContext))

	return p
}

func (s *ExprAddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprAddContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprAddContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprAddContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPLUS, 0)
}

func (s *ExprAddContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMINUS, 0)
}


func (s *ExprAddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExprAdd(s)
	}
}

func (s *ExprAddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExprAdd(s)
	}
}



func (p *ClickHouseParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *ClickHouseParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 144
	p.EnterRecursionRule(localctx, 144, ClickHouseParserRULE_expr, _p)
	var _la int


	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExprParenContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(942)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(943)
			p.expr(0)
		}
		{
			p.SetState(944)
			p.Match(ClickHouseParserRPAREN)
		}


	case 2:
		localctx = NewExprFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(946)
			p.Function()
		}


	case 3:
		localctx = NewExprCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(947)
			p.Match(ClickHouseParserK_CASE)
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(948)
				p.expr(0)
			}


		}

		{
			p.SetState(951)
			p.Match(ClickHouseParserK_WHEN)
		}
		{
			p.SetState(952)
			p.expr(0)
		}
		{
			p.SetState(953)
			p.Match(ClickHouseParserK_THEN)
		}
		{
			p.SetState(954)
			p.expr(0)
		}

		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ClickHouseParserK_WHEN {
			{
				p.SetState(956)
				p.Match(ClickHouseParserK_WHEN)
			}
			{
				p.SetState(957)
				p.expr(0)
			}
			{
				p.SetState(958)
				p.Match(ClickHouseParserK_THEN)
			}
			{
				p.SetState(959)
				p.expr(0)
			}


			p.SetState(965)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(966)
			p.Match(ClickHouseParserK_ELSE)
		}
		{
			p.SetState(967)
			p.expr(0)
		}
		{
			p.SetState(968)
			p.Match(ClickHouseParserK_END)
		}


	case 4:
		localctx = NewExprUnaryMinusContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(970)
			p.Match(ClickHouseParserMINUS)
		}
		{
			p.SetState(971)
			p.expr(22)
		}


	case 5:
		localctx = NewExprCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(972)
			p.Match(ClickHouseParserK_CAST)
		}
		{
			p.SetState(973)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(974)
			p.expr(0)
		}
		{
			p.SetState(975)
			p.Match(ClickHouseParserK_AS)
		}
		{
			p.SetState(976)
			p.Clickhouse_type()
		}
		{
			p.SetState(977)
			p.Match(ClickHouseParserRPAREN)
		}


	case 6:
		localctx = NewExprIntervalContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(979)
			p.Match(ClickHouseParserK_INTERVAL)
		}
		{
			p.SetState(980)
			p.expr(0)
		}
		{
			p.SetState(981)
			p.Interval_unit()
		}


	case 7:
		localctx = NewExprNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(983)
			p.Match(ClickHouseParserK_NOT)
		}
		{
			p.SetState(984)
			p.expr(12)
		}


	case 8:
		localctx = NewExprLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(1004)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserLPAREN:
			{
				p.SetState(985)
				p.Match(ClickHouseParserLPAREN)
			}
			{
				p.SetState(986)
				p.Identifier()
			}
			p.SetState(991)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for _la == ClickHouseParserCOMMA {
				{
					p.SetState(987)
					p.Match(ClickHouseParserCOMMA)
				}
				{
					p.SetState(988)
					p.Identifier()
				}


				p.SetState(993)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(994)
				p.Match(ClickHouseParserRPAREN)
			}


		case ClickHouseParserK_ADD, ClickHouseParserK_AFTER, ClickHouseParserK_ALL, ClickHouseParserK_ALIAS, ClickHouseParserK_ALTER, ClickHouseParserK_AND, ClickHouseParserK_ANY, ClickHouseParserK_ARRAY, ClickHouseParserK_AS, ClickHouseParserK_ASCENDING, ClickHouseParserK_ASC, ClickHouseParserK_ASYNC, ClickHouseParserK_ATTACH, ClickHouseParserK_BETWEEN, ClickHouseParserK_BY, ClickHouseParserK_CASE, ClickHouseParserK_CHECK, ClickHouseParserK_COLUMN, ClickHouseParserK_COLLATE, ClickHouseParserK_CREATE, ClickHouseParserK_CROSS, ClickHouseParserK_DESCRIBE, ClickHouseParserK_DESCENDING, ClickHouseParserK_DESC, ClickHouseParserK_DATABASE, ClickHouseParserK_DATABASES, ClickHouseParserK_DEFAULT, ClickHouseParserK_DETACH, ClickHouseParserK_DISTINCT, ClickHouseParserK_DROP, ClickHouseParserK_ELSE, ClickHouseParserK_END, ClickHouseParserK_ENGINE, ClickHouseParserK_EXISTS, ClickHouseParserK_FINAL, ClickHouseParserK_FIRST, ClickHouseParserK_FROM, ClickHouseParserK_FORMAT, ClickHouseParserK_FULL, ClickHouseParserK_GLOBAL, ClickHouseParserK_GROUP, ClickHouseParserK_HAVING, ClickHouseParserK_ID, ClickHouseParserK_IF, ClickHouseParserK_INNER, ClickHouseParserK_INSERT, ClickHouseParserK_INTO, ClickHouseParserK_IN, ClickHouseParserK_IS, ClickHouseParserK_JOIN, ClickHouseParserK_KILL, ClickHouseParserK_LAST, ClickHouseParserK_LEFT, ClickHouseParserK_LIKE, ClickHouseParserK_LIMIT, ClickHouseParserK_MAIN, ClickHouseParserK_MATERIALIZED, ClickHouseParserK_MODIFY, ClickHouseParserK_NOT, ClickHouseParserK_NULL, ClickHouseParserK_NULLS, ClickHouseParserK_OFFSET, ClickHouseParserK_ON, ClickHouseParserK_OPTIMIZE, ClickHouseParserK_ORDER, ClickHouseParserK_OR, ClickHouseParserK_OUTFILE, ClickHouseParserK_PARTITION, ClickHouseParserK_POPULATE, ClickHouseParserK_PREWHERE, ClickHouseParserK_PROCESSLIST, ClickHouseParserK_QUERY, ClickHouseParserK_RENAME, ClickHouseParserK_RETURN, ClickHouseParserK_RIGHT, ClickHouseParserK_SAMPLE, ClickHouseParserK_SELECT, ClickHouseParserK_SET, ClickHouseParserK_SETTINGS, ClickHouseParserK_SHOW, ClickHouseParserK_SYNC, ClickHouseParserK_TABLE, ClickHouseParserK_TABLES, ClickHouseParserK_TEMPORARY, ClickHouseParserK_TEST, ClickHouseParserK_THEN, ClickHouseParserK_TOTALS, ClickHouseParserK_TO, ClickHouseParserK_OUTER, ClickHouseParserK_VALUES, ClickHouseParserK_VIEW, ClickHouseParserK_UNION, ClickHouseParserK_USE, ClickHouseParserK_USING, ClickHouseParserK_WHEN, ClickHouseParserK_WHERE, ClickHouseParserK_WITH, ClickHouseParserT_FLOAT32, ClickHouseParserT_FLOAT64, ClickHouseParserT_UINT8, ClickHouseParserT_UINT16, ClickHouseParserT_UINT32, ClickHouseParserT_UINT64, ClickHouseParserT_INT8, ClickHouseParserT_INT16, ClickHouseParserT_INT32, ClickHouseParserT_INT64, ClickHouseParserT_ENUM8, ClickHouseParserT_ENUM16, ClickHouseParserT_UUID, ClickHouseParserT_DATE, ClickHouseParserT_DATETIME, ClickHouseParserT_STRING, ClickHouseParserT_FIXEDSTRING, ClickHouseParserT_NULL, ClickHouseParserT_INTERVAL_YEAR, ClickHouseParserT_INTERVAL_MONTH, ClickHouseParserT_INTERVAL_WEEK, ClickHouseParserT_INTERVAL_DAY, ClickHouseParserT_INTERVAL_HOUR, ClickHouseParserT_INTERVAL_MINUTE, ClickHouseParserT_INTERVAL_SECOND, ClickHouseParserIDENTIFIER, ClickHouseParserQUOTED_LITERAL:
			{
				p.SetState(996)
				p.Identifier()
			}
			p.SetState(1001)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for _la == ClickHouseParserCOMMA {
				{
					p.SetState(997)
					p.Match(ClickHouseParserCOMMA)
				}
				{
					p.SetState(998)
					p.Identifier()
				}


				p.SetState(1003)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1006)
			p.Match(ClickHouseParserRARROW)
		}
		{
			p.SetState(1007)
			p.expr(8)
		}


	case 9:
		localctx = NewExprSubqueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1009)
			p.Subquery()
		}


	case 10:
		localctx = NewExprListContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1010)
			p.Match(ClickHouseParserLPAREN)
		}
		{
			p.SetState(1011)
			p.Not_empty_expression_list()
		}
		{
			p.SetState(1012)
			p.Match(ClickHouseParserRPAREN)
		}


	case 11:
		localctx = NewExprArrayContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1014)
			p.Array()
		}


	case 12:
		localctx = NewExprLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1015)
			p.Literal()
		}


	case 13:
		localctx = NewExprIdContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1016)
			p.Compound_identifier()
		}


	case 14:
		localctx = NewExprStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1017)
			p.Match(ClickHouseParserSTAR)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1092)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprTupleElementContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1020)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
				}
				{
					p.SetState(1021)
					p.Match(ClickHouseParserDOT)
				}
				{
					p.SetState(1022)
					p.expr(25)
				}


			case 2:
				localctx = NewExprMulContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1023)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				p.SetState(1024)
				_la = p.GetTokenStream().LA(1)

				if !(((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ClickHouseParserSTAR - 125)) | (1 << (ClickHouseParserPERCENT - 125)) | (1 << (ClickHouseParserDIVIDE - 125)))) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
				    p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
				{
					p.SetState(1025)
					p.expr(21)
				}


			case 3:
				localctx = NewExprAddContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1026)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				p.SetState(1027)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserPLUS || _la == ClickHouseParserMINUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
				    p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
				{
					p.SetState(1028)
					p.expr(20)
				}


			case 4:
				localctx = NewExprConcatContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1029)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(1030)
					p.Match(ClickHouseParserCONCAT)
				}
				{
					p.SetState(1031)
					p.expr(19)
				}


			case 5:
				localctx = NewExprBetweenContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1032)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(1033)
					p.Match(ClickHouseParserK_BETWEEN)
				}
				{
					p.SetState(1034)
					p.expr(0)
				}
				{
					p.SetState(1035)
					p.Match(ClickHouseParserK_AND)
				}
				{
					p.SetState(1036)
					p.expr(18)
				}


			case 6:
				localctx = NewExprLogicalContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1038)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				p.SetState(1050)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case ClickHouseParserEQUALS:
					{
						p.SetState(1039)
						p.Match(ClickHouseParserEQUALS)
					}


				case ClickHouseParserASSIGN:
					{
						p.SetState(1040)
						p.Match(ClickHouseParserASSIGN)
					}


				case ClickHouseParserNOT_EQUALS:
					{
						p.SetState(1041)
						p.Match(ClickHouseParserNOT_EQUALS)
					}


				case ClickHouseParserNOT_EQUALS2:
					{
						p.SetState(1042)
						p.Match(ClickHouseParserNOT_EQUALS2)
					}


				case ClickHouseParserLE:
					{
						p.SetState(1043)
						p.Match(ClickHouseParserLE)
					}


				case ClickHouseParserGE:
					{
						p.SetState(1044)
						p.Match(ClickHouseParserGE)
					}


				case ClickHouseParserLT:
					{
						p.SetState(1045)
						p.Match(ClickHouseParserLT)
					}


				case ClickHouseParserGT:
					{
						p.SetState(1046)
						p.Match(ClickHouseParserGT)
					}


				case ClickHouseParserK_LIKE:
					{
						p.SetState(1047)
						p.Match(ClickHouseParserK_LIKE)
					}


				case ClickHouseParserK_NOT:
					{
						p.SetState(1048)
						p.Match(ClickHouseParserK_NOT)
					}
					{
						p.SetState(1049)
						p.Match(ClickHouseParserK_LIKE)
					}



				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				{
					p.SetState(1052)
					p.expr(17)
				}


			case 7:
				localctx = NewExprInContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1053)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				p.SetState(1062)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1054)
						p.Match(ClickHouseParserK_IN)
					}


				case 2:
					{
						p.SetState(1055)
						p.Match(ClickHouseParserK_NOT)
					}
					{
						p.SetState(1056)
						p.Match(ClickHouseParserK_IN)
					}


				case 3:
					{
						p.SetState(1057)
						p.Match(ClickHouseParserK_GLOBAL)
					}
					{
						p.SetState(1058)
						p.Match(ClickHouseParserK_IN)
					}


				case 4:
					{
						p.SetState(1059)
						p.Match(ClickHouseParserK_GLOBAL)
					}
					{
						p.SetState(1060)
						p.Match(ClickHouseParserK_NOT)
					}
					{
						p.SetState(1061)
						p.Match(ClickHouseParserK_IN)
					}

				}
				{
					p.SetState(1064)
					p.expr(16)
				}


			case 8:
				localctx = NewExprAndContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1065)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1066)
					p.Match(ClickHouseParserK_AND)
				}
				{
					p.SetState(1067)
					p.expr(12)
				}


			case 9:
				localctx = NewExprOrContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1068)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1069)
					p.Match(ClickHouseParserK_OR)
				}
				{
					p.SetState(1070)
					p.expr(11)
				}


			case 10:
				localctx = NewExprTernaryContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1071)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1072)
					p.Match(ClickHouseParserQUESTION)
				}
				{
					p.SetState(1073)
					p.expr(0)
				}
				{
					p.SetState(1074)
					p.Match(ClickHouseParserCOLON)
				}
				{
					p.SetState(1075)
					p.expr(10)
				}


			case 11:
				localctx = NewExprArrayElementContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1077)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
				}
				{
					p.SetState(1078)
					p.Match(ClickHouseParserLBRAKET)
				}
				{
					p.SetState(1079)
					p.expr(0)
				}
				{
					p.SetState(1080)
					p.Match(ClickHouseParserRBRAKET)
				}


			case 12:
				localctx = NewExprIsNullContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1082)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				p.SetState(1088)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1083)
						p.Match(ClickHouseParserK_IS)
					}
					{
						p.SetState(1084)
						p.Match(ClickHouseParserK_NULL)
					}


				case 2:
					{
						p.SetState(1085)
						p.Match(ClickHouseParserK_IS)
					}
					{
						p.SetState(1086)
						p.Match(ClickHouseParserK_NOT)
					}
					{
						p.SetState(1087)
						p.Match(ClickHouseParserK_NULL)
					}

				}


			case 13:
				localctx = NewExprWithAliasContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_expr)
				p.SetState(1090)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1091)
					p.Alias()
				}

			}

		}
		p.SetState(1096)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())
	}



	return localctx
}


// IInterval_unitContext is an interface to support dynamic dispatch.
type IInterval_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterval_unitContext differentiates from other interfaces.
	IsInterval_unitContext()
}

type Interval_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterval_unitContext() *Interval_unitContext {
	var p = new(Interval_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_interval_unit
	return p
}

func (*Interval_unitContext) IsInterval_unitContext() {}

func NewInterval_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interval_unitContext {
	var p = new(Interval_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_interval_unit

	return p
}

func (s *Interval_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Interval_unitContext) K_YEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_YEAR, 0)
}

func (s *Interval_unitContext) K_MONTH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_MONTH, 0)
}

func (s *Interval_unitContext) K_WEEK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_WEEK, 0)
}

func (s *Interval_unitContext) K_DAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DAY, 0)
}

func (s *Interval_unitContext) K_HOUR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_HOUR, 0)
}

func (s *Interval_unitContext) K_MINUTE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_MINUTE, 0)
}

func (s *Interval_unitContext) K_SECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SECOND, 0)
}

func (s *Interval_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interval_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Interval_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterInterval_unit(s)
	}
}

func (s *Interval_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitInterval_unit(s)
	}
}




func (p *ClickHouseParser) Interval_unit() (localctx IInterval_unitContext) {
	localctx = NewInterval_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ClickHouseParserRULE_interval_unit)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1097)
	_la = p.GetTokenStream().LA(1)

	if !(_la == ClickHouseParserK_DAY || ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (ClickHouseParserK_HOUR - 52)) | (1 << (ClickHouseParserK_MINUTE - 52)) | (1 << (ClickHouseParserK_MONTH - 52)))) != 0) || ((((_la - 90)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 90))) & ((1 << (ClickHouseParserK_SECOND - 90)) | (1 << (ClickHouseParserK_WEEK - 90)) | (1 << (ClickHouseParserK_YEAR - 90)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IExpression_listContext is an interface to support dynamic dispatch.
type IExpression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_listContext differentiates from other interfaces.
	IsExpression_listContext()
}

type Expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_listContext() *Expression_listContext {
	var p = new(Expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_expression_list
	return p
}

func (*Expression_listContext) IsExpression_listContext() {}

func NewExpression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_listContext {
	var p = new(Expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_expression_list

	return p
}

func (s *Expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_listContext) Not_empty_expression_list() INot_empty_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_empty_expression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_empty_expression_listContext)
}

func (s *Expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExpression_list(s)
	}
}

func (s *Expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExpression_list(s)
	}
}




func (p *ClickHouseParser) Expression_list() (localctx IExpression_listContext) {
	localctx = NewExpression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ClickHouseParserRULE_expression_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ClickHouseParserK_ADD) | (1 << ClickHouseParserK_AFTER) | (1 << ClickHouseParserK_ALL) | (1 << ClickHouseParserK_ALIAS) | (1 << ClickHouseParserK_ALTER) | (1 << ClickHouseParserK_AND) | (1 << ClickHouseParserK_ANY) | (1 << ClickHouseParserK_ARRAY) | (1 << ClickHouseParserK_AS) | (1 << ClickHouseParserK_ASCENDING) | (1 << ClickHouseParserK_ASC) | (1 << ClickHouseParserK_ASYNC) | (1 << ClickHouseParserK_ATTACH) | (1 << ClickHouseParserK_BETWEEN) | (1 << ClickHouseParserK_BY) | (1 << ClickHouseParserK_CASE) | (1 << ClickHouseParserK_CAST) | (1 << ClickHouseParserK_CHECK) | (1 << ClickHouseParserK_COLUMN) | (1 << ClickHouseParserK_COLLATE) | (1 << ClickHouseParserK_CREATE) | (1 << ClickHouseParserK_CROSS) | (1 << ClickHouseParserK_DESCRIBE) | (1 << ClickHouseParserK_DESCENDING) | (1 << ClickHouseParserK_DESC) | (1 << ClickHouseParserK_DATABASE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ClickHouseParserK_DATABASES - 32)) | (1 << (ClickHouseParserK_DEFAULT - 32)) | (1 << (ClickHouseParserK_DETACH - 32)) | (1 << (ClickHouseParserK_DISTINCT - 32)) | (1 << (ClickHouseParserK_DROP - 32)) | (1 << (ClickHouseParserK_ELSE - 32)) | (1 << (ClickHouseParserK_END - 32)) | (1 << (ClickHouseParserK_ENGINE - 32)) | (1 << (ClickHouseParserK_EXISTS - 32)) | (1 << (ClickHouseParserK_FINAL - 32)) | (1 << (ClickHouseParserK_FIRST - 32)) | (1 << (ClickHouseParserK_FROM - 32)) | (1 << (ClickHouseParserK_FORMAT - 32)) | (1 << (ClickHouseParserK_FULL - 32)) | (1 << (ClickHouseParserK_GLOBAL - 32)) | (1 << (ClickHouseParserK_GROUP - 32)) | (1 << (ClickHouseParserK_HAVING - 32)) | (1 << (ClickHouseParserK_ID - 32)) | (1 << (ClickHouseParserK_IF - 32)) | (1 << (ClickHouseParserK_INNER - 32)) | (1 << (ClickHouseParserK_INSERT - 32)) | (1 << (ClickHouseParserK_INTERVAL - 32)) | (1 << (ClickHouseParserK_INTO - 32)) | (1 << (ClickHouseParserK_IN - 32)) | (1 << (ClickHouseParserK_IS - 32)) | (1 << (ClickHouseParserK_JOIN - 32)) | (1 << (ClickHouseParserK_KILL - 32)) | (1 << (ClickHouseParserK_LAST - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ClickHouseParserK_LEFT - 64)) | (1 << (ClickHouseParserK_LIKE - 64)) | (1 << (ClickHouseParserK_LIMIT - 64)) | (1 << (ClickHouseParserK_MAIN - 64)) | (1 << (ClickHouseParserK_MATERIALIZED - 64)) | (1 << (ClickHouseParserK_MODIFY - 64)) | (1 << (ClickHouseParserK_NOT - 64)) | (1 << (ClickHouseParserK_NULL - 64)) | (1 << (ClickHouseParserK_NULLS - 64)) | (1 << (ClickHouseParserK_OFFSET - 64)) | (1 << (ClickHouseParserK_ON - 64)) | (1 << (ClickHouseParserK_OPTIMIZE - 64)) | (1 << (ClickHouseParserK_ORDER - 64)) | (1 << (ClickHouseParserK_OR - 64)) | (1 << (ClickHouseParserK_OUTFILE - 64)) | (1 << (ClickHouseParserK_PARTITION - 64)) | (1 << (ClickHouseParserK_POPULATE - 64)) | (1 << (ClickHouseParserK_PREWHERE - 64)) | (1 << (ClickHouseParserK_PROCESSLIST - 64)) | (1 << (ClickHouseParserK_QUERY - 64)) | (1 << (ClickHouseParserK_RENAME - 64)) | (1 << (ClickHouseParserK_RETURN - 64)) | (1 << (ClickHouseParserK_RIGHT - 64)) | (1 << (ClickHouseParserK_SAMPLE - 64)) | (1 << (ClickHouseParserK_SELECT - 64)) | (1 << (ClickHouseParserK_SET - 64)) | (1 << (ClickHouseParserK_SETTINGS - 64)) | (1 << (ClickHouseParserK_SHOW - 64)) | (1 << (ClickHouseParserK_SYNC - 64)))) != 0) || ((((_la - 96)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 96))) & ((1 << (ClickHouseParserK_TABLE - 96)) | (1 << (ClickHouseParserK_TABLES - 96)) | (1 << (ClickHouseParserK_TEMPORARY - 96)) | (1 << (ClickHouseParserK_TEST - 96)) | (1 << (ClickHouseParserK_THEN - 96)) | (1 << (ClickHouseParserK_TOTALS - 96)) | (1 << (ClickHouseParserK_TO - 96)) | (1 << (ClickHouseParserK_OUTER - 96)) | (1 << (ClickHouseParserK_VALUES - 96)) | (1 << (ClickHouseParserK_VIEW - 96)) | (1 << (ClickHouseParserK_UNION - 96)) | (1 << (ClickHouseParserK_USE - 96)) | (1 << (ClickHouseParserK_USING - 96)) | (1 << (ClickHouseParserK_WHEN - 96)) | (1 << (ClickHouseParserK_WHERE - 96)) | (1 << (ClickHouseParserK_WITH - 96)) | (1 << (ClickHouseParserLPAREN - 96)) | (1 << (ClickHouseParserSTAR - 96)))) != 0) || ((((_la - 132)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 132))) & ((1 << (ClickHouseParserMINUS - 132)) | (1 << (ClickHouseParserLBRAKET - 132)) | (1 << (ClickHouseParserT_FLOAT32 - 132)) | (1 << (ClickHouseParserT_FLOAT64 - 132)) | (1 << (ClickHouseParserT_UINT8 - 132)) | (1 << (ClickHouseParserT_UINT16 - 132)) | (1 << (ClickHouseParserT_UINT32 - 132)) | (1 << (ClickHouseParserT_UINT64 - 132)) | (1 << (ClickHouseParserT_INT8 - 132)) | (1 << (ClickHouseParserT_INT16 - 132)) | (1 << (ClickHouseParserT_INT32 - 132)) | (1 << (ClickHouseParserT_INT64 - 132)) | (1 << (ClickHouseParserT_ENUM8 - 132)) | (1 << (ClickHouseParserT_ENUM16 - 132)) | (1 << (ClickHouseParserT_UUID - 132)) | (1 << (ClickHouseParserT_DATE - 132)) | (1 << (ClickHouseParserT_DATETIME - 132)) | (1 << (ClickHouseParserT_STRING - 132)) | (1 << (ClickHouseParserT_FIXEDSTRING - 132)))) != 0) || ((((_la - 164)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 164))) & ((1 << (ClickHouseParserT_NULL - 164)) | (1 << (ClickHouseParserT_INTERVAL_YEAR - 164)) | (1 << (ClickHouseParserT_INTERVAL_MONTH - 164)) | (1 << (ClickHouseParserT_INTERVAL_WEEK - 164)) | (1 << (ClickHouseParserT_INTERVAL_DAY - 164)) | (1 << (ClickHouseParserT_INTERVAL_HOUR - 164)) | (1 << (ClickHouseParserT_INTERVAL_MINUTE - 164)) | (1 << (ClickHouseParserT_INTERVAL_SECOND - 164)) | (1 << (ClickHouseParserIDENTIFIER - 164)) | (1 << (ClickHouseParserNUMERIC_LITERAL - 164)) | (1 << (ClickHouseParserSTRING_LITERAL - 164)) | (1 << (ClickHouseParserQUOTED_LITERAL - 164)))) != 0) {
		{
			p.SetState(1099)
			p.Not_empty_expression_list()
		}

	}



	return localctx
}


// INot_empty_expression_listContext is an interface to support dynamic dispatch.
type INot_empty_expression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNot_empty_expression_listContext differentiates from other interfaces.
	IsNot_empty_expression_listContext()
}

type Not_empty_expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_empty_expression_listContext() *Not_empty_expression_listContext {
	var p = new(Not_empty_expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_not_empty_expression_list
	return p
}

func (*Not_empty_expression_listContext) IsNot_empty_expression_listContext() {}

func NewNot_empty_expression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_empty_expression_listContext {
	var p = new(Not_empty_expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_not_empty_expression_list

	return p
}

func (s *Not_empty_expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Not_empty_expression_listContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *Not_empty_expression_listContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Not_empty_expression_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Not_empty_expression_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Not_empty_expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_empty_expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Not_empty_expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterNot_empty_expression_list(s)
	}
}

func (s *Not_empty_expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitNot_empty_expression_list(s)
	}
}




func (p *ClickHouseParser) Not_empty_expression_list() (localctx INot_empty_expression_listContext) {
	localctx = NewNot_empty_expression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ClickHouseParserRULE_not_empty_expression_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1102)
		p.expr(0)
	}
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(1103)
			p.Match(ClickHouseParserCOMMA)
		}
		{
			p.SetState(1104)
			p.expr(0)
		}


		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IArrayContext is an interface to support dynamic dispatch.
type IArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayContext differentiates from other interfaces.
	IsArrayContext()
}

type ArrayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayContext() *ArrayContext {
	var p = new(ArrayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_array
	return p
}

func (*ArrayContext) IsArrayContext() {}

func NewArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayContext {
	var p = new(ArrayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_array

	return p
}

func (s *ArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayContext) LBRAKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLBRAKET, 0)
}

func (s *ArrayContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *ArrayContext) RBRAKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRBRAKET, 0)
}

func (s *ArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterArray(s)
	}
}

func (s *ArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitArray(s)
	}
}




func (p *ClickHouseParser) Array() (localctx IArrayContext) {
	localctx = NewArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ClickHouseParserRULE_array)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1110)
		p.Match(ClickHouseParserLBRAKET)
	}
	{
		p.SetState(1111)
		p.Expression_list()
	}
	{
		p.SetState(1112)
		p.Match(ClickHouseParserRBRAKET)
	}



	return localctx
}


// IFunctionContext is an interface to support dynamic dispatch.
type IFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionContext differentiates from other interfaces.
	IsFunctionContext()
}

type FunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionContext() *FunctionContext {
	var p = new(FunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_function
	return p
}

func (*FunctionContext) IsFunctionContext() {}

func NewFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionContext {
	var p = new(FunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_function

	return p
}

func (s *FunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionContext) Function_name() IFunction_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *FunctionContext) Function_arguments() IFunction_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_argumentsContext)
}

func (s *FunctionContext) Function_parameters() IFunction_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_parametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_parametersContext)
}

func (s *FunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFunction(s)
	}
}

func (s *FunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFunction(s)
	}
}




func (p *ClickHouseParser) Function() (localctx IFunctionContext) {
	localctx = NewFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ClickHouseParserRULE_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1114)
		p.Function_name()
	}
	p.SetState(1116)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1115)
			p.Function_parameters()
		}


	}
	{
		p.SetState(1118)
		p.Function_arguments()
	}



	return localctx
}


// IFunction_parametersContext is an interface to support dynamic dispatch.
type IFunction_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_parametersContext differentiates from other interfaces.
	IsFunction_parametersContext()
}

type Function_parametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_parametersContext() *Function_parametersContext {
	var p = new(Function_parametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_function_parameters
	return p
}

func (*Function_parametersContext) IsFunction_parametersContext() {}

func NewFunction_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_parametersContext {
	var p = new(Function_parametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_function_parameters

	return p
}

func (s *Function_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_parametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *Function_parametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *Function_parametersContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *Function_parametersContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Function_parametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Function_parametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Function_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFunction_parameters(s)
	}
}

func (s *Function_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFunction_parameters(s)
	}
}




func (p *ClickHouseParser) Function_parameters() (localctx IFunction_parametersContext) {
	localctx = NewFunction_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ClickHouseParserRULE_function_parameters)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1120)
		p.Match(ClickHouseParserLPAREN)
	}
	p.SetState(1129)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ClickHouseParserK_ADD) | (1 << ClickHouseParserK_AFTER) | (1 << ClickHouseParserK_ALL) | (1 << ClickHouseParserK_ALIAS) | (1 << ClickHouseParserK_ALTER) | (1 << ClickHouseParserK_AND) | (1 << ClickHouseParserK_ANY) | (1 << ClickHouseParserK_ARRAY) | (1 << ClickHouseParserK_AS) | (1 << ClickHouseParserK_ASCENDING) | (1 << ClickHouseParserK_ASC) | (1 << ClickHouseParserK_ASYNC) | (1 << ClickHouseParserK_ATTACH) | (1 << ClickHouseParserK_BETWEEN) | (1 << ClickHouseParserK_BY) | (1 << ClickHouseParserK_CASE) | (1 << ClickHouseParserK_CAST) | (1 << ClickHouseParserK_CHECK) | (1 << ClickHouseParserK_COLUMN) | (1 << ClickHouseParserK_COLLATE) | (1 << ClickHouseParserK_CREATE) | (1 << ClickHouseParserK_CROSS) | (1 << ClickHouseParserK_DESCRIBE) | (1 << ClickHouseParserK_DESCENDING) | (1 << ClickHouseParserK_DESC) | (1 << ClickHouseParserK_DATABASE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ClickHouseParserK_DATABASES - 32)) | (1 << (ClickHouseParserK_DEFAULT - 32)) | (1 << (ClickHouseParserK_DETACH - 32)) | (1 << (ClickHouseParserK_DISTINCT - 32)) | (1 << (ClickHouseParserK_DROP - 32)) | (1 << (ClickHouseParserK_ELSE - 32)) | (1 << (ClickHouseParserK_END - 32)) | (1 << (ClickHouseParserK_ENGINE - 32)) | (1 << (ClickHouseParserK_EXISTS - 32)) | (1 << (ClickHouseParserK_FINAL - 32)) | (1 << (ClickHouseParserK_FIRST - 32)) | (1 << (ClickHouseParserK_FROM - 32)) | (1 << (ClickHouseParserK_FORMAT - 32)) | (1 << (ClickHouseParserK_FULL - 32)) | (1 << (ClickHouseParserK_GLOBAL - 32)) | (1 << (ClickHouseParserK_GROUP - 32)) | (1 << (ClickHouseParserK_HAVING - 32)) | (1 << (ClickHouseParserK_ID - 32)) | (1 << (ClickHouseParserK_IF - 32)) | (1 << (ClickHouseParserK_INNER - 32)) | (1 << (ClickHouseParserK_INSERT - 32)) | (1 << (ClickHouseParserK_INTERVAL - 32)) | (1 << (ClickHouseParserK_INTO - 32)) | (1 << (ClickHouseParserK_IN - 32)) | (1 << (ClickHouseParserK_IS - 32)) | (1 << (ClickHouseParserK_JOIN - 32)) | (1 << (ClickHouseParserK_KILL - 32)) | (1 << (ClickHouseParserK_LAST - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ClickHouseParserK_LEFT - 64)) | (1 << (ClickHouseParserK_LIKE - 64)) | (1 << (ClickHouseParserK_LIMIT - 64)) | (1 << (ClickHouseParserK_MAIN - 64)) | (1 << (ClickHouseParserK_MATERIALIZED - 64)) | (1 << (ClickHouseParserK_MODIFY - 64)) | (1 << (ClickHouseParserK_NOT - 64)) | (1 << (ClickHouseParserK_NULL - 64)) | (1 << (ClickHouseParserK_NULLS - 64)) | (1 << (ClickHouseParserK_OFFSET - 64)) | (1 << (ClickHouseParserK_ON - 64)) | (1 << (ClickHouseParserK_OPTIMIZE - 64)) | (1 << (ClickHouseParserK_ORDER - 64)) | (1 << (ClickHouseParserK_OR - 64)) | (1 << (ClickHouseParserK_OUTFILE - 64)) | (1 << (ClickHouseParserK_PARTITION - 64)) | (1 << (ClickHouseParserK_POPULATE - 64)) | (1 << (ClickHouseParserK_PREWHERE - 64)) | (1 << (ClickHouseParserK_PROCESSLIST - 64)) | (1 << (ClickHouseParserK_QUERY - 64)) | (1 << (ClickHouseParserK_RENAME - 64)) | (1 << (ClickHouseParserK_RETURN - 64)) | (1 << (ClickHouseParserK_RIGHT - 64)) | (1 << (ClickHouseParserK_SAMPLE - 64)) | (1 << (ClickHouseParserK_SELECT - 64)) | (1 << (ClickHouseParserK_SET - 64)) | (1 << (ClickHouseParserK_SETTINGS - 64)) | (1 << (ClickHouseParserK_SHOW - 64)) | (1 << (ClickHouseParserK_SYNC - 64)))) != 0) || ((((_la - 96)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 96))) & ((1 << (ClickHouseParserK_TABLE - 96)) | (1 << (ClickHouseParserK_TABLES - 96)) | (1 << (ClickHouseParserK_TEMPORARY - 96)) | (1 << (ClickHouseParserK_TEST - 96)) | (1 << (ClickHouseParserK_THEN - 96)) | (1 << (ClickHouseParserK_TOTALS - 96)) | (1 << (ClickHouseParserK_TO - 96)) | (1 << (ClickHouseParserK_OUTER - 96)) | (1 << (ClickHouseParserK_VALUES - 96)) | (1 << (ClickHouseParserK_VIEW - 96)) | (1 << (ClickHouseParserK_UNION - 96)) | (1 << (ClickHouseParserK_USE - 96)) | (1 << (ClickHouseParserK_USING - 96)) | (1 << (ClickHouseParserK_WHEN - 96)) | (1 << (ClickHouseParserK_WHERE - 96)) | (1 << (ClickHouseParserK_WITH - 96)) | (1 << (ClickHouseParserLPAREN - 96)) | (1 << (ClickHouseParserSTAR - 96)))) != 0) || ((((_la - 132)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 132))) & ((1 << (ClickHouseParserMINUS - 132)) | (1 << (ClickHouseParserLBRAKET - 132)) | (1 << (ClickHouseParserT_FLOAT32 - 132)) | (1 << (ClickHouseParserT_FLOAT64 - 132)) | (1 << (ClickHouseParserT_UINT8 - 132)) | (1 << (ClickHouseParserT_UINT16 - 132)) | (1 << (ClickHouseParserT_UINT32 - 132)) | (1 << (ClickHouseParserT_UINT64 - 132)) | (1 << (ClickHouseParserT_INT8 - 132)) | (1 << (ClickHouseParserT_INT16 - 132)) | (1 << (ClickHouseParserT_INT32 - 132)) | (1 << (ClickHouseParserT_INT64 - 132)) | (1 << (ClickHouseParserT_ENUM8 - 132)) | (1 << (ClickHouseParserT_ENUM16 - 132)) | (1 << (ClickHouseParserT_UUID - 132)) | (1 << (ClickHouseParserT_DATE - 132)) | (1 << (ClickHouseParserT_DATETIME - 132)) | (1 << (ClickHouseParserT_STRING - 132)) | (1 << (ClickHouseParserT_FIXEDSTRING - 132)))) != 0) || ((((_la - 164)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 164))) & ((1 << (ClickHouseParserT_NULL - 164)) | (1 << (ClickHouseParserT_INTERVAL_YEAR - 164)) | (1 << (ClickHouseParserT_INTERVAL_MONTH - 164)) | (1 << (ClickHouseParserT_INTERVAL_WEEK - 164)) | (1 << (ClickHouseParserT_INTERVAL_DAY - 164)) | (1 << (ClickHouseParserT_INTERVAL_HOUR - 164)) | (1 << (ClickHouseParserT_INTERVAL_MINUTE - 164)) | (1 << (ClickHouseParserT_INTERVAL_SECOND - 164)) | (1 << (ClickHouseParserIDENTIFIER - 164)) | (1 << (ClickHouseParserNUMERIC_LITERAL - 164)) | (1 << (ClickHouseParserSTRING_LITERAL - 164)) | (1 << (ClickHouseParserQUOTED_LITERAL - 164)))) != 0) {
		{
			p.SetState(1121)
			p.expr(0)
		}
		p.SetState(1126)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1122)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1123)
				p.expr(0)
			}


			p.SetState(1128)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1131)
		p.Match(ClickHouseParserRPAREN)
	}



	return localctx
}


// IFunction_argumentsContext is an interface to support dynamic dispatch.
type IFunction_argumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_argumentsContext differentiates from other interfaces.
	IsFunction_argumentsContext()
}

type Function_argumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_argumentsContext() *Function_argumentsContext {
	var p = new(Function_argumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_function_arguments
	return p
}

func (*Function_argumentsContext) IsFunction_argumentsContext() {}

func NewFunction_argumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_argumentsContext {
	var p = new(Function_argumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_function_arguments

	return p
}

func (s *Function_argumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_argumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *Function_argumentsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *Function_argumentsContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *Function_argumentsContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Function_argumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *Function_argumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *Function_argumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_argumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_argumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFunction_arguments(s)
	}
}

func (s *Function_argumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFunction_arguments(s)
	}
}




func (p *ClickHouseParser) Function_arguments() (localctx IFunction_argumentsContext) {
	localctx = NewFunction_argumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ClickHouseParserRULE_function_arguments)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1133)
		p.Match(ClickHouseParserLPAREN)
	}
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ClickHouseParserK_ADD) | (1 << ClickHouseParserK_AFTER) | (1 << ClickHouseParserK_ALL) | (1 << ClickHouseParserK_ALIAS) | (1 << ClickHouseParserK_ALTER) | (1 << ClickHouseParserK_AND) | (1 << ClickHouseParserK_ANY) | (1 << ClickHouseParserK_ARRAY) | (1 << ClickHouseParserK_AS) | (1 << ClickHouseParserK_ASCENDING) | (1 << ClickHouseParserK_ASC) | (1 << ClickHouseParserK_ASYNC) | (1 << ClickHouseParserK_ATTACH) | (1 << ClickHouseParserK_BETWEEN) | (1 << ClickHouseParserK_BY) | (1 << ClickHouseParserK_CASE) | (1 << ClickHouseParserK_CAST) | (1 << ClickHouseParserK_CHECK) | (1 << ClickHouseParserK_COLUMN) | (1 << ClickHouseParserK_COLLATE) | (1 << ClickHouseParserK_CREATE) | (1 << ClickHouseParserK_CROSS) | (1 << ClickHouseParserK_DESCRIBE) | (1 << ClickHouseParserK_DESCENDING) | (1 << ClickHouseParserK_DESC) | (1 << ClickHouseParserK_DATABASE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ClickHouseParserK_DATABASES - 32)) | (1 << (ClickHouseParserK_DEFAULT - 32)) | (1 << (ClickHouseParserK_DETACH - 32)) | (1 << (ClickHouseParserK_DISTINCT - 32)) | (1 << (ClickHouseParserK_DROP - 32)) | (1 << (ClickHouseParserK_ELSE - 32)) | (1 << (ClickHouseParserK_END - 32)) | (1 << (ClickHouseParserK_ENGINE - 32)) | (1 << (ClickHouseParserK_EXISTS - 32)) | (1 << (ClickHouseParserK_FINAL - 32)) | (1 << (ClickHouseParserK_FIRST - 32)) | (1 << (ClickHouseParserK_FROM - 32)) | (1 << (ClickHouseParserK_FORMAT - 32)) | (1 << (ClickHouseParserK_FULL - 32)) | (1 << (ClickHouseParserK_GLOBAL - 32)) | (1 << (ClickHouseParserK_GROUP - 32)) | (1 << (ClickHouseParserK_HAVING - 32)) | (1 << (ClickHouseParserK_ID - 32)) | (1 << (ClickHouseParserK_IF - 32)) | (1 << (ClickHouseParserK_INNER - 32)) | (1 << (ClickHouseParserK_INSERT - 32)) | (1 << (ClickHouseParserK_INTERVAL - 32)) | (1 << (ClickHouseParserK_INTO - 32)) | (1 << (ClickHouseParserK_IN - 32)) | (1 << (ClickHouseParserK_IS - 32)) | (1 << (ClickHouseParserK_JOIN - 32)) | (1 << (ClickHouseParserK_KILL - 32)) | (1 << (ClickHouseParserK_LAST - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ClickHouseParserK_LEFT - 64)) | (1 << (ClickHouseParserK_LIKE - 64)) | (1 << (ClickHouseParserK_LIMIT - 64)) | (1 << (ClickHouseParserK_MAIN - 64)) | (1 << (ClickHouseParserK_MATERIALIZED - 64)) | (1 << (ClickHouseParserK_MODIFY - 64)) | (1 << (ClickHouseParserK_NOT - 64)) | (1 << (ClickHouseParserK_NULL - 64)) | (1 << (ClickHouseParserK_NULLS - 64)) | (1 << (ClickHouseParserK_OFFSET - 64)) | (1 << (ClickHouseParserK_ON - 64)) | (1 << (ClickHouseParserK_OPTIMIZE - 64)) | (1 << (ClickHouseParserK_ORDER - 64)) | (1 << (ClickHouseParserK_OR - 64)) | (1 << (ClickHouseParserK_OUTFILE - 64)) | (1 << (ClickHouseParserK_PARTITION - 64)) | (1 << (ClickHouseParserK_POPULATE - 64)) | (1 << (ClickHouseParserK_PREWHERE - 64)) | (1 << (ClickHouseParserK_PROCESSLIST - 64)) | (1 << (ClickHouseParserK_QUERY - 64)) | (1 << (ClickHouseParserK_RENAME - 64)) | (1 << (ClickHouseParserK_RETURN - 64)) | (1 << (ClickHouseParserK_RIGHT - 64)) | (1 << (ClickHouseParserK_SAMPLE - 64)) | (1 << (ClickHouseParserK_SELECT - 64)) | (1 << (ClickHouseParserK_SET - 64)) | (1 << (ClickHouseParserK_SETTINGS - 64)) | (1 << (ClickHouseParserK_SHOW - 64)) | (1 << (ClickHouseParserK_SYNC - 64)))) != 0) || ((((_la - 96)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 96))) & ((1 << (ClickHouseParserK_TABLE - 96)) | (1 << (ClickHouseParserK_TABLES - 96)) | (1 << (ClickHouseParserK_TEMPORARY - 96)) | (1 << (ClickHouseParserK_TEST - 96)) | (1 << (ClickHouseParserK_THEN - 96)) | (1 << (ClickHouseParserK_TOTALS - 96)) | (1 << (ClickHouseParserK_TO - 96)) | (1 << (ClickHouseParserK_OUTER - 96)) | (1 << (ClickHouseParserK_VALUES - 96)) | (1 << (ClickHouseParserK_VIEW - 96)) | (1 << (ClickHouseParserK_UNION - 96)) | (1 << (ClickHouseParserK_USE - 96)) | (1 << (ClickHouseParserK_USING - 96)) | (1 << (ClickHouseParserK_WHEN - 96)) | (1 << (ClickHouseParserK_WHERE - 96)) | (1 << (ClickHouseParserK_WITH - 96)) | (1 << (ClickHouseParserLPAREN - 96)) | (1 << (ClickHouseParserSTAR - 96)))) != 0) || ((((_la - 132)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 132))) & ((1 << (ClickHouseParserMINUS - 132)) | (1 << (ClickHouseParserLBRAKET - 132)) | (1 << (ClickHouseParserT_FLOAT32 - 132)) | (1 << (ClickHouseParserT_FLOAT64 - 132)) | (1 << (ClickHouseParserT_UINT8 - 132)) | (1 << (ClickHouseParserT_UINT16 - 132)) | (1 << (ClickHouseParserT_UINT32 - 132)) | (1 << (ClickHouseParserT_UINT64 - 132)) | (1 << (ClickHouseParserT_INT8 - 132)) | (1 << (ClickHouseParserT_INT16 - 132)) | (1 << (ClickHouseParserT_INT32 - 132)) | (1 << (ClickHouseParserT_INT64 - 132)) | (1 << (ClickHouseParserT_ENUM8 - 132)) | (1 << (ClickHouseParserT_ENUM16 - 132)) | (1 << (ClickHouseParserT_UUID - 132)) | (1 << (ClickHouseParserT_DATE - 132)) | (1 << (ClickHouseParserT_DATETIME - 132)) | (1 << (ClickHouseParserT_STRING - 132)) | (1 << (ClickHouseParserT_FIXEDSTRING - 132)))) != 0) || ((((_la - 164)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 164))) & ((1 << (ClickHouseParserT_NULL - 164)) | (1 << (ClickHouseParserT_INTERVAL_YEAR - 164)) | (1 << (ClickHouseParserT_INTERVAL_MONTH - 164)) | (1 << (ClickHouseParserT_INTERVAL_WEEK - 164)) | (1 << (ClickHouseParserT_INTERVAL_DAY - 164)) | (1 << (ClickHouseParserT_INTERVAL_HOUR - 164)) | (1 << (ClickHouseParserT_INTERVAL_MINUTE - 164)) | (1 << (ClickHouseParserT_INTERVAL_SECOND - 164)) | (1 << (ClickHouseParserIDENTIFIER - 164)) | (1 << (ClickHouseParserNUMERIC_LITERAL - 164)) | (1 << (ClickHouseParserSTRING_LITERAL - 164)) | (1 << (ClickHouseParserQUOTED_LITERAL - 164)))) != 0) {
		{
			p.SetState(1134)
			p.expr(0)
		}
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1135)
				p.Match(ClickHouseParserCOMMA)
			}
			{
				p.SetState(1136)
				p.expr(0)
			}


			p.SetState(1141)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1144)
		p.Match(ClickHouseParserRPAREN)
	}



	return localctx
}


// IFunction_nameContext is an interface to support dynamic dispatch.
type IFunction_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_nameContext differentiates from other interfaces.
	IsFunction_nameContext()
}

type Function_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_nameContext() *Function_nameContext {
	var p = new(Function_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_function_name
	return p
}

func (*Function_nameContext) IsFunction_nameContext() {}

func NewFunction_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_nameContext {
	var p = new(Function_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_function_name

	return p
}

func (s *Function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFunction_name(s)
	}
}

func (s *Function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFunction_name(s)
	}
}




func (p *ClickHouseParser) Function_name() (localctx IFunction_nameContext) {
	localctx = NewFunction_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ClickHouseParserRULE_function_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.Identifier()
	}



	return localctx
}


// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) QUOTED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUOTED_LITERAL, 0)
}

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIDENTIFIER, 0)
}

func (s *IdentifierContext) Simple_type() ISimple_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_typeContext)
}

func (s *IdentifierContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}




func (p *ClickHouseParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ClickHouseParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1152)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserQUOTED_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1148)
			p.Match(ClickHouseParserQUOTED_LITERAL)
		}


	case ClickHouseParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1149)
			p.Match(ClickHouseParserIDENTIFIER)
		}


	case ClickHouseParserT_FLOAT32, ClickHouseParserT_FLOAT64, ClickHouseParserT_UINT8, ClickHouseParserT_UINT16, ClickHouseParserT_UINT32, ClickHouseParserT_UINT64, ClickHouseParserT_INT8, ClickHouseParserT_INT16, ClickHouseParserT_INT32, ClickHouseParserT_INT64, ClickHouseParserT_ENUM8, ClickHouseParserT_ENUM16, ClickHouseParserT_UUID, ClickHouseParserT_DATE, ClickHouseParserT_DATETIME, ClickHouseParserT_STRING, ClickHouseParserT_FIXEDSTRING, ClickHouseParserT_NULL, ClickHouseParserT_INTERVAL_YEAR, ClickHouseParserT_INTERVAL_MONTH, ClickHouseParserT_INTERVAL_WEEK, ClickHouseParserT_INTERVAL_DAY, ClickHouseParserT_INTERVAL_HOUR, ClickHouseParserT_INTERVAL_MINUTE, ClickHouseParserT_INTERVAL_SECOND:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1150)
			p.Simple_type()
		}


	case ClickHouseParserK_ADD, ClickHouseParserK_AFTER, ClickHouseParserK_ALL, ClickHouseParserK_ALIAS, ClickHouseParserK_ALTER, ClickHouseParserK_AND, ClickHouseParserK_ANY, ClickHouseParserK_ARRAY, ClickHouseParserK_AS, ClickHouseParserK_ASCENDING, ClickHouseParserK_ASC, ClickHouseParserK_ASYNC, ClickHouseParserK_ATTACH, ClickHouseParserK_BETWEEN, ClickHouseParserK_BY, ClickHouseParserK_CASE, ClickHouseParserK_CHECK, ClickHouseParserK_COLUMN, ClickHouseParserK_COLLATE, ClickHouseParserK_CREATE, ClickHouseParserK_CROSS, ClickHouseParserK_DESCRIBE, ClickHouseParserK_DESCENDING, ClickHouseParserK_DESC, ClickHouseParserK_DATABASE, ClickHouseParserK_DATABASES, ClickHouseParserK_DEFAULT, ClickHouseParserK_DETACH, ClickHouseParserK_DISTINCT, ClickHouseParserK_DROP, ClickHouseParserK_ELSE, ClickHouseParserK_END, ClickHouseParserK_ENGINE, ClickHouseParserK_EXISTS, ClickHouseParserK_FINAL, ClickHouseParserK_FIRST, ClickHouseParserK_FROM, ClickHouseParserK_FORMAT, ClickHouseParserK_FULL, ClickHouseParserK_GLOBAL, ClickHouseParserK_GROUP, ClickHouseParserK_HAVING, ClickHouseParserK_ID, ClickHouseParserK_IF, ClickHouseParserK_INNER, ClickHouseParserK_INSERT, ClickHouseParserK_INTO, ClickHouseParserK_IN, ClickHouseParserK_IS, ClickHouseParserK_JOIN, ClickHouseParserK_KILL, ClickHouseParserK_LAST, ClickHouseParserK_LEFT, ClickHouseParserK_LIKE, ClickHouseParserK_LIMIT, ClickHouseParserK_MAIN, ClickHouseParserK_MATERIALIZED, ClickHouseParserK_MODIFY, ClickHouseParserK_NOT, ClickHouseParserK_NULL, ClickHouseParserK_NULLS, ClickHouseParserK_OFFSET, ClickHouseParserK_ON, ClickHouseParserK_OPTIMIZE, ClickHouseParserK_ORDER, ClickHouseParserK_OR, ClickHouseParserK_OUTFILE, ClickHouseParserK_PARTITION, ClickHouseParserK_POPULATE, ClickHouseParserK_PREWHERE, ClickHouseParserK_PROCESSLIST, ClickHouseParserK_QUERY, ClickHouseParserK_RENAME, ClickHouseParserK_RETURN, ClickHouseParserK_RIGHT, ClickHouseParserK_SAMPLE, ClickHouseParserK_SELECT, ClickHouseParserK_SET, ClickHouseParserK_SETTINGS, ClickHouseParserK_SHOW, ClickHouseParserK_SYNC, ClickHouseParserK_TABLE, ClickHouseParserK_TABLES, ClickHouseParserK_TEMPORARY, ClickHouseParserK_TEST, ClickHouseParserK_THEN, ClickHouseParserK_TOTALS, ClickHouseParserK_TO, ClickHouseParserK_OUTER, ClickHouseParserK_VALUES, ClickHouseParserK_VIEW, ClickHouseParserK_UNION, ClickHouseParserK_USE, ClickHouseParserK_USING, ClickHouseParserK_WHEN, ClickHouseParserK_WHERE, ClickHouseParserK_WITH:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1151)
			p.Keyword()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) K_ADD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ADD, 0)
}

func (s *KeywordContext) K_AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AFTER, 0)
}

func (s *KeywordContext) K_ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ALL, 0)
}

func (s *KeywordContext) K_ALIAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ALIAS, 0)
}

func (s *KeywordContext) K_ALTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ALTER, 0)
}

func (s *KeywordContext) K_AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AND, 0)
}

func (s *KeywordContext) K_ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ANY, 0)
}

func (s *KeywordContext) K_ARRAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ARRAY, 0)
}

func (s *KeywordContext) K_AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_AS, 0)
}

func (s *KeywordContext) K_ASCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ASCENDING, 0)
}

func (s *KeywordContext) K_ASC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ASC, 0)
}

func (s *KeywordContext) K_ASYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ASYNC, 0)
}

func (s *KeywordContext) K_ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ATTACH, 0)
}

func (s *KeywordContext) K_BETWEEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_BETWEEN, 0)
}

func (s *KeywordContext) K_BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_BY, 0)
}

func (s *KeywordContext) K_CASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CASE, 0)
}

func (s *KeywordContext) K_CHECK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CHECK, 0)
}

func (s *KeywordContext) K_COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_COLUMN, 0)
}

func (s *KeywordContext) K_COLLATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_COLLATE, 0)
}

func (s *KeywordContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CREATE, 0)
}

func (s *KeywordContext) K_CROSS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_CROSS, 0)
}

func (s *KeywordContext) K_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DESCRIBE, 0)
}

func (s *KeywordContext) K_DESCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DESCENDING, 0)
}

func (s *KeywordContext) K_DESC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DESC, 0)
}

func (s *KeywordContext) K_DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DATABASE, 0)
}

func (s *KeywordContext) K_DATABASES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DATABASES, 0)
}

func (s *KeywordContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DEFAULT, 0)
}

func (s *KeywordContext) K_DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DETACH, 0)
}

func (s *KeywordContext) K_DISTINCT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DISTINCT, 0)
}

func (s *KeywordContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_DROP, 0)
}

func (s *KeywordContext) K_ENGINE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ENGINE, 0)
}

func (s *KeywordContext) K_ELSE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ELSE, 0)
}

func (s *KeywordContext) K_END() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_END, 0)
}

func (s *KeywordContext) K_EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_EXISTS, 0)
}

func (s *KeywordContext) K_FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FINAL, 0)
}

func (s *KeywordContext) K_FIRST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FIRST, 0)
}

func (s *KeywordContext) K_FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FROM, 0)
}

func (s *KeywordContext) K_FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FORMAT, 0)
}

func (s *KeywordContext) K_FULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_FULL, 0)
}

func (s *KeywordContext) K_GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_GLOBAL, 0)
}

func (s *KeywordContext) K_GROUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_GROUP, 0)
}

func (s *KeywordContext) K_HAVING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_HAVING, 0)
}

func (s *KeywordContext) K_ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ID, 0)
}

func (s *KeywordContext) K_IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_IF, 0)
}

func (s *KeywordContext) K_INNER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_INNER, 0)
}

func (s *KeywordContext) K_INSERT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_INSERT, 0)
}

func (s *KeywordContext) K_INTO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_INTO, 0)
}

func (s *KeywordContext) K_IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_IN, 0)
}

func (s *KeywordContext) K_IS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_IS, 0)
}

func (s *KeywordContext) K_JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_JOIN, 0)
}

func (s *KeywordContext) K_KILL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_KILL, 0)
}

func (s *KeywordContext) K_LAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LAST, 0)
}

func (s *KeywordContext) K_LEFT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LEFT, 0)
}

func (s *KeywordContext) K_LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LIKE, 0)
}

func (s *KeywordContext) K_LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_LIMIT, 0)
}

func (s *KeywordContext) K_MAIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_MAIN, 0)
}

func (s *KeywordContext) K_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_MATERIALIZED, 0)
}

func (s *KeywordContext) K_MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_MODIFY, 0)
}

func (s *KeywordContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NOT, 0)
}

func (s *KeywordContext) K_NULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NULL, 0)
}

func (s *KeywordContext) K_NULLS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NULLS, 0)
}

func (s *KeywordContext) K_OFFSET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OFFSET, 0)
}

func (s *KeywordContext) K_ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ON, 0)
}

func (s *KeywordContext) K_OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OPTIMIZE, 0)
}

func (s *KeywordContext) K_ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_ORDER, 0)
}

func (s *KeywordContext) K_OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OR, 0)
}

func (s *KeywordContext) K_OUTFILE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OUTFILE, 0)
}

func (s *KeywordContext) K_PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_PARTITION, 0)
}

func (s *KeywordContext) K_POPULATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_POPULATE, 0)
}

func (s *KeywordContext) K_PREWHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_PREWHERE, 0)
}

func (s *KeywordContext) K_PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_PROCESSLIST, 0)
}

func (s *KeywordContext) K_QUERY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_QUERY, 0)
}

func (s *KeywordContext) K_RENAME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_RENAME, 0)
}

func (s *KeywordContext) K_RETURN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_RETURN, 0)
}

func (s *KeywordContext) K_RIGHT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_RIGHT, 0)
}

func (s *KeywordContext) K_SAMPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SAMPLE, 0)
}

func (s *KeywordContext) K_SELECT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SELECT, 0)
}

func (s *KeywordContext) K_SET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SET, 0)
}

func (s *KeywordContext) K_SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SETTINGS, 0)
}

func (s *KeywordContext) K_SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SHOW, 0)
}

func (s *KeywordContext) K_SYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_SYNC, 0)
}

func (s *KeywordContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLE, 0)
}

func (s *KeywordContext) K_TABLES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TABLES, 0)
}

func (s *KeywordContext) K_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TEMPORARY, 0)
}

func (s *KeywordContext) K_TEST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TEST, 0)
}

func (s *KeywordContext) K_THEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_THEN, 0)
}

func (s *KeywordContext) K_TOTALS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TOTALS, 0)
}

func (s *KeywordContext) K_TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_TO, 0)
}

func (s *KeywordContext) K_OUTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_OUTER, 0)
}

func (s *KeywordContext) K_VALUES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_VALUES, 0)
}

func (s *KeywordContext) K_VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_VIEW, 0)
}

func (s *KeywordContext) K_UNION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_UNION, 0)
}

func (s *KeywordContext) K_USE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_USE, 0)
}

func (s *KeywordContext) K_USING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_USING, 0)
}

func (s *KeywordContext) K_WHEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_WHEN, 0)
}

func (s *KeywordContext) K_WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_WHERE, 0)
}

func (s *KeywordContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_WITH, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}




func (p *ClickHouseParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ClickHouseParserRULE_keyword)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1154)
	_la = p.GetTokenStream().LA(1)

	if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ClickHouseParserK_ADD) | (1 << ClickHouseParserK_AFTER) | (1 << ClickHouseParserK_ALL) | (1 << ClickHouseParserK_ALIAS) | (1 << ClickHouseParserK_ALTER) | (1 << ClickHouseParserK_AND) | (1 << ClickHouseParserK_ANY) | (1 << ClickHouseParserK_ARRAY) | (1 << ClickHouseParserK_AS) | (1 << ClickHouseParserK_ASCENDING) | (1 << ClickHouseParserK_ASC) | (1 << ClickHouseParserK_ASYNC) | (1 << ClickHouseParserK_ATTACH) | (1 << ClickHouseParserK_BETWEEN) | (1 << ClickHouseParserK_BY) | (1 << ClickHouseParserK_CASE) | (1 << ClickHouseParserK_CHECK) | (1 << ClickHouseParserK_COLUMN) | (1 << ClickHouseParserK_COLLATE) | (1 << ClickHouseParserK_CREATE) | (1 << ClickHouseParserK_CROSS) | (1 << ClickHouseParserK_DESCRIBE) | (1 << ClickHouseParserK_DESCENDING) | (1 << ClickHouseParserK_DESC) | (1 << ClickHouseParserK_DATABASE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ClickHouseParserK_DATABASES - 32)) | (1 << (ClickHouseParserK_DEFAULT - 32)) | (1 << (ClickHouseParserK_DETACH - 32)) | (1 << (ClickHouseParserK_DISTINCT - 32)) | (1 << (ClickHouseParserK_DROP - 32)) | (1 << (ClickHouseParserK_ELSE - 32)) | (1 << (ClickHouseParserK_END - 32)) | (1 << (ClickHouseParserK_ENGINE - 32)) | (1 << (ClickHouseParserK_EXISTS - 32)) | (1 << (ClickHouseParserK_FINAL - 32)) | (1 << (ClickHouseParserK_FIRST - 32)) | (1 << (ClickHouseParserK_FROM - 32)) | (1 << (ClickHouseParserK_FORMAT - 32)) | (1 << (ClickHouseParserK_FULL - 32)) | (1 << (ClickHouseParserK_GLOBAL - 32)) | (1 << (ClickHouseParserK_GROUP - 32)) | (1 << (ClickHouseParserK_HAVING - 32)) | (1 << (ClickHouseParserK_ID - 32)) | (1 << (ClickHouseParserK_IF - 32)) | (1 << (ClickHouseParserK_INNER - 32)) | (1 << (ClickHouseParserK_INSERT - 32)) | (1 << (ClickHouseParserK_INTO - 32)) | (1 << (ClickHouseParserK_IN - 32)) | (1 << (ClickHouseParserK_IS - 32)) | (1 << (ClickHouseParserK_JOIN - 32)) | (1 << (ClickHouseParserK_KILL - 32)) | (1 << (ClickHouseParserK_LAST - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ClickHouseParserK_LEFT - 64)) | (1 << (ClickHouseParserK_LIKE - 64)) | (1 << (ClickHouseParserK_LIMIT - 64)) | (1 << (ClickHouseParserK_MAIN - 64)) | (1 << (ClickHouseParserK_MATERIALIZED - 64)) | (1 << (ClickHouseParserK_MODIFY - 64)) | (1 << (ClickHouseParserK_NOT - 64)) | (1 << (ClickHouseParserK_NULL - 64)) | (1 << (ClickHouseParserK_NULLS - 64)) | (1 << (ClickHouseParserK_OFFSET - 64)) | (1 << (ClickHouseParserK_ON - 64)) | (1 << (ClickHouseParserK_OPTIMIZE - 64)) | (1 << (ClickHouseParserK_ORDER - 64)) | (1 << (ClickHouseParserK_OR - 64)) | (1 << (ClickHouseParserK_OUTFILE - 64)) | (1 << (ClickHouseParserK_PARTITION - 64)) | (1 << (ClickHouseParserK_POPULATE - 64)) | (1 << (ClickHouseParserK_PREWHERE - 64)) | (1 << (ClickHouseParserK_PROCESSLIST - 64)) | (1 << (ClickHouseParserK_QUERY - 64)) | (1 << (ClickHouseParserK_RENAME - 64)) | (1 << (ClickHouseParserK_RETURN - 64)) | (1 << (ClickHouseParserK_RIGHT - 64)) | (1 << (ClickHouseParserK_SAMPLE - 64)) | (1 << (ClickHouseParserK_SELECT - 64)) | (1 << (ClickHouseParserK_SET - 64)) | (1 << (ClickHouseParserK_SETTINGS - 64)) | (1 << (ClickHouseParserK_SHOW - 64)) | (1 << (ClickHouseParserK_SYNC - 64)))) != 0) || ((((_la - 96)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 96))) & ((1 << (ClickHouseParserK_TABLE - 96)) | (1 << (ClickHouseParserK_TABLES - 96)) | (1 << (ClickHouseParserK_TEMPORARY - 96)) | (1 << (ClickHouseParserK_TEST - 96)) | (1 << (ClickHouseParserK_THEN - 96)) | (1 << (ClickHouseParserK_TOTALS - 96)) | (1 << (ClickHouseParserK_TO - 96)) | (1 << (ClickHouseParserK_OUTER - 96)) | (1 << (ClickHouseParserK_VALUES - 96)) | (1 << (ClickHouseParserK_VIEW - 96)) | (1 << (ClickHouseParserK_UNION - 96)) | (1 << (ClickHouseParserK_USE - 96)) | (1 << (ClickHouseParserK_USING - 96)) | (1 << (ClickHouseParserK_WHEN - 96)) | (1 << (ClickHouseParserK_WHERE - 96)) | (1 << (ClickHouseParserK_WITH - 96)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// ICompound_identifierContext is an interface to support dynamic dispatch.
type ICompound_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_identifierContext differentiates from other interfaces.
	IsCompound_identifierContext()
}

type Compound_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_identifierContext() *Compound_identifierContext {
	var p = new(Compound_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_compound_identifier
	return p
}

func (*Compound_identifierContext) IsCompound_identifierContext() {}

func NewCompound_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_identifierContext {
	var p = new(Compound_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_compound_identifier

	return p
}

func (s *Compound_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_identifierContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Compound_identifierContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Compound_identifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *Compound_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Compound_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCompound_identifier(s)
	}
}

func (s *Compound_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCompound_identifier(s)
	}
}




func (p *ClickHouseParser) Compound_identifier() (localctx ICompound_identifierContext) {
	localctx = NewCompound_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ClickHouseParserRULE_compound_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1156)
			p.Identifier()
		}
		{
			p.SetState(1157)
			p.Match(ClickHouseParserDOT)
		}
		{
			p.SetState(1158)
			p.Identifier()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1160)
			p.Identifier()
		}

	}


	return localctx
}


// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) K_NULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserK_NULL, 0)
}

func (s *LiteralContext) NUMERIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNUMERIC_LITERAL, 0)
}

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}




func (p *ClickHouseParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ClickHouseParserRULE_literal)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1163)
	_la = p.GetTokenStream().LA(1)

	if !(_la == ClickHouseParserK_NULL || _la == ClickHouseParserNUMERIC_LITERAL || _la == ClickHouseParserSTRING_LITERAL) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IErrContext is an interface to support dynamic dispatch.
type IErrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_UNEXPECTED_CHAR returns the _UNEXPECTED_CHAR token.
	Get_UNEXPECTED_CHAR() antlr.Token 


	// Set_UNEXPECTED_CHAR sets the _UNEXPECTED_CHAR token.
	Set_UNEXPECTED_CHAR(antlr.Token) 


	// IsErrContext differentiates from other interfaces.
	IsErrContext()
}

type ErrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	_UNEXPECTED_CHAR antlr.Token
}

func NewEmptyErrContext() *ErrContext {
	var p = new(ErrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ClickHouseParserRULE_err
	return p
}

func (*ErrContext) IsErrContext() {}

func NewErrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrContext {
	var p = new(ErrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_err

	return p
}

func (s *ErrContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrContext) Get_UNEXPECTED_CHAR() antlr.Token { return s._UNEXPECTED_CHAR }


func (s *ErrContext) Set_UNEXPECTED_CHAR(v antlr.Token) { s._UNEXPECTED_CHAR = v }


func (s *ErrContext) UNEXPECTED_CHAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUNEXPECTED_CHAR, 0)
}

func (s *ErrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ErrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterErr(s)
	}
}

func (s *ErrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitErr(s)
	}
}




func (p *ClickHouseParser) Err() (localctx IErrContext) {
	localctx = NewErrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ClickHouseParserRULE_err)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1165)

		var _m = p.Match(ClickHouseParserUNEXPECTED_CHAR)

		localctx.(*ErrContext)._UNEXPECTED_CHAR = _m
	}

	panic(localctx.(*ErrContext).Get_UNEXPECTED_CHAR().GetText())
	//throw new RuntimeException("UNEXPECTED_CHAR=" + (func() string { if localctx.(*ErrContext).Get_UNEXPECTED_CHAR() == nil { return "" } else { return localctx.(*ErrContext).Get_UNEXPECTED_CHAR().GetText() }}()));
	   



	return localctx
}


func (p *ClickHouseParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 72:
			var t *ExprContext = nil
			if localctx != nil { t = localctx.(*ExprContext) }
			return p.Expr_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ClickHouseParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return p.Precpred(p.GetParserRuleContext(), 24)

	case 1:
			return p.Precpred(p.GetParserRuleContext(), 20)

	case 2:
			return p.Precpred(p.GetParserRuleContext(), 19)

	case 3:
			return p.Precpred(p.GetParserRuleContext(), 18)

	case 4:
			return p.Precpred(p.GetParserRuleContext(), 17)

	case 5:
			return p.Precpred(p.GetParserRuleContext(), 16)

	case 6:
			return p.Precpred(p.GetParserRuleContext(), 15)

	case 7:
			return p.Precpred(p.GetParserRuleContext(), 11)

	case 8:
			return p.Precpred(p.GetParserRuleContext(), 10)

	case 9:
			return p.Precpred(p.GetParserRuleContext(), 9)

	case 10:
			return p.Precpred(p.GetParserRuleContext(), 23)

	case 11:
			return p.Precpred(p.GetParserRuleContext(), 14)

	case 12:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}


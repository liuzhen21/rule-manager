// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RulesClient is the client API for Rules service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RulesClient interface {
	RuleCreate(ctx context.Context, in *RuleCreateReq, opts ...grpc.CallOption) (*RuleCreateResp, error)
	RuleUpdate(ctx context.Context, in *RuleUpdateReq, opts ...grpc.CallOption) (*RuleUpdateResp, error)
	RuleDelete(ctx context.Context, in *RuleDeleteReq, opts ...grpc.CallOption) (*RuleDeleteResp, error)
	RuleGet(ctx context.Context, in *RuleGetReq, opts ...grpc.CallOption) (*Rule, error)
	RuleQuery(ctx context.Context, in *RuleQueryReq, opts ...grpc.CallOption) (*RuleQueryResp, error)
	RuleStatus(ctx context.Context, in *RuleStatusReq, opts ...grpc.CallOption) (*RuleStatusResp, error)
	RuleStart(ctx context.Context, in *RuleStartReq, opts ...grpc.CallOption) (*RuleStartResp, error)
	RuleStop(ctx context.Context, in *RuleStopReq, opts ...grpc.CallOption) (*RuleStopResp, error)
	RuleDebug(ctx context.Context, in *RuleDebugReq, opts ...grpc.CallOption) (*RuleDebugResp, error)
	RuleDebugMessage(ctx context.Context, in *RuleDebugMsgReq, opts ...grpc.CallOption) (*RuleDebugMsgResp, error)
	RuleError(ctx context.Context, in *RuleErrorReq, opts ...grpc.CallOption) (*RuleErrorResp, error)
}

type rulesClient struct {
	cc grpc.ClientConnInterface
}

func NewRulesClient(cc grpc.ClientConnInterface) RulesClient {
	return &rulesClient{cc}
}

func (c *rulesClient) RuleCreate(ctx context.Context, in *RuleCreateReq, opts ...grpc.CallOption) (*RuleCreateResp, error) {
	out := new(RuleCreateResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleUpdate(ctx context.Context, in *RuleUpdateReq, opts ...grpc.CallOption) (*RuleUpdateResp, error) {
	out := new(RuleUpdateResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleDelete(ctx context.Context, in *RuleDeleteReq, opts ...grpc.CallOption) (*RuleDeleteResp, error) {
	out := new(RuleDeleteResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleGet(ctx context.Context, in *RuleGetReq, opts ...grpc.CallOption) (*Rule, error) {
	out := new(Rule)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleQuery(ctx context.Context, in *RuleQueryReq, opts ...grpc.CallOption) (*RuleQueryResp, error) {
	out := new(RuleQueryResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleStatus(ctx context.Context, in *RuleStatusReq, opts ...grpc.CallOption) (*RuleStatusResp, error) {
	out := new(RuleStatusResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleStart(ctx context.Context, in *RuleStartReq, opts ...grpc.CallOption) (*RuleStartResp, error) {
	out := new(RuleStartResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleStop(ctx context.Context, in *RuleStopReq, opts ...grpc.CallOption) (*RuleStopResp, error) {
	out := new(RuleStopResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleDebug(ctx context.Context, in *RuleDebugReq, opts ...grpc.CallOption) (*RuleDebugResp, error) {
	out := new(RuleDebugResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleDebug", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleDebugMessage(ctx context.Context, in *RuleDebugMsgReq, opts ...grpc.CallOption) (*RuleDebugMsgResp, error) {
	out := new(RuleDebugMsgResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleDebugMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleError(ctx context.Context, in *RuleErrorReq, opts ...grpc.CallOption) (*RuleErrorResp, error) {
	out := new(RuleErrorResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleError", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RulesServer is the server API for Rules service.
// All implementations must embed UnimplementedRulesServer
// for forward compatibility
type RulesServer interface {
	RuleCreate(context.Context, *RuleCreateReq) (*RuleCreateResp, error)
	RuleUpdate(context.Context, *RuleUpdateReq) (*RuleUpdateResp, error)
	RuleDelete(context.Context, *RuleDeleteReq) (*RuleDeleteResp, error)
	RuleGet(context.Context, *RuleGetReq) (*Rule, error)
	RuleQuery(context.Context, *RuleQueryReq) (*RuleQueryResp, error)
	RuleStatus(context.Context, *RuleStatusReq) (*RuleStatusResp, error)
	RuleStart(context.Context, *RuleStartReq) (*RuleStartResp, error)
	RuleStop(context.Context, *RuleStopReq) (*RuleStopResp, error)
	RuleDebug(context.Context, *RuleDebugReq) (*RuleDebugResp, error)
	RuleDebugMessage(context.Context, *RuleDebugMsgReq) (*RuleDebugMsgResp, error)
	RuleError(context.Context, *RuleErrorReq) (*RuleErrorResp, error)
	mustEmbedUnimplementedRulesServer()
}

// UnimplementedRulesServer must be embedded to have forward compatible implementations.
type UnimplementedRulesServer struct {
}

func (UnimplementedRulesServer) RuleCreate(context.Context, *RuleCreateReq) (*RuleCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleCreate not implemented")
}
func (UnimplementedRulesServer) RuleUpdate(context.Context, *RuleUpdateReq) (*RuleUpdateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleUpdate not implemented")
}
func (UnimplementedRulesServer) RuleDelete(context.Context, *RuleDeleteReq) (*RuleDeleteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleDelete not implemented")
}
func (UnimplementedRulesServer) RuleGet(context.Context, *RuleGetReq) (*Rule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleGet not implemented")
}
func (UnimplementedRulesServer) RuleQuery(context.Context, *RuleQueryReq) (*RuleQueryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleQuery not implemented")
}
func (UnimplementedRulesServer) RuleStatus(context.Context, *RuleStatusReq) (*RuleStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleStatus not implemented")
}
func (UnimplementedRulesServer) RuleStart(context.Context, *RuleStartReq) (*RuleStartResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleStart not implemented")
}
func (UnimplementedRulesServer) RuleStop(context.Context, *RuleStopReq) (*RuleStopResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleStop not implemented")
}
func (UnimplementedRulesServer) RuleDebug(context.Context, *RuleDebugReq) (*RuleDebugResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleDebug not implemented")
}
func (UnimplementedRulesServer) RuleDebugMessage(context.Context, *RuleDebugMsgReq) (*RuleDebugMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleDebugMessage not implemented")
}
func (UnimplementedRulesServer) RuleError(context.Context, *RuleErrorReq) (*RuleErrorResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleError not implemented")
}
func (UnimplementedRulesServer) mustEmbedUnimplementedRulesServer() {}

// UnsafeRulesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RulesServer will
// result in compilation errors.
type UnsafeRulesServer interface {
	mustEmbedUnimplementedRulesServer()
}

func RegisterRulesServer(s grpc.ServiceRegistrar, srv RulesServer) {
	s.RegisterService(&Rules_ServiceDesc, srv)
}

func _Rules_RuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleCreate(ctx, req.(*RuleCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleUpdate(ctx, req.(*RuleUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleDelete(ctx, req.(*RuleDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleGet(ctx, req.(*RuleGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleQuery(ctx, req.(*RuleQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleStatus(ctx, req.(*RuleStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleStartReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleStart(ctx, req.(*RuleStartReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleStopReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleStop(ctx, req.(*RuleStopReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleDebug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleDebugReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleDebug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleDebug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleDebug(ctx, req.(*RuleDebugReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleDebugMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleDebugMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleDebugMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleDebugMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleDebugMessage(ctx, req.(*RuleDebugMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleErrorReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleError(ctx, req.(*RuleErrorReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Rules_ServiceDesc is the grpc.ServiceDesc for Rules service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Rules_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.rule.Rules",
	HandlerType: (*RulesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RuleCreate",
			Handler:    _Rules_RuleCreate_Handler,
		},
		{
			MethodName: "RuleUpdate",
			Handler:    _Rules_RuleUpdate_Handler,
		},
		{
			MethodName: "RuleDelete",
			Handler:    _Rules_RuleDelete_Handler,
		},
		{
			MethodName: "RuleGet",
			Handler:    _Rules_RuleGet_Handler,
		},
		{
			MethodName: "RuleQuery",
			Handler:    _Rules_RuleQuery_Handler,
		},
		{
			MethodName: "RuleStatus",
			Handler:    _Rules_RuleStatus_Handler,
		},
		{
			MethodName: "RuleStart",
			Handler:    _Rules_RuleStart_Handler,
		},
		{
			MethodName: "RuleStop",
			Handler:    _Rules_RuleStop_Handler,
		},
		{
			MethodName: "RuleDebug",
			Handler:    _Rules_RuleDebug_Handler,
		},
		{
			MethodName: "RuleDebugMessage",
			Handler:    _Rules_RuleDebugMessage_Handler,
		},
		{
			MethodName: "RuleError",
			Handler:    _Rules_RuleError_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/rule/v1/dto_rule.proto",
}

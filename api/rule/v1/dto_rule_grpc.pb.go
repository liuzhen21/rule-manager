// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RulesClient is the client API for Rules service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RulesClient interface {
	RuleCreate(ctx context.Context, in *RuleCreateReq, opts ...grpc.CallOption) (*RuleCreateResp, error)
	RuleUpdate(ctx context.Context, in *RuleUpdateReq, opts ...grpc.CallOption) (*RuleUpdateResp, error)
	RuleDelete(ctx context.Context, in *RuleDeleteReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RuleGet(ctx context.Context, in *RuleGetReq, opts ...grpc.CallOption) (*Rule, error)
	RuleQuery(ctx context.Context, in *RuleQueryReq, opts ...grpc.CallOption) (*RuleQueryResp, error)
	RuleStatusSwitch(ctx context.Context, in *RuleStatusSwitchReq, opts ...grpc.CallOption) (*RuleStatusSwitchResp, error)
	GetRuleDevicesID(ctx context.Context, in *RuleDevicesIDReq, opts ...grpc.CallOption) (*RuleDevicesIDResp, error)
	AddDevicesToRule(ctx context.Context, in *AddDevicesToRuleReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveDevicesFromRule(ctx context.Context, in *RemoveDevicesFromRuleReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetRuleDevices(ctx context.Context, in *RuleDevicesReq, opts ...grpc.CallOption) (*RuleDevicesResp, error)
	CreateRuleTarget(ctx context.Context, in *CreateRuleTargetReq, opts ...grpc.CallOption) (*CreateRuleTargetResp, error)
	UpdateRuleTarget(ctx context.Context, in *UpdateRuleTargetReq, opts ...grpc.CallOption) (*UpdateRuleTargetResp, error)
	TestConnectToKafka(ctx context.Context, in *TestConnectToKafkaReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListRuleTarget(ctx context.Context, in *ListRuleTargetReq, opts ...grpc.CallOption) (*ListRuleTargetResp, error)
	DeleteRuleTarget(ctx context.Context, in *DeleteRuleTargetReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ErrSubscribe(ctx context.Context, in *ErrSubscribeReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type rulesClient struct {
	cc grpc.ClientConnInterface
}

func NewRulesClient(cc grpc.ClientConnInterface) RulesClient {
	return &rulesClient{cc}
}

func (c *rulesClient) RuleCreate(ctx context.Context, in *RuleCreateReq, opts ...grpc.CallOption) (*RuleCreateResp, error) {
	out := new(RuleCreateResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleUpdate(ctx context.Context, in *RuleUpdateReq, opts ...grpc.CallOption) (*RuleUpdateResp, error) {
	out := new(RuleUpdateResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleDelete(ctx context.Context, in *RuleDeleteReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleGet(ctx context.Context, in *RuleGetReq, opts ...grpc.CallOption) (*Rule, error) {
	out := new(Rule)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleQuery(ctx context.Context, in *RuleQueryReq, opts ...grpc.CallOption) (*RuleQueryResp, error) {
	out := new(RuleQueryResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RuleStatusSwitch(ctx context.Context, in *RuleStatusSwitchReq, opts ...grpc.CallOption) (*RuleStatusSwitchResp, error) {
	out := new(RuleStatusSwitchResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RuleStatusSwitch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) GetRuleDevicesID(ctx context.Context, in *RuleDevicesIDReq, opts ...grpc.CallOption) (*RuleDevicesIDResp, error) {
	out := new(RuleDevicesIDResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/GetRuleDevicesID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) AddDevicesToRule(ctx context.Context, in *AddDevicesToRuleReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/AddDevicesToRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) RemoveDevicesFromRule(ctx context.Context, in *RemoveDevicesFromRuleReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/RemoveDevicesFromRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) GetRuleDevices(ctx context.Context, in *RuleDevicesReq, opts ...grpc.CallOption) (*RuleDevicesResp, error) {
	out := new(RuleDevicesResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/GetRuleDevices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) CreateRuleTarget(ctx context.Context, in *CreateRuleTargetReq, opts ...grpc.CallOption) (*CreateRuleTargetResp, error) {
	out := new(CreateRuleTargetResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/CreateRuleTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) UpdateRuleTarget(ctx context.Context, in *UpdateRuleTargetReq, opts ...grpc.CallOption) (*UpdateRuleTargetResp, error) {
	out := new(UpdateRuleTargetResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/UpdateRuleTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) TestConnectToKafka(ctx context.Context, in *TestConnectToKafkaReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/TestConnectToKafka", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) ListRuleTarget(ctx context.Context, in *ListRuleTargetReq, opts ...grpc.CallOption) (*ListRuleTargetResp, error) {
	out := new(ListRuleTargetResp)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/ListRuleTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) DeleteRuleTarget(ctx context.Context, in *DeleteRuleTargetReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/DeleteRuleTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) ErrSubscribe(ctx context.Context, in *ErrSubscribeReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.rule.Rules/ErrSubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RulesServer is the server API for Rules service.
// All implementations must embed UnimplementedRulesServer
// for forward compatibility
type RulesServer interface {
	RuleCreate(context.Context, *RuleCreateReq) (*RuleCreateResp, error)
	RuleUpdate(context.Context, *RuleUpdateReq) (*RuleUpdateResp, error)
	RuleDelete(context.Context, *RuleDeleteReq) (*emptypb.Empty, error)
	RuleGet(context.Context, *RuleGetReq) (*Rule, error)
	RuleQuery(context.Context, *RuleQueryReq) (*RuleQueryResp, error)
	RuleStatusSwitch(context.Context, *RuleStatusSwitchReq) (*RuleStatusSwitchResp, error)
	GetRuleDevicesID(context.Context, *RuleDevicesIDReq) (*RuleDevicesIDResp, error)
	AddDevicesToRule(context.Context, *AddDevicesToRuleReq) (*emptypb.Empty, error)
	RemoveDevicesFromRule(context.Context, *RemoveDevicesFromRuleReq) (*emptypb.Empty, error)
	GetRuleDevices(context.Context, *RuleDevicesReq) (*RuleDevicesResp, error)
	CreateRuleTarget(context.Context, *CreateRuleTargetReq) (*CreateRuleTargetResp, error)
	UpdateRuleTarget(context.Context, *UpdateRuleTargetReq) (*UpdateRuleTargetResp, error)
	TestConnectToKafka(context.Context, *TestConnectToKafkaReq) (*emptypb.Empty, error)
	ListRuleTarget(context.Context, *ListRuleTargetReq) (*ListRuleTargetResp, error)
	DeleteRuleTarget(context.Context, *DeleteRuleTargetReq) (*emptypb.Empty, error)
	ErrSubscribe(context.Context, *ErrSubscribeReq) (*emptypb.Empty, error)
	mustEmbedUnimplementedRulesServer()
}

// UnimplementedRulesServer must be embedded to have forward compatible implementations.
type UnimplementedRulesServer struct {
}

func (UnimplementedRulesServer) RuleCreate(context.Context, *RuleCreateReq) (*RuleCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleCreate not implemented")
}
func (UnimplementedRulesServer) RuleUpdate(context.Context, *RuleUpdateReq) (*RuleUpdateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleUpdate not implemented")
}
func (UnimplementedRulesServer) RuleDelete(context.Context, *RuleDeleteReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleDelete not implemented")
}
func (UnimplementedRulesServer) RuleGet(context.Context, *RuleGetReq) (*Rule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleGet not implemented")
}
func (UnimplementedRulesServer) RuleQuery(context.Context, *RuleQueryReq) (*RuleQueryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleQuery not implemented")
}
func (UnimplementedRulesServer) RuleStatusSwitch(context.Context, *RuleStatusSwitchReq) (*RuleStatusSwitchResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuleStatusSwitch not implemented")
}
func (UnimplementedRulesServer) GetRuleDevicesID(context.Context, *RuleDevicesIDReq) (*RuleDevicesIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRuleDevicesID not implemented")
}
func (UnimplementedRulesServer) AddDevicesToRule(context.Context, *AddDevicesToRuleReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDevicesToRule not implemented")
}
func (UnimplementedRulesServer) RemoveDevicesFromRule(context.Context, *RemoveDevicesFromRuleReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveDevicesFromRule not implemented")
}
func (UnimplementedRulesServer) GetRuleDevices(context.Context, *RuleDevicesReq) (*RuleDevicesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRuleDevices not implemented")
}
func (UnimplementedRulesServer) CreateRuleTarget(context.Context, *CreateRuleTargetReq) (*CreateRuleTargetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRuleTarget not implemented")
}
func (UnimplementedRulesServer) UpdateRuleTarget(context.Context, *UpdateRuleTargetReq) (*UpdateRuleTargetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRuleTarget not implemented")
}
func (UnimplementedRulesServer) TestConnectToKafka(context.Context, *TestConnectToKafkaReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestConnectToKafka not implemented")
}
func (UnimplementedRulesServer) ListRuleTarget(context.Context, *ListRuleTargetReq) (*ListRuleTargetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRuleTarget not implemented")
}
func (UnimplementedRulesServer) DeleteRuleTarget(context.Context, *DeleteRuleTargetReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRuleTarget not implemented")
}
func (UnimplementedRulesServer) ErrSubscribe(context.Context, *ErrSubscribeReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ErrSubscribe not implemented")
}
func (UnimplementedRulesServer) mustEmbedUnimplementedRulesServer() {}

// UnsafeRulesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RulesServer will
// result in compilation errors.
type UnsafeRulesServer interface {
	mustEmbedUnimplementedRulesServer()
}

func RegisterRulesServer(s grpc.ServiceRegistrar, srv RulesServer) {
	s.RegisterService(&Rules_ServiceDesc, srv)
}

func _Rules_RuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleCreate(ctx, req.(*RuleCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleUpdate(ctx, req.(*RuleUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleDelete(ctx, req.(*RuleDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleGet(ctx, req.(*RuleGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleQuery(ctx, req.(*RuleQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RuleStatusSwitch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleStatusSwitchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RuleStatusSwitch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RuleStatusSwitch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RuleStatusSwitch(ctx, req.(*RuleStatusSwitchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_GetRuleDevicesID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleDevicesIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).GetRuleDevicesID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/GetRuleDevicesID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).GetRuleDevicesID(ctx, req.(*RuleDevicesIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_AddDevicesToRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDevicesToRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).AddDevicesToRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/AddDevicesToRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).AddDevicesToRule(ctx, req.(*AddDevicesToRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_RemoveDevicesFromRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveDevicesFromRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).RemoveDevicesFromRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/RemoveDevicesFromRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).RemoveDevicesFromRule(ctx, req.(*RemoveDevicesFromRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_GetRuleDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuleDevicesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).GetRuleDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/GetRuleDevices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).GetRuleDevices(ctx, req.(*RuleDevicesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_CreateRuleTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRuleTargetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).CreateRuleTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/CreateRuleTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).CreateRuleTarget(ctx, req.(*CreateRuleTargetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_UpdateRuleTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRuleTargetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).UpdateRuleTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/UpdateRuleTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).UpdateRuleTarget(ctx, req.(*UpdateRuleTargetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_TestConnectToKafka_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestConnectToKafkaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).TestConnectToKafka(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/TestConnectToKafka",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).TestConnectToKafka(ctx, req.(*TestConnectToKafkaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_ListRuleTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRuleTargetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).ListRuleTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/ListRuleTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).ListRuleTarget(ctx, req.(*ListRuleTargetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_DeleteRuleTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRuleTargetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).DeleteRuleTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/DeleteRuleTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).DeleteRuleTarget(ctx, req.(*DeleteRuleTargetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_ErrSubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrSubscribeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).ErrSubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.rule.Rules/ErrSubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).ErrSubscribe(ctx, req.(*ErrSubscribeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Rules_ServiceDesc is the grpc.ServiceDesc for Rules service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Rules_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.rule.Rules",
	HandlerType: (*RulesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RuleCreate",
			Handler:    _Rules_RuleCreate_Handler,
		},
		{
			MethodName: "RuleUpdate",
			Handler:    _Rules_RuleUpdate_Handler,
		},
		{
			MethodName: "RuleDelete",
			Handler:    _Rules_RuleDelete_Handler,
		},
		{
			MethodName: "RuleGet",
			Handler:    _Rules_RuleGet_Handler,
		},
		{
			MethodName: "RuleQuery",
			Handler:    _Rules_RuleQuery_Handler,
		},
		{
			MethodName: "RuleStatusSwitch",
			Handler:    _Rules_RuleStatusSwitch_Handler,
		},
		{
			MethodName: "GetRuleDevicesID",
			Handler:    _Rules_GetRuleDevicesID_Handler,
		},
		{
			MethodName: "AddDevicesToRule",
			Handler:    _Rules_AddDevicesToRule_Handler,
		},
		{
			MethodName: "RemoveDevicesFromRule",
			Handler:    _Rules_RemoveDevicesFromRule_Handler,
		},
		{
			MethodName: "GetRuleDevices",
			Handler:    _Rules_GetRuleDevices_Handler,
		},
		{
			MethodName: "CreateRuleTarget",
			Handler:    _Rules_CreateRuleTarget_Handler,
		},
		{
			MethodName: "UpdateRuleTarget",
			Handler:    _Rules_UpdateRuleTarget_Handler,
		},
		{
			MethodName: "TestConnectToKafka",
			Handler:    _Rules_TestConnectToKafka_Handler,
		},
		{
			MethodName: "ListRuleTarget",
			Handler:    _Rules_ListRuleTarget_Handler,
		},
		{
			MethodName: "DeleteRuleTarget",
			Handler:    _Rules_DeleteRuleTarget_Handler,
		},
		{
			MethodName: "ErrSubscribe",
			Handler:    _Rules_ErrSubscribe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/rule/v1/dto_rule.proto",
}
